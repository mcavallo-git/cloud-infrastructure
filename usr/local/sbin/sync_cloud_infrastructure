#!/bin/bash
#
# LOCAL_SBIN="/usr/local/sbin/sync_cloud_infrastructure" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------------------------------------
# Sync 1-Liner ( See:  https://github.com/mcavallo-git/cloud-infrastructure/blob/master/README.md )
#
if [ 0 -eq 1 ]; then

curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -ssL "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" | bash;

fi;
#
# ------------------------------------------------------------
#
# Log all shell output & error output to logfile
#
LOGDIR="${HOME}/sync_cloud_infrastructure_logs"; if [ -w "/var/log/" ]; then LOGDIR="/var/log/sync_cloud_infrastructure"; fi;
mkdir -p "${LOGDIR}"; chown $(stat -c '%u:%g' $(dirname ${LOGDIR})) "${LOGDIR}"; chmod 0770 "${LOGDIR}";
LOGFILE="${LOGDIR}/$(basename ${LOGDIR})_$(date +'%Y%m%d')";
chmod 0660 "${LOGFILE}";
exec > >(tee -a "${LOGFILE}" );
exec 2>&1;
#
# ------------------------------------------------------------
#
# Script must run as root or via sudo
#
if [ "$(id -un)" != "root" ]; then
	echo "";
	echo "$(date +'%Y-%m-%d %H:%M:%S') | Error: Script must run as user \"root\" or via \"sudo\" command";
	exit 1;
else
	# ------------------------------------------------------------
	# Instantiate runtime variables

	START_SECONDS_NANOSECONDS=$(date +'%s.%N');
	START_EPOCHSECONDS=$(echo ${START_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 1);
	# START_NANOSECONDS=$(echo ${START_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 2 | cut --characters 1-9);
	# START_MICROSECONDS=$(echo ${START_NANOSECONDS} | cut --characters 1-6);
	# START_MILLISECONDS=$(echo ${START_NANOSECONDS} | cut --characters 1-3);
	START_DATETIME="$(date --date=@${START_EPOCHSECONDS} +'%Y-%m-%d %H:%M:%S')";
	START_TIMESTAMP="$(date --date=@${START_EPOCHSECONDS} +'%Y%m%d_%H%M%S')";

	GIT_SOURCE_REPO_URL="";

	DEFAULT_GIT_SOURCE_REPO_URL="https://github.com/mcavallo-git/cloud-infrastructure.git";

	DIRNAME_LOCAL_CONFIG="/etc/sync_cloud_infrastructure";

	# ------------------------------------------------------------
	# Make sure the Config directory exists (create it if it doesn't)
	if [ ! -d "${DIRNAME_LOCAL_CONFIG}" ]; then
		mkdir -p "${DIRNAME_LOCAL_CONFIG}";
	fi;
	if [ -d "${DIRNAME_LOCAL_CONFIG}" ] && [ -n "$(which stat 2>'/dev/null';)" ] && [ "$(stat --format '%a' ${DIRNAME_LOCAL_CONFIG})" != "755" ]; then
		chmod 755	"${DIRNAME_LOCAL_CONFIG}";
	fi;

	# Get the Git Source-Repo from the local device's config
	FILEPATH_GIT_SOURCE_REPO_URL="${DIRNAME_LOCAL_CONFIG}/git_source_repo.url";
	GIT_SOURCE_REPO_URL="${DEFAULT_GIT_SOURCE_REPO_URL}";
	if [ -f "${FILEPATH_GIT_SOURCE_REPO_URL}" ]; then
		GIT_SOURCE_REPO_URL="$(cat ${FILEPATH_GIT_SOURCE_REPO_URL};)";
	fi; 

	# Fall-back to the default Git-Repo if none is defined, locally
	if [ -z "${GIT_SOURCE_REPO_URL}" ]; then
		GIT_SOURCE_REPO_URL="${DEFAULT_GIT_SOURCE_REPO_URL}";
	fi;

	GIT_REPO_OWNER="$(basename $(dirname ${GIT_SOURCE_REPO_URL};);)";
	GIT_REPO_NAME="$(basename ${GIT_SOURCE_REPO_URL} | cut -d. -f1;)";

	# ------------------------------------------------------------
	EXIT_CODE=1; # Set status to fail by-default, and only proceed if a known good-status is reached

	GIT_LOCAL_PARENT_PATH="${HOME}/Documents/GitHub";

	GIT_LOCAL_REPO_PATH="${GIT_LOCAL_PARENT_PATH}/${GIT_REPO_NAME}/";

	WIN32_HOMEDIR="";

	DIR_REPO_BASE="";


	# ------------------------------------------------------------
	# Parse inline arguments (passed to current script)

	ARGS=("$@");
	ARGS_COUNT=${#ARGS[@]};

	ARGS_CHECK_WSL=0;
	ARGS_DEBUG_MODE=0;
	ARGS_CRONJOB_REMOVE=0;
	ARGS_CRONJOB_SYNC=0;
	ARGS_SYNC_DDNS=0;
	ARGS_SYNC_JENKINS=0;
	ARGS_SYNC_NGINX=0;
	ARGS_SYNC_SSH_CONFIG=0;
	ARGS_SYNC_TIMEZONE=0;
	ARGS_SYNC_UFW=0;

	RESTART_SERVICE_CRON=0;
	RESTART_SERVICE_JENKINS=0;
	RESTART_SERVICE_NGINX=0;
	RESTART_SERVICE_SSH=0;
	RESTART_SERVICE_UFW=0;

	# Walk through any inline-arguments passed to this function
	for (( i=0;i<$ARGS_COUNT;i++ )); do

		EACH_ARG=${ARGS[${i}]};

		# Check if this is the last inline-argument or if there are more to follow
		if [ $((${i}+1)) -eq ${ARGS_COUNT} ]; then # if this is the last argument
			NEXT_ARG="";
		else
			NEXT_ARG=${ARGS[$((${i}+1))]};
			if [[ "${NEXT_ARG}" == "--"* ]]; then # Do not allow inline-arguments starting with "--..." to use the next bash-argument as an associated value if it, also, starts with "--..."
				NEXT_ARG="";
			fi;
		fi;

		if [ -n "${EACH_ARG}" ]; then # Parse each non-empty inline argument

			# Parse cronjob calls
			if [ "${EACH_ARG}" == "--cron" ]; then
				if [ "${NEXT_ARG}" == "remove" ] && [ ${ARGS_CRONJOB_SYNC} -eq 0 ]; then
					# Remove cronjobs
					ARGS_CRONJOB_REMOVE=1;
				elif [ "${NEXT_ARG}" == "sync" ] && [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
					# Sync cronjobs
					ARGS_CRONJOB_SYNC=1;
				else
					# Error - Show user valid argument syntax
					echo "$(date +'%Y-%m-%d %H:%M:%S') | Error:  Invalid inline argument:  ${EACH_ARG} ${NEXT_ARG}";
					echo "                        |";
					echo "                        |--> Sync cron-job(s) via \"--cron sync\" argument";
					echo "                        |--> Remove synced cron-job(s) via \"--cron remove\" argument";
					echo "";
					EXIT_CODE=1;
				fi;
			fi;

			# Use "--all" inline-arg. to sync all modules
			if [ "${EACH_ARG}" == "--all" ]; then
				ARGS_CHECK_WSL=1;
				ARGS_DEBUG_MODE=1;
				ARGS_CRONJOB_REMOVE=0;
				ARGS_CRONJOB_SYNC=1;
				# ARGS_SYNC_DDNS=1;
				ARGS_SYNC_JENKINS=1;
				ARGS_SYNC_NGINX=1;
				ARGS_SYNC_SSH_CONFIG=1;
				ARGS_SYNC_TIMEZONE=1;
				ARGS_SYNC_UFW=1;
			fi;

			if [ "${EACH_ARG}" == "--remove-cronjobs" ] || [ "${EACH_ARG}" == "--remove" ]; then
				ARGS_CRONJOB_REMOVE=1; # Parse remove-cronjobs calls
			fi;

			if [ "${EACH_ARG}" == "--wsl" ] || [ "${EACH_ARG}" == "--windows" ]; then
				ARGS_CHECK_WSL=1; # Parse WSL-Check calls
			fi;

			if [ "${EACH_ARG}" == "--debug" ] || [ "${EACH_ARG}" == "--verbose" ]; then
				ARGS_DEBUG_MODE=1; # Parse Debug/Verbose Calls
			fi;

			if [ "${EACH_ARG}" == "--ddns" ]; then
				ARGS_SYNC_DDNS=1; # Parse DDNS-Sync Calls
			fi;

			if [ "${EACH_ARG}" == "--jenkins" ]; then
				ARGS_SYNC_JENKINS=1; # Parse JENKINS-Sync Calls
			fi;
			
			if [ "${EACH_ARG}" == "--nginx" ]; then
				ARGS_SYNC_NGINX=1; # Parse NGINX-Sync Calls
			fi;

			if [ "${EACH_ARG}" == "--ssh" ] || [ "${EACH_ARG}" == "--sshd" ]; then
				ARGS_SYNC_SSH_CONFIG=1; # Parse SSH-Config calls
			fi;

			if [ "${EACH_ARG}" == "-z" ] || [ "${EACH_ARG}" == "--timezone" ]; then
				ARGS_SYNC_TIMEZONE=1; # Parse Timezone-Config calls
			fi;

			if [ "${EACH_ARG}" == "--ufw" ]; then
				ARGS_SYNC_UFW=1; # Parse UFW-Sync Calls
			fi;


		fi;

	done;

	if [ ${ARGS_DEBUG_MODE} -eq 1 ]; then
		echo "";
		echo "Debug:  ARGS = [ ${ARGS} ]";
		echo "Debug:  ARGS_COUNT = [ ${ARGS_COUNT} ]";
		echo "";
		echo "Debug:  ARGS_CHECK_WSL = [ ${ARGS_CHECK_WSL} ]";
		echo "Debug:  ARGS_DEBUG_MODE = [ ${ARGS_DEBUG_MODE} ]";
		echo "Debug:  ARGS_CRONJOB_REMOVE = [ ${ARGS_CRONJOB_REMOVE} ]";
		echo "Debug:  ARGS_CRONJOB_SYNC = [ ${ARGS_CRONJOB_SYNC} ]";
		echo "Debug:  ARGS_SYNC_DDNS = [ ${ARGS_SYNC_DDNS} ]";
		echo "Debug:  ARGS_SYNC_JENKINS = [ ${ARGS_SYNC_JENKINS} ]";
		echo "Debug:  ARGS_SYNC_NGINX = [ ${ARGS_SYNC_NGINX} ]";
		echo "Debug:  ARGS_SYNC_SSH_CONFIG = [ ${ARGS_SYNC_SSH_CONFIG} ]";
		echo "Debug:  ARGS_SYNC_TIMEZONE = [ ${ARGS_SYNC_TIMEZONE} ]";
		echo "Debug:  ARGS_SYNC_UFW = [ ${ARGS_SYNC_UFW} ]";

	fi;


	# ------------------------------------------------------------
	# Make sure prerequisite-packages are installed
	unset REQUIRED_PKGS_ARRAY; declare -a REQUIRED_PKGS_ARRAY; # [Re-]Instantiate bash array
	unset MISSING_PKGS_ARRAY; declare -a MISSING_PKGS_ARRAY; # [Re-]Instantiate bash array
	REQUIRED_PKGS_ARRAY=();
	REQUIRED_PKGS_ARRAY+=("bc");
	REQUIRED_PKGS_ARRAY+=("dos2unix");
	REQUIRED_PKGS_ARRAY+=("git");
	REQUIRED_PKGS_ARRAY+=("lsof");
	REQUIRED_PKGS_ARRAY+=("rsync");
	REQUIRED_PKGS_ARRAY+=("vim-common");
	REQUIRED_PKGS_ARRAY+=("wget");

	# Debian-specific packages
	if [ $(which apt 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Debian, Ubuntu, etc.
		REQUIRED_PKGS_ARRAY+=("cron");
		REQUIRED_PKGS_ARRAY+=("jq");
		REQUIRED_PKGS_ARRAY+=("sslscan");
	elif [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
		REQUIRED_PKGS_ARRAY+=("bind-utils");
		REQUIRED_PKGS_ARRAY+=("policycoreutils-devel");
		# Install the "jq" (JSON Parser) package manually for RHEL distros
		if [ ! -f "/usr/bin/jq" ] || [[ -f "/usr/bin/jq" && $(stat --printf="%s" "/usr/bin/jq";) -le 1000 ]]; then # stat command is for hotfix on invalid downloads
			curl -o "/usr/bin/jq" -ssL "https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" && chmod 0755 "/usr/bin/jq";
		fi;
	fi;

	# Determine if any required packages are missing
	for EACH_REQUIRED_PKG in "${REQUIRED_PKGS_ARRAY[@]}"; do
		if [ -n "${EACH_REQUIRED_PKG}" ]; then
			if [ $(which dpkg 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Debian, Ubuntu, etc.
				# Query Debian's Package-Manager for each package
				if [ $(dpkg -l "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]; then
					MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
				fi;
			elif [ $(which rpm 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
				# Query RHEL's Package-Manager for each package
				if [ $(rpm --quiet --query "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]; then
					MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
				fi;
			else # Other distros
				if [ "$(which ${EACH_REQUIRED_PKG} 1>'/dev/null' 2>&1; echo $?;)" != "0" ]; then
					MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
				fi;
			fi;
		fi;
	done;

	# If any packages were found to be missing, install them
	if [ ${#MISSING_PKGS_ARRAY[@]} -ne 0 ]; then
		if [ ${ARGS_DEBUG_MODE} -eq 1 ]; then
			echo -e "\n""Debug:  MISSING_PKGS_ARRAY = [ ${MISSING_PKGS_ARRAY[@]} ]";
		fi;
		# Bulk install all packages
		if [ $(which apt 2>'/dev/null' | wc -l;) -gt 0 ]; then
			# Debian distros (Ubuntu, Raspbian, etc.)
			echo -e "\n""Info:  Calling [ apt-get update -y && apt-get install -y ${MISSING_PKGS_ARRAY[@]}; ]...";
			apt-get -y update; apt-get -y install ${MISSING_PKGS_ARRAY[@]};

		elif [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then
			# RHEL, CentOS
			echo -e "\n""Info:  Calling [ yum check-update -y && yum install -y ${MISSING_PKGS_ARRAY[@]}; ]...";
			yum check-update -y; yum -y install ${MISSING_PKGS_ARRAY[@]};

		elif [ $(which apk 2>'/dev/null' | wc -l;) -gt 0 ]; then
			# Alpine
			echo -e "\n""Info:  Calling [ apk update -y && apk add -y ${MISSING_PKGS_ARRAY[@]}; ]...";
			apk update -y; apk add -y ${MISSING_PKGS_ARRAY[@]};

		fi;

		# Verify that all required packages (which are needed later in this script) are installed as-intended
		unset FAILED_INSTALL_PKGS_ARRAY; declare -a FAILED_INSTALL_PKGS_ARRAY; # [Re-]Instantiate bash array
		for EACH_REQUIRED_PKG in "${REQUIRED_PKGS_ARRAY[@]}"; do
			if [ $(which apt 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Debian, Ubuntu, etc.
				# Query Debian's Package-Manager for each package
				if [ $(dpkg -l "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]; then
					FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
				fi;
			elif [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
				# Query RHEL's Package-Manager for each package
				if [ $(rpm --quiet --query "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]; then
					FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
				fi;
			else # Other distros
				if [ "$(which ${EACH_REQUIRED_PKG} 1>'/dev/null' 2>&1; echo $?;)" != "0" ]; then
					FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
				fi;
			fi;
		done;

		if [ ${#FAILED_INSTALL_PKGS_ARRAY[@]} -ne 0 ]; then
			# echo -e "\n""Warning : Attempting fallback (manual/hardcode) package installation-method";
			# RET_CODE=1
			# if [ $(which apt 2>'/dev/null' | wc -l;) -gt 0 ]; then
			# 	echo "Info:  Calling [ apt-get -y update; apt-get -y install bc dos2unix git rsync vim wget; ]...";
			# 	apt-get -y update; apt-get -y install bc dos2unix git rsync vim wget; RET_CODE=$?;
			# elif [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then
			# 	echo "Info:  Calling [ yum check-update -y && yum -y install bc dos2unix git rsync vim wget; ]...";
			# 	yum -y check-update; yum -y install bc dos2unix git rsync vim wget; RET_CODE=$?;
			# elif [ $(which apk 2>'/dev/null' | wc -l;) -gt 0 ]; then
			# 	echo "Info:  Calling [ apk update -y; apk add -y bc dos2unix git rsync vim wget; ]...";
			# 	apk update -y; apk add -y bc dos2unix git rsync vim wget; RET_CODE=$?;
			# fi;
			# if [ ${RET_CODE} -ne 0 ]; then 
				echo -e "\n""Error: Unable to install package(s):  [ ${FAILED_INSTALL_PKGS_ARRAY[@]} ]";
				# sleep 60;
				EXIT_CODE=1;
			# fi;
		fi;
		
	fi;


	# ------------------------------------------------------------
	# Update-Self - If the local script's checksum is different than the source-script's checksum, then update the local to match the source
	CHECKSUM_LOCAL=$(if [ -f "/usr/local/sbin/sync_cloud_infrastructure" ]; then cat "/usr/local/sbin/sync_cloud_infrastructure" | cksum | cut -d" " -f1; else echo 0; fi;);
	CHECKSUM_SOURCE=$(curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -ssL "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" | cksum | cut -d" " -f1);
	if [ ${ARGS_DEBUG_MODE} -eq 1 ]; then
		echo "";
		echo "Debug:  CHECKSUM_SOURCE = [ ${CHECKSUM_SOURCE} ]";
		echo "Debug:  CHECKSUM_LOCAL  = [ ${CHECKSUM_LOCAL} ]";
	fi;
	if [ "${CHECKSUM_SOURCE}" != "${CHECKSUM_LOCAL}" ]; then
		#####  Sync 1-liner  -->  Pull the raw version of the file directly out of GitHub
		echo -e "\n""Info:  Updating local runtime \"/usr/local/sbin/sync_cloud_infrastructure\"...";
		BENCHMARK_START=$(date +'%s.%N');
		curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -ssL "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" -o "/usr/local/sbin/sync_cloud_infrastructure" && chmod 0755 "/usr/local/sbin/sync_cloud_infrastructure";
		BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
		test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

		"/usr/local/sbin/sync_cloud_infrastructure" $@;
		exit 0;

	else
		# ------------------------------------------------------------
		# Ensure the (GitHub) Repos directory exists, locally
		if [ ! -d "${GIT_LOCAL_PARENT_PATH}" ]; then
			mkdir -p "${GIT_LOCAL_PARENT_PATH}";
		fi;


		# ------------------------------------------------------------
		# Fetch/Pull/Clone the Remote Repo
		echo -e "\n""Info:  Pulling the latest revision of the \"${GIT_REPO_NAME}\" repository";
		echo "  |--> Source (URL):        ${GIT_SOURCE_REPO_URL}";
		echo "  |--> Destination (Path):  ${GIT_LOCAL_REPO_PATH}";
		BENCHMARK_START=$(date +'%s.%N');
		# Clone the repo if it hasn't been synced, yet
		if [ ! -d "${GIT_LOCAL_REPO_PATH}" ]; then
			cd "${GIT_LOCAL_PARENT_PATH}" && \
			git clone --quiet "${GIT_SOURCE_REPO_URL}";
		fi;
		# Sync local workstation's commands with the repo's commands
		cd "${GIT_LOCAL_REPO_PATH}" && \
		git fetch --quiet && \
		git reset --quiet --hard "origin/master" && \
		git pull --quiet;
		BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
		test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

		# ------------------------------------------------------------
		# Set ownership for git-repo files as-intended
		echo -e "\n""Info:  Setting ownership for directories within the \"${GIT_REPO_NAME}\" synced repository";
		BENCHMARK_START=$(date +'%s.%N');
		# find "${GIT_LOCAL_REPO_PATH}" -type d -exec chmod 0700 "{}" ";"; # directories, find + chmod
		find "${GIT_LOCAL_REPO_PATH}" -type d -print0 | xargs -0 chmod 0700; # directories, xargs + chmod
		BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
		test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

		# Set ownership for git-repo directories as-intended
		echo -e "\n""Info:  Setting ownership for files within the \"${GIT_REPO_NAME}\" synced repository";
		BENCHMARK_START=$(date +'%s.%N');
		# find "${GIT_LOCAL_REPO_PATH}" -type f -exec chmod 0600 "{}" ";"; # files, find + chmod
		find "${GIT_LOCAL_REPO_PATH}" -type f -print0 | xargs -0 chmod 0600; # files, xargs + chmod
		BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
		test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


		# ------------------------------------------------------------
		# Check for (Detect/Handle) WSL instance(s)
		if [ ${ARGS_CHECK_WSL} -eq 1 ]; then
			WSL_CHECK_EXISTS=$(which wsl_get_windows_username 2>'/dev/null');
			if [ -n "${WSL_CHECK_EXISTS}" ]; then
				echo -e "\n""Info:  Checking for Windows Subsystem for Linux (WSL) Environment";
				WIN32_USERNAME=$(wsl_get_windows_username);
				WIN32_USER_ERRORS="$?";
			fi;
			
			if [ -n "${WIN32_USERNAME}" ] && [ -n "${WIN32_USER_ERRORS}" ] && [ "${WIN32_USER_ERRORS}" == "0" ]; then
				#  Windows OS running WSL (Windows Subsystem for Linux) - Locate source directory from amongst Win32-Host-User's files
				echo -e "\n""Info:  Detected [ Windows Subsystem for Linux (WSL) ] Environment - Checking for local repo files";
				WIN32_HOMEDIR=$(find /mnt/*/Users/${WIN32_USERNAME} -mindepth 0 -maxdepth 0 -type d);
				WIN32_USR_LOCAL=$(find ${WIN32_HOMEDIR}/Documents -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
				if [ ! -n "${WIN32_USR_LOCAL}" ]; then
					echo "";
					echo "Error:  Unable to locate directory matching '${GIT_REPO_NAME}/usr/local' within win32-user's documents @ '${WIN32_USERNAME}'";
					EXIT_CODE=1;
				else
					DIR_REPO_USR="$(dirname ${WIN32_USR_LOCAL})";
					DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
				fi;
			fi;
		fi;


		# ------------------------------------------------------------
		if [ ! -v WIN32_HOMEDIR ] || [ -z "${WIN32_HOMEDIR}" ]; then
			# If Windows/WSL check(s) failed (or were skipped), push forwards by checking for required Linux filepath(s)
			# echo -e "\n""Info:  Unset/Empty variable: \${WIN32_HOMEDIR} ";
			echo -e "\n""Info:  Checking for local repository files within user [ $(whoami) ]'s home-directory";
			BENCHMARK_START=$(date +'%s.%N');
			WHOAMI_HOME_DIR="$(getent passwd $(id -un) | cut --delimiter=: --fields=6)";
			WHOAMI_USR_LOCAL=$(find ${WHOAMI_HOME_DIR} -mindepth 2 -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
			DIR_REPO_USR="$(dirname ${WHOAMI_USR_LOCAL})";
			DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
			RET_CODE=$?;
			if [ ${RET_CODE} -eq 0 ]; then
				echo "  |--> Using [ $(whoami) ] user's repository directory @ [ ${DIR_REPO_BASE} ]";
			else 
				if [ -v SUDO_USER ] && [ -n "${SUDO_USER}" ]; then
					#  Linux OS - Locate source directory from amongst Non-Sudo User's files
					echo "  |--> Repository not found within [ $(whoami) ] user's home-directory";
					echo "  |--> Checking for local repository files within [ ${SUDO_USER} ] user's home-directory";
					BENCHMARK_START=$(date +'%s.%N');
					SUDOER_HOME_DIR="$(getent passwd ${SUDO_USER} | cut --delimiter=: --fields=6)";
					SUDOER_USR_LOCAL=$(find ${SUDOER_HOME_DIR} -mindepth 2 -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
					DIR_REPO_USR="$(dirname ${SUDOER_USR_LOCAL})";
					DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
					RET_CODE=$?;
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					if [ ${RET_CODE} -eq 0 ]; then
						echo "  |--> Using [ ${SUDO_USER} ] user's repository directory @ [ ${DIR_REPO_BASE} ]";
					fi;
				fi;
			fi;
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


		else
			# Running WSL on Windows-based OS

			# Create link to repo-manuals
			WSL_DIR="${WIN32_HOMEDIR}/Documents/GitHub/CodingPrivate/man";
			if [ -d "${WSL_DIR}" ]; then
				# Current User 
				if [ -d "${HOME}" ] && [ ! -h "${HOME}/$(basename ${WSL_DIR})" ]; then
					ln -sf "${WSL_DIR}" "${HOME}/$(basename ${WSL_DIR})";
				fi;
				if [ -v SUDO_USER ]; then
					# Sudoer User (also create link in default user's homedir)
					SUDOER_HOMEDIR="$(getent passwd ${SUDO_USER} | cut -d: -f 6;)";
					if [ -d "${SUDOER_HOMEDIR}" ]; then
						if [ ! -h "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]; then
							ln -sf "${WSL_DIR}" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
						fi;
						chown --no-dereference "${SUDO_USER}:$(id -gn ${SUDO_USER})" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
					fi;
				fi;
			fi;
			
			# Create link to Desktop
			WSL_DIR="${WIN32_HOMEDIR}/Desktop";
			if [ -d "${WSL_DIR}" ]; then
				# Current User 
				if [ -d "${HOME}" ] && [ ! -h "${HOME}/$(basename ${WSL_DIR})" ]; then
					ln -sf "${WSL_DIR}" "${HOME}/$(basename ${WSL_DIR})";
				fi;
				if [ -v SUDO_USER ]; then
					# Sudoer User (also create link in default user's homedir)
					SUDOER_HOMEDIR="$(getent passwd ${SUDO_USER} | cut -d: -f 6;)";
					if [ -d "${SUDOER_HOMEDIR}" ]; then
						if [ ! -h "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]; then
							ln -sf "${WSL_DIR}" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
						fi;
						chown --no-dereference "${SUDO_USER}:$(id -gn ${SUDO_USER})" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
					fi;
				fi;
			fi;

		fi;

		# ------------------------------------------------------------
		if [ -z "${DIR_REPO_BASE}" ]; then
			# Error-out if any required variable(s) are empty/unset
			EXIT_CODE=1;

			echo "";
			echo "Error:  Required variable found to be empty/unset: \${DIR_REPO_BASE}";

		elif [ ! -d "${DIR_REPO_BASE}/usr/local/bin/" ] || [ ! -d "${DIR_REPO_BASE}/usr/local/sbin/" ]; then
			# Error-out if any required source directories are missing
			EXIT_CODE=1;

			if [ ! -d "${DIR_REPO_BASE}/usr/local/bin/" ]; then
				echo "";
				echo "Error:  Directory not-found: [ ${DIR_REPO_BASE}/usr/local/bin/ ]";
			fi;
			if [ ! -d "${DIR_REPO_BASE}/usr/local/sbin/" ]; then
				echo "";
				echo "Error:  Directory not-found: [ ${DIR_REPO_BASE}/usr/local/sbin/ ]";
			fi;

		else
			# Required source directory/directories exist --> Sync them to local workstation/server
			EXIT_CODE=0;
			
			
			# ------------------------------------------------------------
			#
			# /usr/local/bin
			#
			DESTINATION_PATH="/usr/local/bin";
			SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
			FILE_PERMS="0755"; DIR_PERMS="0755";
			echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
			BENCHMARK_START=$(date +'%s.%N');
			rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
			chown -R "root:root" "${DESTINATION_PATH}";
			find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
			find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
			if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
			dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


			# ------------------------------------------------------------
			#
			# /usr/local/sbin
			#
			DESTINATION_PATH="/usr/local/sbin";
			SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
			FILE_PERMS="0755"; DIR_PERMS="0755";
			echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
			BENCHMARK_START=$(date +'%s.%N');
			rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
			chown -R "root:root" "${DESTINATION_PATH}";
			find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
			find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
			if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
			dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


			# ------------------------------------------------------------
			#
			# /etc/profile
			#
			if [ $(sed -rne 's/^MAIL=""$/\0/p' '/etc/profile' | wc -l 2>'/dev/null';) -eq 0 ]; then
				if [ $(sed -rne 's/^(\s*export ?.*)( MAIL)( ?.*)$/\0/p' '/etc/profile' | wc -l 2>'/dev/null';) -gt 0 ]; then
					### Bash - Disable "You have mail in ..." && "You have new mail in /var/spool/mail/..." alerts
					BENCHMARK_START=$(date +'%s.%N');
					echo -e "\n""Info:  Disabling \"You have new mail in ...\" alerts (commenting MAIL=... in \"/etc/profile\")";
					sed -i".${START_TIMESTAMP}.bak" -r -e 's/^ *MAIL=".+"/#\0/p' "/etc/profile"; # Comment out all lines which set variable  [ MAIL ]  to anything OTHER THAN an empty string ("")
					sed -i".${START_TIMESTAMP}.bak" -r -e '/^ *export ?.* MAIL ?.*/{' -e 'i\MAIL=""' -e '}' "/etc/profile"; # Remove MAIL from the  [ export ... ]  variables
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
				fi;
			fi;


			# ------------------------------------------------------------
			#
			# /etc/pki/ca-trust/source/anchors  (Server root-certificates & CA-bundles)
			#
			if [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
				DESTINATION_PATH="/etc/pki/ca-trust/source/anchors";
				SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
				FILE_PERMS="0644"; DIR_PERMS="0644";
				echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
				BENCHMARK_START=$(date +'%s.%N');
				rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
				chown -R "root:root" "${DESTINATION_PATH}";
				find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
				find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
				if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
				dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
				BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
				test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

				## Reference:  https://manuals.gfi.com/en/kerio/connect/content/server-configuration/ssl-certificates/adding-trusted-root-certificates-to-the-server-1605.html
				update-ca-trust force-enable;
				update-ca-trust extract; ## Update for Rhel/Centos

			fi;


			# ------------------------------------------------------------
			#
			# /etc/profile.d/required_paths.sh
			#
			DESTINATION_PATH="/etc/profile.d/required_paths.sh";
			SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
			FILE_PERMS="0644"; DIR_PERMS="0644";
			echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
			BENCHMARK_START=$(date +'%s.%N');
			rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
			chown -R "root:root" "${DESTINATION_PATH}";
			find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
			find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
			if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
			dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


			# ------------------------------------------------------------
			#
			# /etc/profile.d/bash_history_logging.sh
			#
			DESTINATION_PATH="/etc/profile.d/bash_history_logging.sh";
			SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
			FILE_PERMS="0644"; DIR_PERMS="0644";
			echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
			BENCHMARK_START=$(date +'%s.%N');
			rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
			chown -R "root:root" "${DESTINATION_PATH}";
			find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
			find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
			if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
			dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


			# ------------------------------------------------------------
			#
			# /etc/whitelist.d
			#
			DESTINATION_PATH="/etc/whitelist.d";
			SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
			FILE_PERMS="0644"; DIR_PERMS="0755";
			echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
			BENCHMARK_START=$(date +'%s.%N');
			rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
			chown -R "root:root" "${DESTINATION_PATH}";
			find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
			find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
			if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
			dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


			# ------------------------------------------------------------
			#
			# /etc/ssh/sshd_config
			#
			if [ ${ARGS_SYNC_SSH_CONFIG} -eq 1 ]; then

				if [ -z "$(which ssh 2>'/dev/null')" ]; then
					echo "Info:  Skipped SSH Config-Update (command \"ssh\" not found)";

				else
					
					# Backup & Update the sshd_config (SSH Server) file
					SSHD_CONFIG_LIVE="/etc/ssh/sshd_config";
					SSHD_CONFIG_MFA="${SSHD_CONFIG_LIVE}.mfa"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_MFA}" "${SSHD_CONFIG_MFA}";
					SSHD_CONFIG_NO_MFA="${SSHD_CONFIG_LIVE}.no_mfa"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_NO_MFA}" "${SSHD_CONFIG_NO_MFA}";
					SSHD_CONFIG_PASS_AUTH="${SSHD_CONFIG_LIVE}.password_auth"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_PASS_AUTH}" "${SSHD_CONFIG_PASS_AUTH}";
					SSHD_CONFIG_SED="${SSHD_CONFIG_LIVE}.sed";

					if [ -d "/etc/ssh/authorized_keys" ] && [ "$(find /etc/ssh/authorized_keys -type f | wc -l;)" != "0" ]; then
						# Set ownership of "/etc/ssh/authorized_keys" directory as-intended
						### chmod 0755 "/etc/ssh/authorized_keys";  # Keep for reference on intended permissions for "/etc/ssh/authorized_keys" (chmod 0755 as-of 20200310-063820)
						# At least one SSH-Key exists in the standard keyfile directory (/etc/ssh/authorized_keys)
						MFA_CONFIG_LOGIN_DUO="/etc/duo/login_duo.conf";
						MFA_CONFIG_PAM_DUO="/etc/duo/pam_duo.conf";
						if [ -f "${MFA_CONFIG_PAM_DUO}" ] || [ -f "${MFA_CONFIG_LOGIN_DUO}" ]; then
							# Duo MFA Installed --> Use it (through PAM) for SSH-Authentication
							SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_MFA}";
						else
							# No MFA, but at least one SSH-Key exists
							SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_NO_MFA}";
						fi;
					else
						# No SSH Key(s) exist in the standard keyfile directory (/etc/ssh/authorized_keys) --> Allow passwords, for now
						SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_PASS_AUTH}";
					fi;

					dos2unix --quiet "${SSHD_CONFIG_LIVE}";
					dos2unix --quiet "${SSHD_CONFIG_REPLACEMENT}";
					if [ $(cmp -s "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_REPLACEMENT}" 1>'/dev/null' 2>&1; echo $?;) -eq 0 ]; then
						# SSH-Config file already fully up-to-date
						echo -e "\n""Info:  Skipped update to SSH-Config file \"${SSHD_CONFIG_LIVE}\"";
						echo "  |--> Checksum already up-to-date with \"$(basename ${SSHD_CONFIG_REPLACEMENT})\"";

					elif [ ! -d "/home/" ] || [ $(find '/home/' -mindepth 1 -maxdepth 1 | wc -l 2>'/dev/null') -eq 0 ]; then
						# Need another user other than root to SSH into this machine --> No user directories found in /home/.
						echo -e "\n""Info:  Skipped SSH Config-Update (must create at least one user other than root to access this workstation (with home directory within  [ /home/. ] )";

					elif [ ! -d "/etc/ssh/authorized_keys/" ] || [ $(find '/etc/ssh/authorized_keys/' -mindepth 1 -maxdepth 1 | wc -l 2>'/dev/null') -eq 0 ]; then
						# Need at least one SSH-Key to exist in /etc/ssh/authorized_keys/.
						echo -e "\n""Info:  Skipped SSH Config-Update (must create at least one private-key/public-key combo, with the public key residing @  [ /etc/ssh/authorized_keys/$SUDO_USER ] )";

					else
						# At least one Tell the user to make sure and open a new SSH terminal to avoid being locked-out of the server
						ECHO_SSH_WARNING="";
						ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n!!! Warning !!!";
						ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
						ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |--> Update to SSH Configuration Requested";
						ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
						ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |--> To avoid being locked-out, ensure you have a separate SSH connection open (aside from this terminal) before continuing";
						ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
						ECHO_SSH_CONFIRMATION="  |--> Update \"/etc/ssh/sshd_config\", now? - If you are unsure, press \"n\"  (y/n)  ";

						if [ $(which apt 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Debian, Ubuntu, etc.
							# Require user-confirmation to proceed with config-update
							echo -e "${ECHO_SSH_WARNING}";
							read -p "${ECHO_SSH_CONFIRMATION}" -n 1 -t 60 -r; # Await single keypress
							echo "  |";
							if [ -z "${REPLY}" ] || [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" != "Y" ]; then
								# User declined the config-update
								echo -e "  |--> Info:  Skipped SSH Config-Update (user opt-out)";
							else
								# User accepted/confirmed the config-update
								echo -e "  |--> Info:  Updating SSH-Config file \"${SSHD_CONFIG_LIVE}\"";
								echo -e "  |--> Info:  Replacing with contents from file \"${SSHD_CONFIG_REPLACEMENT}\"";
								# Backup & Update the sshd_config (SSH Server) file
								BENCHMARK_START=$(date +'%s.%N');
								cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_LIVE}.${START_TIMESTAMP}.bak" \
									&& wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/master${SSHD_CONFIG_REPLACEMENT}" -O "${SSHD_CONFIG_REPLACEMENT}" -q \
									&& chmod 0644 "${SSHD_CONFIG_REPLACEMENT}" \
									&& cp -f "${SSHD_CONFIG_REPLACEMENT}" "${SSHD_CONFIG_LIVE}" \
									&& RESTART_SERVICE_SSH=1;
								BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
								test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
							fi;

						elif [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.

							# Amongst other things, disable the "root" user and require that users login with SSH private keys (deny password-based login)
							BENCHMARK_START=$(date +'%s.%N');
							cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_SED}";
							chmod 0644 "${SSHD_CONFIG_SED}";
							sed -r -i \
								-e "/^#?AuthorizedKeysFile/c\AuthorizedKeysFile /etc/ssh/authorized_keys/%u" \
								-e "/^#?AuthenticationMethods/c\AuthenticationMethods publickey" \
								-e "/^#?ChallengeResponseAuthentication/c\ChallengeResponseAuthentication no" \
								-e "/^#?LogLevel/c\LogLevel INFO" \
								-e "/^#?PasswordAuthentication/c\PasswordAuthentication no" \
								-e "/^#?PermitEmptyPasswords/c\PermitEmptyPasswords no" \
								-e "/^#?PermitRootLogin/c\PermitRootLogin no" \
								-e "/^#?PubkeyAuthentication/c\PubkeyAuthentication yes" \
								-e "/^#?SyslogFacility/c\SyslogFacility AUTH" \
								-e "/^#?TCPKeepAlive/c\TCPKeepAlive no" \
								-e "/^#?UseDNS/c\UseDNS no" \
								-e "/^#?UsePAM/c\UsePAM yes" \
								"${SSHD_CONFIG_SED}";

							# Remove duplicated lines in a target file (while keeping one copy of each line)
							echo "$(tac ${SSHD_CONFIG_SED};)" > "${SSHD_CONFIG_SED}";
							echo "$(cat -n ${SSHD_CONFIG_SED} | sort -uk2 | sort -nk1 | cut -f2-;)" > "${SSHD_CONFIG_SED}";
							echo "$(tac ${SSHD_CONFIG_SED};)" > "${SSHD_CONFIG_SED}";

							# Update the service's config-file only if its checksum is not the same as the updated config-file's checksum
							CHECKSUM_SOURCE=$(cat "${SSHD_CONFIG_LIVE}" | cksum | cut -d" " -f1;);
							CHECKSUM_UPDATED=$(cat "${SSHD_CONFIG_SED}" | cksum | cut -d" " -f1;);
							if [ "${CHECKSUM_SOURCE}" != "${CHECKSUM_UPDATED}" ]; then
								# Require user-confirmation to proceed with config-update
								echo -e "${ECHO_SSH_WARNING}";
								read -p "${ECHO_SSH_CONFIRMATION}" -n 1 -t 60 -r; # Await single keypress
								echo "  |";
								if [ -z "${REPLY}" ] || [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" != "Y" ]; then
									# User declined the config-update
									echo -e "  |--> Info:  Skipped SSH Config-Update (user opt-out)";
								else
									# User accepted/confirmed the config-update
									echo -e "  |--> Info:  Updating SSH-Config file \"${SSHD_CONFIG_LIVE}\"";
									echo -e "  |--> Info:  Replacing with contents from file \"${SSHD_CONFIG_SED}\"";
									cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_LIVE}.${START_TIMESTAMP}.bak" \
										&& cp -f "${SSHD_CONFIG_SED}" "${SSHD_CONFIG_LIVE}" \
										&& RESTART_SERVICE_SSH=1;
								fi;
							else
								echo -e "\n""Info:  Skipped SSH Config-Update (checksum already equal to \"${SSHD_CONFIG_SED}\")";
							fi;
							BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
							test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
						fi;

					fi;

				fi;
			fi;


			# ------------------------------------------------------------
			# Sync Timezone
			TZ="America/Chicago";
			if [ ${ARGS_SYNC_TIMEZONE} -eq 1 ] && [ "$(cat /etc/timezone;)" != "${TZ}" ]; then
					echo -e "\n";
					echo "Info:  Request to set Timezone to \"${TZ}\"";
					read -p "  |--> Set Timezone, now? (y/n)  " -n 1 -t 60 -r; # Await single keypress
					echo "";
					if [[ $REPLY =~ ^[Yy]$ ]]; then
						ln -snf "/usr/share/zoneinfo/$TZ" "/etc/localtime";
						echo $TZ > "/etc/timezone";
					fi;
				fi;
			fi;


			# ------------------------------------------------------------
			# Sync UFW ("Uncomplicated Firewall")
			ENABLE_CRON_DDNS_UPDATER=0;
			if [ ${ARGS_SYNC_UFW} -eq 1 ]; then
				# Ensure that the UFW module exists on the current Linux Distro before continuing to setting it up
				if [ $(which ufw 2>'/dev/null' | wc -l) -gt 0 ]; then
					# Check for base-level errors with the UFW runtime (usually from Windows Subsystem for Linux + IPTables)
					if [[ $(ufw status 1>'/dev/null' 2>&1; echo $?;) -eq 0 ]]; then
						# Check UFW Enabled/Disabled Status
						UFW_ENABLED=$(test -n "$(ufw status | grep 'Status' | grep 'inactive')" && echo 0 || echo 1;);
						if [ ${ARGS_DEBUG_MODE} -eq 1 ]; then
							echo -e "\n""Debug:  UFW_ENABLED = [ ${UFW_ENABLED} ]";
						fi;
						if [ ${UFW_ENABLED} -eq 0 ]; then

							# UFW DISABLED - Show recommendations for general-practice setup
							echo -e "\n""!!! Warning !!!";
							echo "  |";
							echo "  |--> Firewall package UFW (default Debian firewall) is installed but disabled";
							echo "  |";
							echo "  |--> Recommend applying the following ruleset, enabling UFW, then tweaking rules as-needed:";
							echo "         ufw allow from 10.0.0.0/8 to any port 22;  # allow ssh/sftp-requests (22) over LAN subnet (defined in RFC-1918)";
							echo "         ufw allow from 172.16.0.0/12 to any port 22;  # allow ssh/sftp-requests (22) over LAN subnet (defined in RFC-1918)";
							echo "         ufw allow from 192.168.0.0/16 to any port 22;  # allow ssh/sftp-requests (22) over LAN subnet (defined in RFC-1918)";
							echo "         ## ufw allow 22/tcp;  # allow ssh/sftp-requests (22)  !!! Only apply if you don't know ipv4s to allow access-to";
							echo "         ufw allow 80/tcp;  # allow web-requests (80)";
							echo "         ufw allow 443/tcp; # allow web-requests (443)";
							echo "         ufw default deny incoming;  # deny all non-matched incoming requests";
							echo "         ufw default allow outgoing; # allow all non-matched outgoing requests";
							echo "         ufw logging on; # enable logging";
							echo "         ufw enable; # enforce all ufw rules, including aforementioned 'allow' and 'deny' rules (if applied)";
							echo "         # Add / remove / tweak UFW rules as-needed (based on machine's environment and designated purpose)";

							# UFW DISABLED - Prompt for confirmation before auto-enabling UFW (and potentially locking user out of being able to access the machine)
							# echo "  |";
							# echo "  |--> UFW sync requested, however UFW is currently disabled";
							# echo "  |";
							# read -p "  |--> Enable UFW, now? - If you are unsure, press \"n\"  (y/n)  " -n 1 -t 60 -r; # Await single keypress
							# if [ -n "${REPLY}" ] && [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" == "Y" ]; then
							# 	ufw enable;
							# 	# Re-check UFW Enabled/Disabled Status
							# 	UFW_ENABLED=$(test -n "$(ufw status | grep 'Status' | grep 'inactive')" && echo 0 || echo 1;);
							# 	if [ ${ARGS_DEBUG_MODE} -eq 1 ]; then
							# 		echo -e "\n""Debug:  UFW_ENABLED = [ ${UFW_ENABLED} ]";
							# 	fi;
							# fi;

						fi;

						# Proceed if UFW is, indeed, enabled
						if [ ${UFW_ENABLED} -eq 1 ]; then

							RESTART_SERVICE_UFW=1;
							RESTART_SERVICE_SSH=1;

							# Sync Cronjob Automation:  UFW DDNS Updates
							if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
								ENABLE_CRON_DDNS_UPDATER=1;
							fi;
						fi;

					fi;

				elif [ $(which firewall-cmd 2>'/dev/null' | wc -l) -gt 0 ]; then

					if [ $(systemctl is-enabled firewalld 1>'/dev/null' 2>&1; echo $?) -eq 0 ]; then
						ENABLE_CRON_DDNS_UPDATER=1;
					fi;

				fi;
				
				if [ ${ENABLE_CRON_DDNS_UPDATER} -ne 0 ]; then
					CRON_DDNS_UFW_UPDATE="/etc/cron.d/CRON_ddns_ufw_update";
					echo -e "\n""Info:  Updating \"${CRON_DDNS_UFW_UPDATE}\" with changes from \"${GIT_REPO_NAME}\" repository";
					BENCHMARK_START=$(date +'%s.%N');
					wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/master${CRON_DDNS_UFW_UPDATE}" -O "${CRON_DDNS_UFW_UPDATE}" -q \
						&& chmod 0644 "${CRON_DDNS_UFW_UPDATE}" \
						&& RESTART_SERVICE_CRON=1;
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
				fi;

			fi;


			# ------------------------------------------------------------
			#
			# /etc/cron.d/...
			#
			if [ ${ARGS_CRONJOB_SYNC} -eq 1 ]; then
				RESTART_SERVICE_CRON=1;

				# ------------------------------------------------------------
				#
				# /etc/cron.d/CRON_sync_cloud_infrastructure
				#
				DESTINATION_PATH="/etc/cron.d/CRON_sync_cloud_infrastructure";
				SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
				FILE_PERMS="0644"; DIR_PERMS="0644";
				echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
				BENCHMARK_START=$(date +'%s.%N');
				rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
				chown -R "root:root" "${DESTINATION_PATH}";
				find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
				find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
				if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
				dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
				BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
				test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

				# ------------------------------------------------------------
				#
				# /etc/cron.d/CRON_certbot_renew_all
				#
				if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
					if [ $(which certbot 1>'/dev/null' 2>&1; echo $?;) -eq 0 ]; then
						DESTINATION_PATH="/etc/cron.d/CRON_certbot_renew_all";
						if [ -f "${DESTINATION_PATH}" ]; then
							REPLY="y";
						else
							echo ""; read -p "Setup SSL/TLS (HTTPS) certificate auto-renewal (Weekly, Sundays @ 06:10 AM) via \"certbot_renew_all\"? (y/n)  " -n 1 -t 60 -r; # Await single keypress
						fi;
						if [ -n "${REPLY}" ] && [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" == "Y" ]; then
							SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
							FILE_PERMS="0644"; DIR_PERMS="0644";
							echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
							BENCHMARK_START=$(date +'%s.%N');
							rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
							chown -R "root:root" "${DESTINATION_PATH}";
							find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
							find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
							if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
							dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
							BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
							test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
						else
							echo "Info:  Skipped DNS-Server Sync";
						fi;
					fi;
				fi;

				# ------------------------------------------------------------
				#
				# /etc/cron.d/CRON_update_dns_config
				#
				if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
					DESTINATION_PATH="/etc/cron.d/CRON_update_dns_config";
					if [ -f "${DESTINATION_PATH}" ]; then
						REPLY="y";
					else
						echo ""; read -p "Setup DNS-Server Sync (daily @ 04:05 AM) via \"update_dns_config\"? (y/n)  " -n 1 -t 60 -r; # Await single keypress
					fi;
					if [ -n "${REPLY}" ] && [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" == "Y" ]; then
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
					else
						echo "Info:  Skipped DNS-Server Sync";
					fi;
				fi;

				# ------------------------------------------------------------
				#
				# /etc/cron.d/CRON_update_system
				#
				if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
					DESTINATION_PATH="/etc/cron.d/CRON_update_system";
					if [ -f "${DESTINATION_PATH}" ]; then
						REPLY="y";
					else
						echo ""; read -p "Setup Automatic Updates (Weekly, Sunday @ 04:10 AM) via \"update_system\"? (y/n)  " -n 1 -t 60 -r; # Await single keypress
					fi;

					if [ -n "${REPLY}" ] && [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" == "Y" ]; then
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
					else
						echo "Info:  Skipped Automatic Updates";
					fi;
				fi;

				# ------------------------------------------------------------
				#
				# /etc/cron.d/CRON_raspi_hw_monitor
				#
				if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
					RaspberryPi_Check=$(grep 'Hardware' '/proc/cpuinfo' | sed --regexp-extended --quiet --expression='s/^Hardware\s*:\s*([a-zA-Z0-9]+)\s*$/\1/p');
					if [ "${RaspberryPi_Check}" == "BCM2835" ]; then
						DESTINATION_PATH="/etc/cron.d/CRON_raspi_hw_monitor";
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
					fi;
				fi;

			fi;


			# ------------------------------------------------------------
			#
			# ${HOME}/.
			#

			# Get list of files to Copy into Home-Dirs
			COPY_FROM_SOURCE="${DIR_REPO_BASE}/root";
			FILES_TO_COPY=$(ls -hAl "${COPY_FROM_SOURCE}/" | awk '{print $9}');

			# User-List whose Home-Dirs will be updated
			LINUX_BASH_USERS=$(cat /etc/passwd | grep /bin/bash | awk -F':' '{ print $1}');

			# Determine longest Username to enhance log-readability by left-padding (right-aligning) output text, below
			#   NOTE: Linux usernames cannot be longer than 32 chars (according to useradd man page)
			USERNAMES_MOSTCHARS=0;
			for EACH_SSH_USER in ${LINUX_BASH_USERS}; do
				EACH_USERNAME_LENGTH=${#EACH_SSH_USER};
				if (( ${EACH_USERNAME_LENGTH} > ${USERNAMES_MOSTCHARS} )); then
					USERNAMES_MOSTCHARS=${EACH_USERNAME_LENGTH};
				fi;
			done;
			echo -e "\n""Info:  Syncing Bash-Config & Terminal-Formatting files for SSH-Enabled users...";
			BENCHMARK_START=$(date +'%s.%N');
			# Begin copying files to SSH-Enabled User-Home Directories
			for EACH_FILE in ${FILES_TO_COPY}; do
				if [[ ! -z "${EACH_FILE// }" ]]; then # Ignore blank/empty filenames
					echo "  |--> \"${EACH_FILE}\" (Home-Directory File)";
					SRC_FULLPATH="${COPY_FROM_SOURCE}/${EACH_FILE}";
					for EACH_SSH_USER in ${LINUX_BASH_USERS}; do
						EACH_PRIMARY_GROUP="$(id -gn ${EACH_SSH_USER})";
						DIR_USER_HOME="$(eval echo ~${EACH_SSH_USER})";
						USERNAME_RPAD="  "$(printf '%-'${USERNAMES_MOSTCHARS}'s' "|----> ${EACH_SSH_USER}");
						# Only copy files to SSH-Enabled user home-directories (plus root)
						if [ -d "${DIR_USER_HOME}/.ssh" ] || [ -f "${DIR_USER_HOME}/.bash_history" ] || [ -f "/etc/ssh/authorized_keys/${EACH_SSH_USER}" ] || [ "${EACH_SSH_USER}" == "root" ]; then
							DEST_FULLPATH="${DIR_USER_HOME}/${EACH_FILE}";
							if [ -d "${SRC_FULLPATH}" ] && [ -f "${SRC_FULLPATH}/"* ]; then
								# Directories containing at least one file
								dos2unix --quiet "${SRC_FULLPATH}/"*;
								cp -rf "${SRC_FULLPATH}" "${DIR_USER_HOME}";
								chown -R "${EACH_SSH_USER}:${EACH_PRIMARY_GROUP}" "${DEST_FULLPATH}";
								chmod -R 600 "${DEST_FULLPATH}";
								chmod 700 "${DEST_FULLPATH}";
							else
								# Files
								dos2unix --quiet "${SRC_FULLPATH}";
								cp -f "${SRC_FULLPATH}" "${DEST_FULLPATH}";
								chown "${EACH_SSH_USER}:${EACH_PRIMARY_GROUP}" "${DEST_FULLPATH}";
								chmod 600 "${DEST_FULLPATH}";
							fi;
							echo "${USERNAME_RPAD}:  [ ${DEST_FULLPATH} ]";
						fi;
					done;
				fi;
			done;
			BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |";
			test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


			# ------------------------------------------------------------
			#
			# /etc/cron.d/CRON_ddns_updater
			#
			if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then
				if [ ${ARGS_SYNC_DDNS} -eq 1 ]; then
					# Syncs the cronjob trigger to update a given DNS-Provider with current WAN IP
					CRON_UPDATE_DNS_A_RECORDS="/etc/cron.d/CRON_ddns_updater";
					echo -e "\n""Info:  Updating \"${CRON_UPDATE_DNS_A_RECORDS}\" with changes from \"${GIT_REPO_NAME}\" repository";
					BENCHMARK_START=$(date +'%s.%N');

					/usr/local/bin/ddns_setup \
						&& wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/master${CRON_UPDATE_DNS_A_RECORDS}" -O "/etc/cron.d/CRON_ddns_updater" -q \
						&& chmod 0644 "/etc/cron.d/CRON_ddns_updater" \
						&& RESTART_SERVICE_CRON=1;

					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
				fi;
			fi;


			# ------------------------------------------------------------
			#
			# Jenkins Items
			#
			if [ ${ARGS_SYNC_JENKINS} -eq 1 ] && [ ${RESTART_SERVICE_JENKINS} -eq 0 ] && [ -x "/usr/sbin/service" ]; then

				SERVICE_NAME="jenkins";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then

					# ------------------------------------------------------------
					#
					# Set directory permissions as-intended
					#  |--> Fix for issue where jenkins images wouldn't show-up while on "Manage Jenkins" page (or directly accessing them)
					#

					DESTINATION_PATH="/var/cache/jenkins";
					DIR_PERMS="0751";
					chmod "${DIR_PERMS}" "${DESTINATION_PATH}";

					DESTINATION_PATH="/var/cache/jenkins/war";
					DIR_PERMS="0755";
					chmod "${DIR_PERMS}" "${DESTINATION_PATH}";

					# ------------------------------------------------------------
					#
					# /var/cache/jenkins/war
					#
					DESTINATION_PATH="/var/cache/jenkins/war";
					SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
					FILE_PERMS="0644"; DIR_PERMS="0755";
					echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
					BENCHMARK_START=$(date +'%s.%N');
					rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
					chown -R "jenkins:jenkins" "${DESTINATION_PATH}";
					find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
					find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
					if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
					dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

					# /var/cache/jenkins/war - Set policies to stop Selinux from blocking access to cached Jenkins images within "/var/cache/jenkins/war/images"
					if [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
						chcon -R -t httpd_sys_content_t "/var/cache/jenkins/war/images/";
						semanage fcontext -a -t httpd_sys_content_t "/var/cache/jenkins/war/images/";
					fi;

					# ------------------------------------------------------------
					#
					# /etc/default/jenkins
					#
					DESTINATION_PATH="/etc/default/jenkins";
					SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
					FILE_PERMS="0644"; DIR_PERMS="0755";
					echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
					BENCHMARK_START=$(date +'%s.%N');
					rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
					chown -R "jenkins:jenkins" "${DESTINATION_PATH}";
					find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
					find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
					if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
					dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";


					if [ ${ARGS_CRONJOB_REMOVE} -eq 0 ]; then

						# ------------------------------------------------------------
						#
						# /etc/cron.d/CRON_jenkins_export_config
						#
						DESTINATION_PATH="/etc/cron.d/CRON_jenkins_export_config";
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

						# ------------------------------------------------------------
						#
						# /etc/cron.d/CRON_jenkins_log_cleanup
						#
						DESTINATION_PATH="/etc/cron.d/CRON_jenkins_log_cleanup";
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

						# ------------------------------------------------------------
						#
						# /etc/cron.d/CRON_jenkins_sync_ci
						#
						DESTINATION_PATH="/etc/cron.d/CRON_jenkins_sync_ci";
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

						# ------------------------------------------------------------
						#
						# /etc/cron.d/CRON_jenkins_warfile_update
						#
						DESTINATION_PATH="/etc/cron.d/CRON_jenkins_warfile_update";
						SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
						FILE_PERMS="0644"; DIR_PERMS="0644";
						echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
						BENCHMARK_START=$(date +'%s.%N');
						rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
						chown -R "root:root" "${DESTINATION_PATH}";
						find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
						find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
						if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
						dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
						BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
						test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

					fi;

					RESTART_SERVICE_JENKINS=1;
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

				fi;

			else
				# Service not found locally
				echo -e "\n""Info:  Skipped Jenkins config-sync (not found as a local service)";

			fi;


			# ------------------------------------------------------------
			#
			# /etc/nginx
			#
			if [ ${ARGS_SYNC_NGINX} -eq 1 ]; then
				if [ -z "$(which nginx 2>'/dev/null')" ]; then
					# NGINX does NOT exist locally
					echo -e "\n""Info:  Skipped NGINX sync (not found as a local service)";

				else
					# NGINX exists locally
					DESTINATION_PATH="/etc/nginx"; if [ ! -d  "${DESTINATION_PATH}" ]; then mkdir -p "${DESTINATION_PATH}"; fi;
					SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
					FILE_PERMS="0644"; DIR_PERMS="0755";
					echo -e "\n""Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
					BENCHMARK_START=$(date +'%s.%N');
					rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
					chown -R "root:root" "${DESTINATION_PATH}";
					find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
					find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
					if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
					dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)

					# /var/www/error
					DESTINATION_PATH="/var/www/error"; if [ ! -d  "${DESTINATION_PATH}" ]; then mkdir -p "${DESTINATION_PATH}"; fi;
					SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"$(test -d "${DIR_REPO_BASE}${DESTINATION_PATH}" && echo "/";);
					FILE_PERMS="0644"; DIR_PERMS="0755";
					echo -e "  |--> Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository";
					BENCHMARK_START=$(date +'%s.%N');
					rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
					chown -R "root:root" "${DESTINATION_PATH}";
					find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \;; # chmod directories
					find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \;; # chmod files
					if [ "${FILE_PERMS}" == "${DIR_PERMS}" ]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
					dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)

					if [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
						# Allow files to be read without selinux blocking them
						chcon -Rt httpd_sys_content_t "${DESTINATION_PATH}";
					fi;

					# Ensure that the Diffie-Hellman parameter for DHE ciphersuites exists
					DH_PARAM_FILEPATH="/etc/ssl/certs/dhparam.pem";
					DH_ENCRYPTION_BIT_STRENGTH=2048; # 2048 / 3072 / 4096 <-- Do not go lower than 2048 (as-of late 2019)
					if [ ! -f "${DH_PARAM_FILEPATH}" ]; then
						echo "  |--> Creating Diffie-Hellman Parameters File @ \"${DH_PARAM_FILEPATH}\"...";
						openssl dhparam -out "${DH_PARAM_FILEPATH}" ${DH_ENCRYPTION_BIT_STRENGTH};
					fi;

					# Set the environment-specific web-server runtime user
					if [ $(which apt 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Debian, Ubuntu, etc.
						sed -i 's|user www-data;|user www-data;|g' "/etc/nginx/nginx.conf";
					elif [ $(which yum 2>'/dev/null' | wc -l;) -gt 0 ]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
						sed -i 's|user www-data;|user nginx;|g' "/etc/nginx/nginx.conf";
					fi;

					# Walk through all sites-available (from repo), resolve their IPv4, then compare against current device's WAN IPv4 & only sync if the two IPv4's are a direct match
					find "/etc/nginx/sites-available/" -mindepth 1 -maxdepth 1 -name "*.nginx" -type "f" -print0 | while IFS= read -r -d $'\0' Each_SitesAvailable; do
						Each_FQDN=$(echo "$(basename ${Each_SitesAvailable})" | rev | cut -d. -f 1 --complement | rev);
						Each_SitesEnabled="/etc/nginx/sites-enabled/${Each_FQDN}";
						if [ "$(hostname --fqdn)" == "${Each_FQDN}" ] || [ "$(dig +short ${Each_FQDN})" == "$(hostname -i | awk '{print $1}';)" ] || [ "$(dig +short ${Each_FQDN})" == "$(curl -s -4 https://icanhazip.com)" ]; then
							# The FQDN resolved to an IPv4 which matches this workstation/server's WAN IPv4 - Set this FQDN to "Enabled" for the current NGINX server
							ln -sf "${Each_SitesAvailable}" "${Each_SitesEnabled}";
							echo "  |--> Enabling NGINX FQDN \"${Each_FQDN}\" (Exact match found between FQDN's-resolved-IPv4 & Current-WAN-IPv4)";
						else
							rm -f "${Each_SitesAvailable}";
							if [ -L "${Each_SitesEnabled}" ]; then
								# If the FQDN's IPv4 didn't resolve to the same IPv4 as the current workstation/server's WAN IPv4, but the FQDN is found to be enabled anyways, then disable it
								unlink "${Each_SitesEnabled}";
								test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Disabling NGINX FQDN \"${Each_FQDN}\" (No match found between FQDN's-resolved-IPv4 & Current WAN IPv4)";
								# else
								# 	echo "  |--> Skipped NGINX FQDN \"${Each_FQDN}\" (No match found between FQDN's-Resolved-IPv4 & Current WAN IPv4)";
							fi;
						fi;
					done;

					# Setup certbot to reload NGINX whenever a Let's Encrypt HTTPS certificate is renewed via certbot
					if [ -d "/etc/letsencrypt/renewal-hooks/deploy" ] && [ ! -e "/etc/letsencrypt/renewal-hooks/deploy/reload_nginx" ] && [ -f "/usr/local/sbin/reload_nginx" ]; then
						ln --symbolic --verbose --force "/usr/local/sbin/reload_nginx" "/etc/letsencrypt/renewal-hooks/deploy/reload_nginx";
					fi;

					RESTART_SERVICE_NGINX=1;
					BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
					test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";

				fi;

			fi;


			if [ ${ARGS_CRONJOB_REMOVE} -eq 1 ]; then
				#
				# --remove-cronjobs  -->  Removes all scripts matching /etc/cron.d/CRON_*  (other than CRON_sync_cloud_infrastructure, which triggers this, current script)
				#
				LOCAL_CRON_D_SCRIPTS=$(ls /etc/cron.d/CRON_* | grep -v 'sync_cloud_infrastructure' 2>'/dev/null';);
				COUNT_CRON_D_SCRIPTS=$(echo "${LOCAL_CRON_D_SCRIPTS}" | wc -l;);
				if [ $(echo "${LOCAL_CRON_D_SCRIPTS}" | wc -l) -eq 0 ]; then
					echo -e "\n""Info:  Skipped removal of cron sync-triggers (No scripts found matching \"/etc/cron.d/CRON_*\")";
				else
					echo -e "\n""Info:  Found ${COUNT_CRON_D_SCRIPTS} cron sync-triggers matching \"/etc/cron.d/CRON_*\":";
					for EACH_CRON_TRIGGER in ${LOCAL_CRON_D_SCRIPTS}; do
						echo "  |";
						read -p "  |--> Are you sure you want to remove cron sync-trigger \"${EACH_CRON_TRIGGER}\"? (y/n)  " -n 1 -t 60 -r; # Await single keypress
						if [ -n "${REPLY}" ] && [ "$(echo ${REPLY} | tr '[:lower:]' '[:upper:]';)" == "Y" ]; then
							echo "  |----> Confirmed - Removing \"${EACH_CRON_TRIGGER}\"...";
							rm -f "${EACH_CRON_TRIGGER}";
						else
							echo "  |----> Skipped - Leaving \"${EACH_CRON_TRIGGER}\" unchanged/unaffected";
						fi;
					done;
				fi;

			fi;

			# ------------------------------------------------------------
			# DELETE OLD FILES / UNLINK OLD SYMLINKS
			# ------------------------------------------------------------

			DELDIR="/usr/local/bin/";
			TO_DEL="${DELDIR}/docker_check_installation_status"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/docker_list_volume_maps.sh"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/get_enabled_services"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;  # Added 2019-12-12
			TO_DEL="${DELDIR}/get_services"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;  # Added 2019-12-12
			TO_DEL="${DELDIR}/get_wan_ip"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;

			DELDIR="/usr/local/sbin/";
			TO_DEL="${DELDIR}/install_devops_packages"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/install_minio_mc"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/install_mongod"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/install_utilities"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/install_vmware-tools"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/jenkins-config-export"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/jenkins_war_update"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/sudoer_edit"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/sync_Cloud_infrastructure"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 2020-01-06
			TO_DEL="${DELDIR}/sync_config_gpg_git"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/sync_gpg_git_config"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;  # Added 2019-12-12
			TO_DEL="${DELDIR}/sync_upd"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/update_bins_from_sftp"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi;
			TO_DEL="${DELDIR}/wsl_reboot"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 20191220-164752

			DELDIR="/etc/ddns_ufw_update";
			if [ -d "${DELDIR}" ]; then rm -rf "${DELDIR}" fi; # Added 20200115-223014 - Moved to /etc/whitelist.d

			DELDIR="/etc/nginx/conf.ddns";
			TO_DEL="${DELDIR}/rz.mcavallo.com"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 20200115-224618
			TO_DEL="${DELDIR}/x1.mcavallo.com"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 20200115-224620
	
			DELDIR="/etc/nginx/conf.vendor";
			TO_DEL="${DELDIR}/LAN_subnets.conf"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 20200114-192658

			DELDIR="/var/cache/jenkins/war";
			TO_DEL="${DELDIR}Jenkins Artwork (jenkins.io).url"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456
			TO_DEL="${DELDIR}Jenkins Material Theme (GitHub).url"; if [ -h "${TO_DEL}" ]; then unlink "${TO_DEL}"; elif [ -f "${TO_DEL}" ]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456


			# ------------------------------------------------------------
			# Restart Service (if needed)  -->  cron
			# ------------------------------------------------------------
			if [ ${RESTART_SERVICE_CRON} -eq 1 ] && [ -x "/usr/sbin/service" ]; then
				CRON_SVC_FOUND=0; CRON_SVC_NAMES="";
				# ------------------------------------------------------------
				SERVICE_NAME="cron";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then
					CRON_SVC_FOUND=$((${CRON_SVC_FOUND}+1));
					CRON_SVC_NAMES="${SERVICE_NAME}";
					/usr/sbin/service "${SERVICE_NAME}" restart;
					/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
				fi;
				# ------------------------------------------------------------
				SERVICE_NAME="crond";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then
					CRON_SVC_FOUND=$((${CRON_SVC_FOUND}+1));
					CRON_SVC_NAMES="${SERVICE_NAME}";
					/usr/sbin/service "${SERVICE_NAME}" restart;
					/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
				fi;
				# ------------------------------------------------------------
				if [ ${CRON_SVC_FOUND} -eq 0 ]; then
					echo "Skipped restart of the \"${CRON_SVC_NAMES}\" service(s) (not found as a local service)";
				fi;
			fi;


			# ------------------------------------------------------------
			# Restart Service (if needed)  -->  jenkins
			# ------------------------------------------------------------
			if [ ${RESTART_SERVICE_JENKINS} -eq 1 ] && [ -x "/usr/sbin/service" ]; then
				SERVICE_NAME="jenkins";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then
					/usr/sbin/service "${SERVICE_NAME}" restart;
					/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
				else
					echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
				fi;
			fi;


			# ------------------------------------------------------------
			# Restart Service (if needed)  -->  nginx
			# ------------------------------------------------------------
			if [ ${RESTART_SERVICE_NGINX} -eq 1 ] && [ -x "/usr/sbin/service" ]; then
				SERVICE_NAME="nginx";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then
					/usr/local/sbin/reload_nginx;
				else
					echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
				fi;
			fi;


			# ------------------------------------------------------------
			# Restart Service (if needed)  -->  ssh
			# ------------------------------------------------------------
			if [ ${RESTART_SERVICE_SSH} -eq 1 ] && [ -x "/usr/sbin/service" ]; then
				SERVICE_NAME="sshd";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then
					/usr/sbin/service "${SERVICE_NAME}" restart;
					/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
				else
					echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
				fi;
			fi;


			# ------------------------------------------------------------
			# Restart Service (if needed)  -->  ufw
			# ------------------------------------------------------------
			if [ ${RESTART_SERVICE_UFW} -eq 1 ] && [ -x "/usr/sbin/service" ]; then
				SERVICE_NAME="ufw";
				SERVICE_RET_CODE=$(/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full 1>'/dev/null' 2>&1; echo $?;);
				if [ ${SERVICE_RET_CODE} -eq 0 ]; then
					/usr/sbin/service "${SERVICE_NAME}" restart;
					if [ -n "$(which ${SERVICE_NAME} 2>'/dev/null';)" ]; then
						ufw reload;
					fi;
					/usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
				else
					echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
				fi;
			fi;


			# ------------------------------------------------------------
			# Cleanup log files outside of the retention-policy's max-age
			# ------------------------------------------------------------
			if [ -z "${LOGDIR}" ]; then
				LOGDIR="/var/log/sync_cloud_infrastructure";
			fi;
			if [ "${LOGDIR}" == "${HOME}/sync_cloud_infrastructure_logs" ] || [ "${LOGDIR}" == "/var/log/sync_cloud_infrastructure" ]; then
				if [ -d "${LOGDIR}" ]; then
					echo -e "\n""Info:  Cleaning logs older than 3 days old from directory \"${LOGDIR}\"";
					find "${LOGDIR}" -type f -mtime +3 -exec rm -- '{}' \;;
				fi;
			fi;

		fi;


		# ------------------------------------------------------------
		# Show Runtime Statistics
		echo -e "\n""Info:  End of \"sync_cloud_infrastructure\" runtime";
		BENCHMARK_START=${START_SECONDS_NANOSECONDS};
		BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l);
		test ${ARGS_DEBUG_MODE} -eq 1 && echo "  |--> Finished after ${BENCHMARK_DELTA}s";
		echo "";

	fi;

	# ------------------------------------------------------------
	# Exit as-intended (force returned code)
	exit ${EXIT_CODE};

fi;
