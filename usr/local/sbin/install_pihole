#!/bin/bash
#
# LOCAL_SBIN="/usr/local/sbin/install_pihole" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------------------------------------
if [ 0 -eq 1 ]; then  # RUN THIS SCRIPT

curl -H 'Cache-Control: no-cache' -s "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/install_pihole?t=$(date +'%s.%N')" | bash;

fi;
# ------------------------------------------------------------
#
# Log all shell output & error output to logfile
#
LOGDIR="${HOME}/install_pihole_logs"; if [ -w "/var/log/" ]; then LOGDIR="/var/log/install_pihole"; fi;
mkdir -p "${LOGDIR}"; chown $(stat -c '%u:%g' $(dirname ${LOGDIR})) "${LOGDIR}"; chmod 0770 "${LOGDIR}";
LOGFILE="${LOGDIR}/$(basename ${LOGDIR})_$(date +'%Y%m%d_%H%M%S')"; echo -n "" > "${LOGFILE}"; chmod 0660 "${LOGFILE}";
exec > >(tee -a "${LOGFILE}" );
exec 2>&1;
#
# ------------------------------------------------------------
#
# Spin-up pihole instance (using docker-compose)
#
# ------------------------------------------------------------
#
# Free-up port 53 by stopping service [ systemd-resolved ] from listening on it
#  |
#  |--> Update "/etc/systemd/resolved.conf"
#  |     |--> Uncomment "DNS=" line and set to "DNS=8.8.4.4"
#  |     |--> Uncomment "FallbackDNS=" line and set to "FallbackDNS=1.1.1.1"
#  |     |--> Uncomment "DNSStubListener=" line and set to "DNSStubListener=no"
#  |
#  |--> Redirect "/etc/resolv.conf"
#  |     |--> Run [ ln -sf "/run/systemd/resolve/resolv.conf" "/etc/resolv.conf"; ]
#  |
#  |--> Restart the machine via [ reboot ]
#
# ------------------------------------------------------------

EXIT_CODE=0;

THIS_SCRIPT="install_pihole";

echo "------------------------------";
echo "Starting ${THIS_SCRIPT} at [ $(date +'%Y-%m-%dT%H:%M:%S%z')] ";

# ------------------------------------------------------------
#
# Spin-up the pihole docker (after port 53 is freed up)
#

# Check to see if any pihole dockers are currently running (before updating/removing/replacing them with a newer version)
DOCKER_NAME="pihole";
FIRST_REINSTALL_CONFIRMATION="";
SECOND_REINSTALL_CONFIRMATION="";
RUNNING_PIHOLE_DOCKERS=$(docker ps --all --quiet --filter "name=${DOCKER_NAME}" | wc -l;);
if [ ${RUNNING_PIHOLE_DOCKERS} -gt 0 ]; then
  # Require a first round of user confirmations ('Y' or 'y' keypress) before reinstalling pihole over an already-running instance of pihole
  echo -e "";
  echo -e " ! !        ! !";
  echo -e " ! ! NOTICE ! !  This will reinstall any existing ${DOCKER_NAME} dockers  ! ! NOTICE ! ! ";
  echo -e " ! !   |    ! !";
  echo -e "       |  ";
  read -p "       |--> Are you sure you want to continue?  (press 'y' to confirm)  " -a FIRST_REINSTALL_CONFIRMATION -n 1 -t 60 <'/dev/tty'; # Await single keypress
  echo -e "";
fi;

if [ ${RUNNING_PIHOLE_DOCKERS} -eq 0 ] || [[ "${FIRST_REINSTALL_CONFIRMATION}" =~ ^[Yy]$ ]]; then

  # Require a second round of user confirmations ('Y' or 'y' keypress) before reinstalling pihole over an already-running instance of pihole
  if [[ "${FIRST_REINSTALL_CONFIRMATION}" =~ ^[Yy]$ ]]; then
    echo "       |  ";
    read -p "       |--> Are you completely positive you want to continue?  (press 'y' to confirm)  " -a SECOND_REINSTALL_CONFIRMATION -n 1 -t 60 <'/dev/tty'; # Await single keypress
    echo "";
    echo "";
  fi;

  if [ ${RUNNING_PIHOLE_DOCKERS} -eq 0 ] || [[ "${SECOND_REINSTALL_CONFIRMATION}" =~ ^[Yy]$ ]]; then

    # ------------------------------
    # Ensure any volume-map directories exist
    CONFIG_DIR="/root/docker-configs/pihole";
    echo "";
    echo "Info:  Creating volume-map directories which don't already exist...";
    mkdir --parents "${CONFIG_DIR}/etc/pihole/" "${CONFIG_DIR}/etc/dnsmasq.d/";  # Directories used for docker container volume maps

    # ------------------------------

    # Set the working directory
    echo "";
    echo "Info:  Setting the working directory to \"${CONFIG_DIR}\"...";
    cd "${CONFIG_DIR}";

    # ------------------------------

    # Download a base docker-compose YAML script (intended to be used for spinning up customized pihole containers)
    REMOTE_DOCKER_COMPOSE="https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/var/lib/docker-compose/docker-compose.pihole.yml";
    COMPOSE_FILE="${CONFIG_DIR}/docker-compose.yml";
    echo "";
    echo "Info:  Downloading pihole docker-compose script...";
    curl -sL "${REMOTE_DOCKER_COMPOSE}" -o "${COMPOSE_FILE}";
    chmod 0600 "${COMPOSE_FILE}";

    # ------------------------------

    # If any pihole containers are already running locally
    REVERT_RESOLV_CONF=0;
    if [ ${RUNNING_PIHOLE_DOCKERS} -gt 0 ]; then
      if [ $(sed -rne 's/^# (nameserver 8.8.4.4)$/\0/p' '/etc/resolv.conf' | wc -l 2>'/dev/null';) -gt 0 ]; then
        # Add Google DNS to local DNS resolvers before removing current pihole container (and ruining loopback DNS resolution, if active)
        echo "";
        echo "Info:  Adding Google DNS server to local DNS resolvers before removing current pihole container (which could ruin loopback DNS resolution, if active)";
        sed -re 's/^# (nameserver 8.8.4.4)$/\1/' -i "/etc/resolv.conf";
        REVERT_RESOLV_CONF=1;
      fi;
      # Remove existing pihole dockers
      echo "";
      echo "Info:  Removing existing pihole containers...";
      curl -H 'Cache-Control: no-cache' -s "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/bin/docker_sniper?t=$(date +'%s.%N')" | bash -s -- "${DOCKER_NAME}";
      # docker_sniper "${DOCKER_NAME}";

      # Wait for local DNS resolution to recognize and update itself around the pihole DNS server going AWOL
      echo "";
      echo "Info:  Sleeping for 30 seconds (to allow network resolution changes to propogate)...";
      sleep 30;
    fi;

    # ------------------------------
    # Spin up the pihole docker container
    echo "";
    echo "Info:  Spinning up the \"${DOCKER_NAME}\" docker container...";
    cd "${CONFIG_DIR}";
    docker-compose up --detach;

    # Verify that the docker container was created as-intended
    DOCKER_EXISTS=0;
    if [ -n "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" ]; then
      # Pi-hole container DOES exist
      DOCKER_EXISTS=1;
      echo "";
      echo "Info:  Pi-hole docker successfully created";
      # echo "Info:  Pi-hole docker successfully created with container ID \"$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)\";";
    else
      # Pi-hole container does NOT exist
      EXIT_CODE=1;
      DOCKER_EXISTS=0;
      echo "";
      echo "Error:  Pi-hole docker not found";
    fi;

    # Free up port 53 for pihole --> Stop the pihole docker, then stop the 'systemd-resolved' service in order to free up port 53 (DNS) so that pihole may create a listening thread on port 53, effectively reserving the port for the pihole service, locally, then start the pihole docker
    if [[ "${DOCKER_EXISTS}" -eq 1 ]]; then
      echo "";
      echo "Info:  Freeing up port 53 (DNS) so that the pihole service may create a listening thread on it";

      echo " |--> Stopping docker \"${DOCKER_NAME}\"...";
      docker stop "${DOCKER_NAME}" 1>'/dev/null';

      echo " |--> Stopping service 'systemd-resolved'...";
      systemctl stop "systemd-resolved.service";

      echo " |--> Disabling service 'systemd-resolved'...";
      systemctl disable "systemd-resolved.service";

      echo " |--> Starting docker \"${DOCKER_NAME}\"...";
      docker start "${DOCKER_NAME}" 1>'/dev/null';

    fi;


    # If we added a temporary DNS resolver's IP address (above) to /etc/resolv.conf, then now is the location in the script where it should be removed/cleaned-up (as it is only a workaround to download pihole's docker image while pihole itself doesn't exist to resolve DNS queries to find it)
    if [ ${REVERT_RESOLV_CONF} -eq 1 ]; then
      echo "";
      echo "Info:  Removing Google DNS server from local DNS resolvers...";
      sed -re 's/^(nameserver 8.8.4.4)$/# \1/' -i "/etc/resolv.conf";
    fi;


    if [[ "${DOCKER_EXISTS}" -eq 1 ]]; then

      # ------------------------------
      #
      # Update pihole's adlists (list of blacklisted domains which pihole's gravity pulls from)
      #  |
      #  |--> DB-Schema command:
      #  |      TABLE_NAME="adlist"; FULLPATH_DATABASE="/etc/pihole/gravity.db"; DOCKER_NAME="pihole"; docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" sqlite3 "${FULLPATH_DATABASE}" ".schema ${TABLE_NAME}";
      #  |
      #  |--> DB-Schema:
      #         CREATE TABLE adlist
      #         (
      #           id INTEGER PRIMARY KEY AUTOINCREMENT,
      #           address TEXT UNIQUE NOT NULL,
      #           enabled BOOLEAN NOT NULL DEFAULT 1,
      #           date_added INTEGER NOT NULL DEFAULT (cast(strftime('%s', 'now') as int)),
      #           date_modified INTEGER NOT NULL DEFAULT (cast(strftime('%s', 'now') as int)),
      #           comment TEXT,
      #           date_updated INTEGER,
      #           number INTEGER NOT NULL DEFAULT 0,
      #           invalid_domains INTEGER NOT NULL DEFAULT 0,
      #           status INTEGER NOT NULL DEFAULT 0
      #         );
      #

      FULLPATH_ADLISTS="/etc/pihole/adlists.list";
      FILE_CONTENT_LINES="$(docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" cat "${FULLPATH_ADLISTS}" 2>'/dev/null' | wc -l;)";
      if [[ "${FILE_CONTENT_LINES}" != "0" ]]; then
        echo "";
        echo "Info:  Syncing Adlist entries from \"${FULLPATH_ADLISTS}\"...";
        SQL_TABLE="adlist";
        # Search adlists for urls to pull from
        ROLLBACK_IFS="${IFS}"; IFS=$'\n'; # Set the global for-loop delimiter
        for EACH_LINE in $(docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" cat "${FULLPATH_ADLISTS}";); do
          EACH_ADDRESS="$(echo "${EACH_LINE}" | sed -re "s/^([^\|]+)(\|(.+))?\s*$/\1/";)";
          EACH_COMMENT="$(TEST_COMMENT="$(echo "${EACH_LINE}" | sed -re "s/^([^\|]+)(\|(.+))?\s*$/\3/";)"; if [[ -n "${TEST_COMMENT}" ]]; then echo "${TEST_COMMENT}"; else echo "Imported from ${FULLPATH_WHITELIST}"; fi;)";
          SQLITE_QUERY_SELECT="SELECT enabled FROM ${SQL_TABLE} WHERE address='${EACH_ADDRESS}';";
          SQLITE_RESULT_SELECT="$(docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" sqlite3 /etc/pihole/gravity.db "${SQLITE_QUERY_SELECT}";)";
          SQLITE_QUERY_UPDATE="";
          if [[ -z "${SQLITE_RESULT_SELECT}" ]]; then
            # (Insert) Record doesn't (yet) exist for this Adlist entry --> create it
            echo " |--> (Insert)  Adding/Enabling Adlist entry:  '${EACH_ADDRESS}' ...";
            SQLITE_QUERY_UPDATE="INSERT INTO ${SQL_TABLE} (address, enabled, comment) VALUES ('${EACH_ADDRESS}',1,'${EACH_COMMENT}');";
          elif [[ "${SQLITE_RESULT_SELECT}" -eq 0 ]]; then
            # (Update) Record exists for this Adlist entry, but it is disabled --> enable it
            echo " |--> (Update)  Enabling Adlist entry:  '${EACH_ADDRESS}' ...";
            SQLITE_QUERY_UPDATE="UPDATE ${SQL_TABLE} SET enabled=1,comment='${EACH_COMMENT}' WHERE address='${EACH_ADDRESS}';";
          else
            # (Skipped) Record exists and is enabled, already
            echo " |--> (Skipped) Adlist entry already enabled:  '${EACH_ADDRESS}' ...";
          fi;
          if [ -n "${SQLITE_QUERY_UPDATE}" ]; then
            docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" sqlite3 /etc/pihole/gravity.db "${SQLITE_QUERY_UPDATE}";
          fi;
        done;
        IFS="${ROLLBACK_IFS}"; # Restore the global for-loop delimiter

      fi;

      # ------------------------------
      #
      # Update pihole's whitelisted domains  -  https://discourse.pi-hole.net/t/commonly-whitelisted-domains/212
      #  |
      #  |--> DB-Schema command:
      #  |      TABLE_NAME="domainlist"; FULLPATH_DATABASE="/etc/pihole/gravity.db"; DOCKER_NAME="pihole"; docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" sqlite3 "${FULLPATH_DATABASE}" ".schema ${TABLE_NAME}";
      #  |
      #  |--> DB-Schema:
      #         CREATE TABLE domainlist
      #         (
      #           id INTEGER PRIMARY KEY AUTOINCREMENT,
      #           type INTEGER NOT NULL DEFAULT 0,
      #           domain TEXT NOT NULL,
      #           enabled BOOLEAN NOT NULL DEFAULT 1,
      #           date_added INTEGER NOT NULL DEFAULT (cast(strftime('%s', 'now') as int)),
      #           date_modified INTEGER NOT NULL DEFAULT (cast(strftime('%s', 'now') as int)),
      #           comment TEXT,
      #           UNIQUE(domain, type)
      #         );
      #

      FULLPATH_WHITELIST="/etc/pihole/whitelist.list";
      FILE_CONTENT_LINES="$(docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" cat "${FULLPATH_WHITELIST}" 2>'/dev/null' | wc -l;)";
      if [[ "${FILE_CONTENT_LINES}" != "0" ]]; then
        echo "";
        echo "Info:  Syncing Whitelist entries from \"${FULLPATH_WHITELIST}\"...";
        SQL_TABLE="domainlist";
        DEFAULT_COMMENT="Imported from ${FULLPATH_WHITELIST}";
        # Search adlists for urls to pull from
        ROLLBACK_IFS="${IFS}"; IFS=$'\n'; # Set the global for-loop delimiter
        for EACH_LINE in $(docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" cat "${FULLPATH_WHITELIST}";); do
          EACH_DOMAIN="$(echo "${EACH_LINE}" | sed -re "s/^([^\|]+)(\|(.+))?\s*$/\1/";)";
          EACH_COMMENT="$(TEST_COMMENT="$(echo "${EACH_LINE}" | sed -re "s/^([^\|]+)(\|(.+))?\s*$/\3/";)"; if [[ -n "${TEST_COMMENT}" ]]; then echo "${TEST_COMMENT}"; else echo "Imported from ${FULLPATH_WHITELIST}"; fi;)";
          SQLITE_QUERY_SELECT="SELECT enabled FROM ${SQL_TABLE} WHERE domain='${EACH_DOMAIN}';";
          SQLITE_RESULT_SELECT="$(docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" sqlite3 /etc/pihole/gravity.db "${SQLITE_QUERY_SELECT}";)";
          SQLITE_QUERY_UPDATE="";
          if [[ -z "${SQLITE_RESULT_SELECT}" ]]; then
            # (Insert) Record doesn't (yet) exist for this Whitelist entry --> create it
            echo " |--> (Insert)  Adding/Enabling Whitelist entry:  '${EACH_DOMAIN}' ...";
            SQLITE_QUERY_UPDATE="INSERT INTO ${SQL_TABLE} (domain, enabled, comment) VALUES ('${EACH_DOMAIN}',1,'Imported from ${FULLPATH_WHITELIST}');";
          elif [[ "${SQLITE_RESULT_SELECT}" -eq 0 ]]; then
            # (Update) Record exists for this Whitelist entry, but it is disabled --> enable it
            echo " |--> (Update)  Enabling Whitelist entry:  '${EACH_DOMAIN}' ...";
            SQLITE_QUERY_UPDATE="UPDATE ${SQL_TABLE} SET enabled=1 WHERE domain='${EACH_DOMAIN}';";
          else
            # (Skipped) Record exists and is enabled, already
            echo " |--> (Skipped) Whitelist entry already enabled:  '${EACH_DOMAIN}' ...";
          fi;
          if [ -n "${SQLITE_QUERY_UPDATE}" ]; then
            docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" sqlite3 /etc/pihole/gravity.db "${SQLITE_QUERY_UPDATE}";
          fi;
        done;
        IFS="${ROLLBACK_IFS}"; # Restore the global for-loop delimiter

      fi;

      # ------------------------------
      #
      # Update pihole's gravity (which pulls from its enabled adlists)
      #

      echo "";
      echo "Sleeping for 15 seconds (to allow pihole container to boot up)...";
      sleep 15;

      echo "";
      echo "Updating pihole's Gravity DB with latest Adlist entries...";
      docker exec "$(docker ps --all --quiet --filter "name=${DOCKER_NAME}";)" pihole updateGravity;

    fi;

  fi;

fi;


#  !!!  PERFORM THE FOLLOWING STEPS MANUALLY (for the time being)
if [ 0 -eq 1 ]; then

  # Bash into the docker
  docker_bash_X;  # Download from [ https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/bin/docker_bash_X ]

  #
  # Set pihole file permissions as-intended
  #
  chown -R "pihole:pihole" "/etc/pihole/";
  chown -R "pihole:pihole" "/etc/pihole/dhcp.leases";
  chown -R "pihole:pihole" "/etc/pihole/gravity.db";
  chown -R "pihole:pihole" "/etc/pihole/macvendor.db";
  chown -R "pihole:root"   "/etc/pihole/pihole-FTL.conf";
  chown -R "pihole:pihole" "/etc/pihole/pihole-FTL.db";

  #
  # Make sure pihole's "/etc/resolv.conf" contains line [ nameserver 127.0.0.1 ], to allow internal query-ing and Adlist updating via [ pihole -g ]
  #  |--> via Docker Volume-Map to [ /etc/resolv.conf ] with read-only attribute ":ro" (to avoid it being updated/reverted)
  #

fi;


echo "";
echo "Finished ${THIS_SCRIPT} at [ $(date +'%Y-%m-%dT%H:%M:%S%z')]";
echo "------------------------------";
exit ${EXIT_CODE};


# ------------------------------------------------------------
#
# Citation(s)
#
#   discourse.pi-hole.net  |  "[Solved] While executing: attempt to write a readonly database error - Help / Community Help - Pi-hole Userspace"  |  https://discourse.pi-hole.net/t/solved-while-executing-attempt-to-write-a-readonly-database-error/33003/4
#
#   discourse.pi-hole.net  |  "Commonly Whitelisted Domains - FAQs - Pi-hole Userspace"  |  https://discourse.pi-hole.net/t/commonly-whitelisted-domains/212
#
#   discourse.pi-hole.net  |  "Enabling HTTPS for your Pi-hole Web Interface - FAQs / Community How-to's - Pi-hole Userspace"  |  https://discourse.pi-hole.net/t/enabling-https-for-your-pi-hole-web-interface/5771
#
#   discourse.pi-hole.net  |  "How do I add list via cli - FAQs / Community How-to's - Pi-hole Userspace"  |  https://discourse.pi-hole.net/t/how-do-i-add-list-via-cli/43733/2
#
#   discourse.pi-hole.net  |  "V5.0 Docker, Whitelist domain, writing to readonly database - Help - Pi-hole Userspace"  |  https://discourse.pi-hole.net/t/v5-0-docker-whitelist-domain-writing-to-readonly-database/32153/20?u=cavalol
#
#   docs.pi-hole.net  |  "Overview of Pi-hole - Pi-hole documentation"  |  https://docs.pi-hole.net/
#
#   github.com  |  "GitHub - pi-hole/docker-pi-hole: Pi-hole in a docker container"  |  https://github.com/pi-hole/docker-pi-hole/
#
#   hub.docker.com  |  "pihole/pihole - Docker Hub"  |  https://hub.docker.com/r/pihole/pihole
#
#   www.linuxuprising.com  |  "Ubuntu: How To Free Up Port 53, Used By systemd-resolved - Linux Uprising Blog"  |  https://www.linuxuprising.com/2020/07/ubuntu-how-to-free-up-port-53-used-by.html
#
#   www.sqlitetutorial.net  |  "SQLite Describe Table"  |  https://www.sqlitetutorial.net/sqlite-tutorial/sqlite-describe-table/
#
# ------------------------------------------------------------