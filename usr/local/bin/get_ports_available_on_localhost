#!/bin/bash
# ------------------------------------------------------------
#
# Dynamically locate an open port on local device
#  |
#  |--> Note:  Ports 0 to 1023 are "Well-Known" Ports
#              Ports 1024 to 49151 are "Registered" Ports
#              Ports 49152 to 65535 are "Public" Ports
#
# ------------------------------------------------------------

if [ $(which NETSTAT.EXE 2>'/dev/null' | wc -l;) -gt 0 ]; then
IP_PORT_COLUMN=2;
NETSTAT_CLI="NETSTAT.EXE -nao";
else
IP_PORT_COLUMN=4;
NETSTAT_CLI="netstat -tulpen";
fi;

RESERVED_PORTS="$(${NETSTAT_CLI} | grep ':' | grep -v 'processes' | awk "{print \$${IP_PORT_COLUMN}}" | sed -rne 's/^.+:([0-9]+)$/\1/p' | sort -gu;)";

STARTING_PORT=40000;

if [ ! -v PORT_ITERATOR ]; then
  # PORT_ITERATOR=$(shuf -i 40000-42500 -n 1);  # Start on a random port in a given range
  PORT_ITERATOR=${STARTING_PORT};
else
  PORT_ITERATOR=$(expr ${PORT_ITERATOR} + 1);
fi;

while [[ "${DUPLICATE_PORT}" != "0" ]]; do
  DUPLICATE_PORT=0;
  for EACH_RESERVED_PORT in ${RESERVED_PORTS}; do
    if [[ "${PORT_ITERATOR}" == "${EACH_RESERVED_PORT}" ]]; then
      # Socket already exists on port - iterate to the next port & check again
      PORT_ITERATOR=$(expr ${PORT_ITERATOR} + 1);
      DUPLICATE_PORT=1;
    fi;
  done;
done;

echo ${PORT_ITERATOR};  # Return the value of the available port (so that this module may be called as a sub-module for a single open/available port, as-needed)


# ------------------------------------------------------------