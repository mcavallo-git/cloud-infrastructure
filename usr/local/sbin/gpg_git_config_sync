#!/bin/bash
#
# LOCAL_SBIN="/usr/local/sbin/gpg_git_config_sync" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------------------------------------
if [ 0 -eq 1 ]; then

# Download & run this script on-the-fly:
curl -H 'Cache-Control: no-cache' -s "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/gpg_git_config_sync?$(date +'%s.%N')" | bash;

# Run the local copy of this script:
bash "${HOME}\Documents\GitHub\cloud-infrastructure\usr\local\sbin\gpg_git_config_sync";

fi;
# ------------------------------------------------------------
#
# In a Windows environment, take control of signing commits in Git by redirecting gpg commands to use
# [ Gpg4win ]'s [ Kleopatra ]  module's keyring and keyring handler to sign local commits used/sent by
# [ Git Bash ], [ GitHub Desktop ], & [ Tortoise Git ]
#
# ------------------------------------------------------------
#
# INSTALL "Gpg4win" FOR WINDOWS, FIRST
#   |--> Updated Installer for Gpg4win @ https://www.gpg4win.org/thanks-for-download.html
#
# ------------------------------------------------------------
#
# USE "KLEOPATRA" (search for program name via Start Menu) ONCE [ Gpg4win ] HAS BEEN INSTALLED 
#  |--> CREATE & MANAGE GnuPG KEYS LOCALLY, THEN SYNC THEM TO DESIRED GPG KEYSERVER
#  |--> KLEOPATRA IS NEEDED FOR WINDOWS SINCE GnuPG IS NEARLY, IF NOTE ENTIRELY A CLI ONLY TOOL
#
# ------------------------------------------------------------

# if [[ "${OSTYPE}" != "linux-gnu"* ]] && [[ "$(uname -s)" != "Linux" ]] && [[ "${OSTYPE}" != "darwin"* ]]; then
#   OS_IS_WINDOWS=1;
# else
#   OS_IS_WINDOWS=0;
#   echo "";
#   echo "Error: Script must run in a Windows Git-Bash terminal ( w/ admin-privileges ) to function as-intended";
#   echo "";
#   exit 1;
# fi;

IS_MINGW=$(if [[ $(uname -s | grep -i MINGW | wc -l) -gt 0 ]] || [ "${OSTYPE}" == "msys" ]; then echo 1; else echo 0; fi;);

PERSONAL_PUBLIC_REPOS=(); # Remote Public Repos (Personal)

PERSONAL_PRIVATE_REPOS=(); # Remote Private Repos (Personal)

WORK_PUBLIC_REPOS=(); # Remote Public Repos (Work)

WORK_PRIVATE_REPOS=(); # Remote Private Repos (Work)

REPOS_DIR=""; # Git Repo(s) Directory

COMMIT_NAME_PERSONAL=""; # Commit Fullname (Personal)

COMMIT_NAME_WORK=""; # Commit Fullname (Work)

GIT_EMAIL_PERSONAL=""; # Commit Email (Personal)

GIT_EMAIL_WORK=""; # Commit Email (Work)

GIT_SSH_PERSONAL=""; # Commit SSH-Key (Personal)

GIT_SSH_WORK=""; # Commit SSH-Key (Work)

GPG_KEY_ID_PERSONAL=""; # GPG Credential 1 (Personal)

GPG_PASS_FILE_PERSONAL=""; # GPG Credential 2 (Personal)

GPG_KEY_ID_WORK=""; # GPG Credential 1 (Work)

GPG_PASS_FILE_WORK=""; # GPG Credential 2 (Work)

GPG_CACHE_TIMEOUT=""; # GPG Cache Timeout

GPG_CONFIG_DIR=""; # GPG Config-Directory

GPG_KEYSERVER_URL=""; # GPG Key-Server URL

GPG_KEY_ID_FORMAT=""; # GPG Key-ID Format

GPG_KEYSERVER_OPTIONS=""; # GPG Key-Server Options

# ------------------------------------------------------------

GIT_SYNC_REPOS_ID1=""; # Git Repo-URLs (Key) & Associated Email for Read (and/or Write) user (Val) [ Implemented 2019-11-06 ]

GIT_SYNC_REPOS_ID2=""; # Git Repo-URLs (Key) & Associated Email for Read (and/or Write) user (Val) [ Implemented 2019-11-06 ]

GIT_SYNC_GPG_KEYS=""; # Git Emails (Key) and their associated GnuPG-Key Fingerprint (Val) [ Implemented 2019-11-06 ]

GIT_SYNC_FULLNAMES=""; # Git Emails (Key) and their associated Fullname (Val) [ Implemented 2019-11-06 ]

# ------------------------------------------------------------

DEFAULT_CONFIG_DIRNAME="${HOME}/.gpg_git";
DEFAULT_CONFIG_FULLPATH="${DEFAULT_CONFIG_DIRNAME}/config";
GIT_SYNC_CONFIG_FULLPATH="";

# Create parent directory to the main config (if not found to exist)
if [ ! -d "${DEFAULT_CONFIG_DIRNAME}" ]; then
  mkdir "${DEFAULT_CONFIG_DIRNAME}";
fi;

if [ -n "${1}" ] && [ -f "${1}" ]; then
  GIT_SYNC_CONFIG_FULLPATH="${1}";
  source "${1}"; # First inline parameter ( $1 ) is the path to another shell script which sets/instantiates all required config variables
elif [ -f "${DEFAULT_CONFIG_FULLPATH}" ]; then
  GIT_SYNC_CONFIG_FULLPATH="${DEFAULT_CONFIG_FULLPATH}";
  source "${DEFAULT_CONFIG_FULLPATH}"; # Default shell script which sets/instantiates all required config variables
else
  echo "";
  echo "Error: FIRST inline parameter ( \$1 ) must point to the filepath of a separate shell script which sets/instantiates all required git + gnupg config variables (see var-names above)";
  echo "";
  exit 1;
fi;


# ------------------------------------------------------------

shopt -s lastpipe; # extends the current shell into sub-shells (within piped-commands), sharing variables down-into them, as well


# ------------------------------------------------------------

# SHOW_GIT_CONFIG_OUTPUTS=0;
# SHOW_GIT_CONFIG_OUTPUTS=1;
# SHOW_GIT_CONFIG_OUTPUTS=2;
if [ ! -v SHOW_GIT_CONFIG_OUTPUTS ]; then
  SHOW_GIT_CONFIG_OUTPUTS=1;
fi;


# ------------------------------------------------------------

# STRICT_HOSTKEY_CHECKING=0;
# STRICT_HOSTKEY_CHECKING=1;
if [ ! -v STRICT_HOSTKEY_CHECKING ]; then
  STRICT_HOSTKEY_CHECKING=1; # 0 to use " -o StrictHostKeyChecking=no"
fi;


# ------------------------------------------------------------

# Additional options to which affect each and every Git call (push, pull, fetch, etc.)
GIT_SSH_OPTS="";
if [ ${STRICT_HOSTKEY_CHECKING} -eq 0 ]; then
  GIT_SSH_OPTS=" -o StrictHostKeyChecking=no";
fi;


# ------------------------------------------------------------
# Environment Variables
#  |--> Convert filepaths into both Win32 && Linux compatible variables

START_TIMESTAMP="$(date +'%Y%m%d%H%M%S')";

DISK_ROOT="";
if [ -d "/c" ]; then
  DISK_ROOT="/c";
elif [ -d "/mnt/c" ]; then
  DISK_ROOT="/mnt/c";
fi;

# USERPROFILE_LINUX=""; MM=$(realpath "${USERPROFILE}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; USERPROFILE_LINUX="${HOME}" || USERPROFILE_LINUX="${MM}";
# USERPROFILE_WIN32=""; MM=$(realpath "${USERPROFILE}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; USERPROFILE_WIN32="${MM}";

if [ ! -v APPDATA ]; then
  WIN32_USERNAME=$(get_username_windows_wsl);
  export APPDATA="/mnt/c/Users/${WIN32_USERNAME}/AppData/Roaming";
fi

APPDATA_LINUX=""; MM=$(realpath "${APPDATA}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; APPDATA_LINUX="${MM}";
APPDATA_WIN32=""; MM=$(realpath "${APPDATA}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; APPDATA_WIN32="${MM}";

LOCALAPPDATA_LINUX=""; MM=$(realpath "${LOCALAPPDATA}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; LOCALAPPDATA_LINUX="${MM}";
LOCALAPPDATA_WIN32=""; MM=$(realpath "${LOCALAPPDATA}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; LOCALAPPDATA_WIN32="${MM}";

TEMP_FILES_LINUX=""; MM="${LOCALAPPDATA_LINUX}/Temp";
TEMP_FILES_WIN32=""; MM="${LOCALAPPDATA_WIN32}\\Temp\\${START_TIMESTAMP}";

PROG_FILES_X64_W_FALLBACK=${PROGRAMFILES:-C:\\Program Files};
PROG_FILES_X64_LINUX=""; MM=$(realpath "${PROG_FILES_X64_W_FALLBACK}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; PROG_FILES_X64_LINUX="${MM}";
PROG_FILES_X64_WIN32=""; MM=$(realpath "${PROG_FILES_X64_W_FALLBACK}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; PROG_FILES_X64_WIN32="${MM}";

PROG_FILES_X86_LINUX="${PROG_FILES_X64_LINUX} (x86)";
PROG_FILES_X86_WIN32="${PROG_FILES_X64_WIN32} (x86)";

PROG_DATA_W_FALLBACK=${ProgramData:-C:\\ProgramData};
PROG_DATA_LINUX=""; MM=$(realpath "${PROG_DATA_W_FALLBACK}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; PROG_DATA_LINUX="${MM}";
PROG_DATA_WIN32=""; MM=$(realpath "${PROG_DATA_W_FALLBACK}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; PROG_DATA_WIN32="${MM}";

TEMPDIR_LINUX="${LOCALAPPDATA_LINUX}/Temp";
TEMPDIR_WIN32="${LOCALAPPDATA_WIN32}\\Temp";

Write-Host "APPDATA=\"${APPDATA}\"";
Write-Host "APPDATA_LINUX=\"${APPDATA_LINUX}\"";
Write-Host "APPDATA_WIN32=\"${APPDATA_WIN32}\"";
Write-Host "LOCALAPPDATA_LINUX=\"${LOCALAPPDATA_LINUX}\"";
Write-Host "LOCALAPPDATA_WIN32=\"${LOCALAPPDATA_WIN32}\"";
Write-Host "TEMP_FILES_LINUX=\"${TEMP_FILES_LINUX}\"";
Write-Host "TEMP_FILES_WIN32=\"${TEMP_FILES_WIN32}\"";
Write-Host "PROG_FILES_X64_W_FALLBACK=\"${PROG_FILES_X64_W_FALLBACK}\"";
Write-Host "PROG_FILES_X64_LINUX=\"${PROG_FILES_X64_LINUX}\"";
Write-Host "PROG_FILES_X64_WIN32=\"${PROG_FILES_X64_WIN32}\"";
Write-Host "PROG_FILES_X86_LINUX=\"${PROG_FILES_X86_LINUX}\"";
Write-Host "PROG_FILES_X86_WIN32=\"${PROG_FILES_X86_WIN32}\"";
Write-Host "PROG_DATA_W_FALLBACK=\"${PROG_DATA_W_FALLBACK}\"";
Write-Host "PROG_DATA_LINUX=\"${PROG_DATA_LINUX}\"";
Write-Host "PROG_DATA_WIN32=\"${PROG_DATA_WIN32}\"";
Write-Host "TEMPDIR_LINUX=\"${TEMPDIR_LINUX}\"";
Write-Host "TEMPDIR_WIN32=\"${TEMPDIR_WIN32}\"";


# ------------------------------------------------------------
# Git Default Path(s)

GIT_EXE_DEFAULT_DIR="${EXEPATH:-${PROGRAMFILES:-C:\\Program Files}\\Git}\usr\bin";
GIT_EXE_DIR_LINUX=""; MM=$(realpath "${GIT_EXE_DEFAULT_DIR}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; GIT_EXE_DIR_LINUX="${MM}";
GIT_EXE_DIR_WIN32=""; MM=$(realpath "${GIT_EXE_DEFAULT_DIR}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; GIT_EXE_DIR_WIN32="${MM}";

GIT_CONF_SYSTEM_PATHS_LINUX="${TEMP_FILES_LINUX}/git.config.system.${START_TIMESTAMP}.txt";
GIT_CONF_SYSTEM_PATHS_WIN32="${TEMP_FILES_LINUX}\\git.config.system.${START_TIMESTAMP}.txt";

GIT_CONF_GLOBAL_PATHS_LINUX="${TEMP_FILES_LINUX}/git.config.globals.${START_TIMESTAMP}.txt";
GIT_CONF_GLOBAL_PATHS_WIN32="${TEMP_FILES_WIN32}\\git.config.globals.${START_TIMESTAMP}.txt";

# ------------------------------------------------------------
# GnuPG Default Path(s)

GPG4WIN_EXE_DIR_LINUX="${PROG_FILES_X86_LINUX}/GnuPG/bin";
GPG4WIN_EXE_DIR_WIN32="${PROG_FILES_X86_WIN32}\GnuPG\bin";

GPG4WIN_GPG_EXE_LINUX="${GPG4WIN_EXE_DIR_LINUX}/gpg.exe";
GPG4WIN_GPG_EXE_WIN32="${GPG4WIN_EXE_DIR_WIN32}\gpg.exe";

# ------------------------------------------------------------

# Check if running as w/ administrative privileges (or not)
# IS_ADMIN=$(net session > /dev/null 2>&1; if [ "$?" -ne "0" ]; then echo 0; else echo 1; fi;);
# if [ "${IS_ADMIN}" == "0" ]; then
#   echo "";
#   echo "Error: Must \"Run as Administrator\" on the Git Bash terminal";
#   echo "";
#   sleep 60;
#   exit 1;

# el
if [ ! -e "${GPG4WIN_GPG_EXE_LINUX}" ]; then
  #
  # Gpg4win --> GnuPG Key Hander
  #   Make sure that "Gpg4win" is installed, as it both upgrades Git's default "gpg.exe" runtime, and
  #   also brings along "Kleopatra", a Windows handler for gpg-keys w/ a front-end GUI & server-sync built-in
  #
  echo "Error: Unable to locate \"Gpg4win\" directory";
  echo " |--> Please download & install \"Gpg4win\" via : https://www.gpg4win.org/thanks-for-download.html ";
  echo " |--> Once Gpg4win is installed, import/create your GnuPG keys using its \"Kleopatra\" included module ";
  sleep 60;
  exit 1;

fi;

# ------------------------------------------------------------
# Git - Setup all known Windows git config-file locations
# ------------------------------------------------------------

ROLLBACK_IFS="${IFS}";
IFS=$'\n'; # Set the global for-loop delimiter to newlines (ignore spaces)

GIT_CONF_SYSTEM_FILE_1=$(realpath "${DISK_ROOT}/ProgramData/Git/config" 2>/dev/null);
GIT_CONF_SYSTEM_FILE_2=$(realpath "${DISK_ROOT}/Program Files/Git/mingw64/etc/gitconfig" 2>/dev/null);

GIT_CONF_GLOBAL_FILE_1=$(realpath "${HOME}/.gitconfig" 2>/dev/null);
GIT_CONF_GLOBAL_FILE_2=$(realpath "${XDG_CONFIG_HOME:-${HOME}}/git/config" 2>/dev/null);

echo -n "" > "${GIT_CONF_SYSTEM_PATHS_LINUX}";
if [ -f "${GIT_CONF_SYSTEM_FILE_1}" ]; then echo "${GIT_CONF_SYSTEM_FILE_1}" >> "${GIT_CONF_SYSTEM_PATHS_LINUX}"; fi;
if [ -f "${GIT_CONF_SYSTEM_FILE_2}" ]; then echo "${GIT_CONF_SYSTEM_FILE_2}" >> "${GIT_CONF_SYSTEM_PATHS_LINUX}"; fi;

echo -n "" > "${GIT_CONF_GLOBAL_PATHS_LINUX}";
if [ -f "${GIT_CONF_GLOBAL_FILE_1}" ]; then echo "${GIT_CONF_GLOBAL_FILE_1}" >> "${GIT_CONF_GLOBAL_PATHS_LINUX}"; fi;
if [ -f "${GIT_CONF_GLOBAL_FILE_2}" ]; then echo "${GIT_CONF_GLOBAL_FILE_2}" >> "${GIT_CONF_GLOBAL_PATHS_LINUX}"; fi;

# ------------------------------------------------------------
# Git - Locate remaining Git-Configs
# ------------------------------------------------------------

SEARCH_DIRECTORIES=();
SEARCH_DIRECTORIES+=("${LOCALAPPDATA_LINUX}/");
SEARCH_DIRECTORIES+=("${PROG_FILES_X64_LINUX}/");
SEARCH_DIRECTORIES+=("${PROG_FILES_X86_LINUX}/");

for EACH_DIRECTORY in "${SEARCH_DIRECTORIES[@]}"; do

  HAYSTACK=$(realpath "${EACH_DIRECTORY}");
  NEEDLE="git.exe";
  echo "Info: Searching haystack \"${HAYSTACK}\" for needle \"${NEEDLE}\"...";
  find "${HAYSTACK}" \
  -type f \
  -name "${NEEDLE}" \
  -print0 \
  2>"/dev/null" \
  | while IFS= read -r -d $'\0' EACH_GIT_EXE; do

    EACH_GIT_LINUX=""; MM=$(realpath "${EACH_GIT_EXE}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; EACH_GIT_LINUX="${MM}";
    EACH_GIT_WIN32=""; MM=$(realpath "${EACH_GIT_EXE}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; EACH_GIT_WIN32="${MM}";

    SYSTEM_CONF_PATH=$("${EACH_GIT_LINUX}" config --system --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
    SYSTEM_CONF_LINUX=""; MM=$(realpath "${SYSTEM_CONF_PATH}"); MM="${MM/C:/${DISK_ROOT}}"; MM="${MM//\\/\/}"; SYSTEM_CONF_LINUX="${MM}";
    SYSTEM_ALREADY_NOTED=$(cat "${GIT_CONF_SYSTEM_PATHS_LINUX}" | grep "${SYSTEM_CONF_LINUX}");
    if [ ! -n "${SYSTEM_ALREADY_NOTED}" ]; then
      echo "${SYSTEM_CONF_LINUX}" >> "${GIT_CONF_SYSTEM_PATHS_LINUX}";
    fi;

    GLOBAL_CONF_PATH=$("${EACH_GIT_LINUX}" config --global --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
    GLOBAL_CONF_LINUX=""; MM=$(realpath "${GLOBAL_CONF_PATH}"); MM="${MM/C:/${DISK_ROOT}}"; MM="${MM//\\/\/}"; GLOBAL_CONF_LINUX="${MM}";
    GLOBAL_ALREADY_NOTED=$(cat "${GIT_CONF_GLOBAL_PATHS_LINUX}" | grep "${GLOBAL_CONF_LINUX}");
    if [ ! -n "${GLOBAL_ALREADY_NOTED}" ]; then
      echo "${GLOBAL_CONF_LINUX}" >> "${GIT_CONF_GLOBAL_PATHS_LINUX}";
    fi;

  done;

done;

IFS="${ROLLBACK_IFS}";

# ------------------------------------------------------------
# Repositories  :::  General/Global && System Configs
# ------------------------------------------------------------

if [ "list gnupg" == "key ids" ]; then
  gpg --list-keys;
fi;

#
# Locate the default GnuPG Pin-Entry Program
#  |
#  |--> There are many places in Windows that GnuPG will look for the pin-entry executable
#  |
#  |--> Quote from [   man gpg-agent   ]  :
#   "
#     ...
#     On a Windows platform the default is to use the first existing program from this list: ‘bin\pinen‐
#     try.exe’,  ‘..\Gpg4win\bin\pinentry.exe’,  ‘..\Gpg4win\pinentry.exe’, ‘..\GNU\GnuPG\pinentry.exe’,
#     ‘..\GNU\bin\pinentry.exe’, ‘bin\pinentry-basic.exe’ where the file names are relative to the GnuPG
#     installation directory.
#     ...
#   "
#

GPG_PINENTRY_EXE="";
if [ -f "${DISK_ROOT}/Program Files (x86)/GnuPG/bin/pinentry.exe" ]; then GPG_PINENTRY_EXE=$(realpath "${DISK_ROOT}/Program Files (x86)/GnuPG/bin/pinentry.exe");
elif [ -f "${DISK_ROOT}/Program Files (x86)/GnuPG/../Gpg4win/bin/pinentry.exe" ]; then GPG_PINENTRY_EXE=$(realpath "${DISK_ROOT}/Program Files (x86)/GnuPG/../Gpg4win/bin/pinentry.exe");
elif [ -f "${DISK_ROOT}/Program Files (x86)/GnuPG/../Gpg4win/pinentry.exe" ]; then GPG_PINENTRY_EXE=$(realpath "${DISK_ROOT}/Program Files (x86)/GnuPG/../Gpg4win/pinentry.exe");
elif [ -f "${DISK_ROOT}/Program Files (x86)/GnuPG/../GNU/GnuPG/pinentry.exe" ]; then GPG_PINENTRY_EXE=$(realpath "${DISK_ROOT}/Program Files (x86)/GnuPG/../GNU/GnuPG/pinentry.exe");
elif [ -f "${DISK_ROOT}/Program Files (x86)/GnuPG/../GNU/bin/pinentry.exe" ]; then GPG_PINENTRY_EXE=$(realpath "${DISK_ROOT}/Program Files (x86)/GnuPG/../GNU/bin/pinentry.exe");
elif [ -f "${DISK_ROOT}/Program Files (x86)/GnuPG/bin/pinentry-basic.exe" ]; then GPG_PINENTRY_EXE=$(realpath "${DISK_ROOT}/Program Files (x86)/GnuPG/bin/pinentry-basic.exe");
fi;

echo "Info: GnuPG exe - Git  (gpg.exe) :  \"${GIT_EXE_DIR_LINUX}/gpg.exe\"";
echo "Info: GnuPG exe - Gpg4win  (gpg.exe) :  \"${GPG4WIN_GPG_EXE_LINUX}\"";
echo "Info: GnuPG pinentry exe (pinentry.exe) :  \"${GPG_PINENTRY_EXE}\"";

for EACH_FILE in $(ls "${GPG4WIN_EXE_DIR_LINUX}" | grep .exe); do
  EACH_FULLPATH="${GPG4WIN_EXE_DIR_LINUX}/${EACH_FILE}";
  if [ -f "${GPG4WIN_EXE_DIR_LINUX}/${EACH_FILE}" ]; then # 
    if [ -L "${GIT_EXE_DIR_LINUX}/${EACH_FILE}" ]; then
      EACH_FILE_OUTPUT=$(ls -al "${GPG4WIN_EXE_DIR_LINUX}" | awk '{print $9,$10,$11}' | grep "${EACH_FILE}");
      # echo "Pass - ${EACH_FILE_OUTPUT}";
    else
      if [ -f "${GIT_EXE_DIR_LINUX}/${EACH_FILE}" ]; then
        echo "";
        mv --verbose "${GIT_EXE_DIR_LINUX}/${EACH_FILE}" "${GIT_EXE_DIR_LINUX}/${EACH_FILE}.$(date +'%Y%m%d-%H%M%S').bak";
      fi;
      # Redirect Git's [ gpg.exe ] runtime to, instead, refer to Gpg4win's [ gpg.exe ] runtime
      echo "";
      echo "MKLINK \"${GIT_EXE_DIR_WIN32}\\${EACH_FILE}\" \"${GPG4WIN_EXE_DIR_WIN32}\\${EACH_FILE}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
    fi;
  fi;
done;

#
# Once gpg.exe's are redirected as-intended (e.g. once all gpg.exe's all refer/redirect to Gpg4win's gpg.exe)...
# The next step is to locate GnuPG's configuration filepath(s)
#  |--> To accomplish this, this script will locate the primary gpg-agent.conf script location, then redirect (sym-link) other possible gpg-agent.conf locations to centralize on it
#
# Gpg4win's GnuPG configuration (on Windows workstations) is stored in one of two locations   -->   %APPDATA%\gnupg  ||  %USERPROFILE%\.gnupg
#

mkdir --parents --verbose "$(realpath ${HOME})/.gnupg";
mkdir --parents --verbose "$(realpath ${APPDATA_LINUX})/gnupg";

USERPROFILE_GNUPG_LINUX="$(realpath ${HOME}/.gnupg)";
USERPROFILE_GNUPG_WIN32=""; MM="${USERPROFILE_GNUPG_LINUX/${DISK_ROOT}\//C:\\}"; USERPROFILE_GNUPG_WIN32="${MM//\//\\}";

GCONF_USERPROFILE_LINUX="${USERPROFILE_GNUPG_LINUX}/gpg-agent.conf";
GCONF_USERPROFILE_WIN32="${USERPROFILE_GNUPG_WIN32}\gpg-agent.conf";

GCONF_APPDATA_DIR_LINUX="$(realpath ${APPDATA_LINUX}/gnupg)";
GCONF_APPDATA_DIR_WIN32=""; MM="${GCONF_APPDATA_DIR_LINUX/${DISK_ROOT}\//C:\\}"; GCONF_APPDATA_DIR_WIN32="${MM//\//\\}";

GCONF_APPDATA_LINUX="${GCONF_APPDATA_DIR_LINUX}/gpg-agent.conf";
GCONF_APPDATA_WIN32="${GCONF_APPDATA_DIR_WIN32}\gpg-agent.conf";

# Find the primary config-file, then compare it to the possible config-locations, above
GCONF_PRIMARY_DIR_LINUX=""; MM="${GPG_CONFIG_DIR/C:/${DISK_ROOT}}"; MM="${MM//\\//}"; GCONF_PRIMARY_DIR_LINUX="$(realpath ${MM})";
GCONF_PRIMARY_DIR_WIN32=""; MM="${GPG_CONFIG_DIR/${DISK_ROOT}\//C:\\}"; GCONF_PRIMARY_DIR_WIN32="${MM//\//\\}";

GCONF_PRIMARY_LINUX="${GCONF_PRIMARY_DIR_LINUX}/gpg-agent.conf";
GCONF_PRIMARY_WIN32="${GCONF_PRIMARY_DIR_WIN32}\gpg-agent.conf";

echo "Info: GnuPG %USERPROFILE% Config-File (Linux): \"${GCONF_USERPROFILE_LINUX}\"";
# echo "Info: GnuPG %USERPROFILE% Config-File (Win32): \"${GCONF_USERPROFILE_WIN32}\"";

echo "Info: GnuPG %APPDATA% Config-File (Linux): \"${GCONF_APPDATA_LINUX}\"";
# echo "Info: GnuPG %APPDATA% Config-File (Win32): \"${GCONF_APPDATA_WIN32}\"";

echo "Info: GnuPG Default Config-File (Linux): \"${GCONF_PRIMARY_LINUX}\"";
# echo "Info: GnuPG Default Config-File (Win32): \"${GCONF_PRIMARY_WIN32}\"";

# ------------------------------------------------------------

# [ GnuPG USER-DIR ] gpg.conf
EACH_CONF="gpg.conf";
EACH_FULLCONF="${GCONF_PRIMARY_DIR_LINUX}/${EACH_CONF}";
if [ ! -f "${EACH_FULLCONF}" ]; then
  echo -n "" > "${EACH_FULLCONF}";
fi;

# if [ "$(cat ${EACH_FULLCONF} | grep 'pinentry-mode')" == "" ]; then echo "pinentry-mode loopback" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'passphrase')" == "" ]; then echo "passphrase $(cat ${HOME}/.gnupg/passphrase.personal)" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'verbose')" == "" ]; then echo "verbose" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'utf8-strings')" == "" ]; then echo "utf8-strings" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'keyid-format')" == "" ]; then echo "keyid-format ${GPG_KEY_ID_FORMAT}" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'keyserver-options')" == "" ]; then echo "keyserver-options ${GPG_KEYSERVER_OPTIONS}" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'keyserver')" == "" ]; then echo "keyserver ${GPG_KEYSERVER_URL}" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'no-tty')" == "" ]; then echo "no-tty" >> "${EACH_FULLCONF}"; fi; # try disable TTY if you have problems with making auto-signed commits from your IDE or other software

# ------------------------------------------------------------

# [ GnuPG USER-DIR ] gpg-agent.conf
EACH_CONF="gpg-agent.conf";
EACH_FULLCONF="${GCONF_PRIMARY_DIR_LINUX}/${EACH_CONF}";
if [ ! -f "${EACH_FULLCONF}" ]; then
  echo -n "" > "${EACH_FULLCONF}";
fi;

# if [ "$(cat ${EACH_FULLCONF} | grep 'pinentry-timeout')" == "" ]; then echo "pinentry-timeout 0" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'batch')" == "" ]; then echo "batch" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'allow-loopback-pinentry')" == "" ]; then echo "allow-loopback-pinentry" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'allow-preset-passphrase')" == "" ]; then echo "allow-preset-passphrase" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'default-cache-ttl-ssh')" == "" ]; then echo "default-cache-ttl-ssh ${GPG_CACHE_TIMEOUT}" >> "${EACH_FULLCONF}"; fi;
# if [ "$(cat ${EACH_FULLCONF} | grep 'max-cache-ttl-ssh')" == "" ]; then echo "max-cache-ttl-ssh ${GPG_CACHE_TIMEOUT}" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'default-cache-ttl')" == "" ]; then echo "default-cache-ttl ${GPG_CACHE_TIMEOUT}" >> "${EACH_FULLCONF}"; fi;
if [ "$(cat ${EACH_FULLCONF} | grep 'max-cache-ttl')" == "" ]; then echo "max-cache-ttl ${GPG_CACHE_TIMEOUT}" >> "${EACH_FULLCONF}"; fi;

# [ GnuPG USER-DIR ] gpgconf.conf
EACH_CONF="gpgconf.conf";
EACH_FULLCONF="${GCONF_PRIMARY_DIR_LINUX}/${EACH_CONF}";
if [ ! -f "${EACH_FULLCONF}" ]; then
  echo -n "" > "${EACH_FULLCONF}";
fi;

# ------------------------------------------------------------

# [ USERPROFILE ] *.conf - Creation / Symlinking
if [ "${GCONF_USERPROFILE_LINUX}" == "${GCONF_PRIMARY_LINUX}" ]; then
  # echo "";
  # echo "Pass - \"${GCONF_USERPROFILE_LINUX}\" IS the primary GnuPG config-file";
  MM="";
else
  # [ USERPROFILE ] gpg.conf
  EACH_CONF="gpg.conf";
  if [ ! -f "${USERPROFILE_GNUPG_LINUX}/${EACH_CONF}" ]; then
    echo "";
    echo "MKLINK \"${USERPROFILE_GNUPG_WIN32}\\${EACH_CONF}\" \"${GCONF_PRIMARY_DIR_WIN32}\\${EACH_CONF}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
  fi;
  # [ USERPROFILE ] gpgconf.conf
  EACH_CONF="gpgconf.conf";
  if [ ! -f "${USERPROFILE_GNUPG_LINUX}/${EACH_CONF}" ]; then
    echo "";
    echo "MKLINK \"${USERPROFILE_GNUPG_WIN32}\\${EACH_CONF}\" \"${GCONF_PRIMARY_DIR_WIN32}\\${EACH_CONF}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
  fi;
  # [ USERPROFILE ] gpg-agent.conf
  EACH_CONF="gpg-agent.conf";
  if [ ! -f "${USERPROFILE_GNUPG_LINUX}/${EACH_CONF}" ]; then
    echo "";
    echo "MKLINK \"${USERPROFILE_GNUPG_WIN32}\\${EACH_CONF}\" \"${GCONF_PRIMARY_DIR_WIN32}\\${EACH_CONF}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
  fi;
fi;

# ------------------------------------------------------------

# [ APPDATA ] *.conf - Config File Creation / Symlinking
if [ "${GCONF_APPDATA_LINUX}" == "${GCONF_PRIMARY_LINUX}" ]; then
  # echo "";
  # echo "Pass - \"${GCONF_APPDATA_LINUX}\" IS the primary GnuPG config-file";
  MM="";
else
  # [ APPDATA ] gpg.conf
  EACH_CONF="gpg.conf";
  if [ ! -f "${GCONF_APPDATA_DIR_LINUX}/${EACH_CONF}" ]; then
    echo "";
    echo "MKLINK \"${GCONF_APPDATA_DIR_WIN32}\\${EACH_CONF}\" \"${GCONF_PRIMARY_DIR_WIN32}\\${EACH_CONF}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
  fi;
  # [ APPDATA ] gpgconf.conf
  EACH_CONF="gpgconf.conf";
  if [ ! -f "${GCONF_APPDATA_DIR_LINUX}/${EACH_CONF}" ]; then
    echo "";
    echo "MKLINK \"${GCONF_APPDATA_DIR_WIN32}\\${EACH_CONF}\" \"${GCONF_PRIMARY_DIR_WIN32}\\${EACH_CONF}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
  fi;
  # [ APPDATA ] gpg-agent.conf
  EACH_CONF="gpg-agent.conf";
  if [ ! -f "${GCONF_APPDATA_DIR_LINUX}/${EACH_CONF}" ]; then
    echo "";
    echo "MKLINK \"${GCONF_APPDATA_DIR_WIN32}\\${EACH_CONF}\" \"${GCONF_PRIMARY_DIR_WIN32}\\${EACH_CONF}\" " | CMD; # MKLINK Syntax: [ MKLINK "NEW_LINK" "EXISTING_TARGET" ]
  fi;
fi;

# ------------------------------------------------------------

# Personal Repos - Clear GPG commit key-ids when the associated ssh-key doesn't exist
# if [ ! -f "${GIT_SSH_PERSONAL}" ]; then
#   GPG_KEY_ID_PERSONAL="";
#   GPG_PASS_FILE_PERSONAL="";
# fi;

# # Work Repos - Clear GPG commit key-ids when the associated ssh-key doesn't exist
# if [ ! -f "${GIT_SSH_WORK}" ]; then
#   GPG_KEY_ID_WORK="";
#   GPG_PASS_FILE_WORK="";
# fi;

# if [ -f "${GIT_SSH_PERSONAL}" ]; then
#   #  PERSONAL SSH-KEY EXISTS
#   # GLOBAL_COMMIT_NAME="${COMMIT_NAME_PERSONAL}";
#   # GLOBAL_COMMIT_EMAIL="${GIT_EMAIL_PERSONAL}";
#   GLOBAL_COMMIT_SSH_KEY="${GIT_SSH_PERSONAL}";
#   # GLOBAL_DEFAULT_GPG_KEY="${GPG_KEY_ID_PERSONAL}";

# elif [ ! -f "${GIT_SSH_PERSONAL}" ] && [ -f "${GIT_SSH_WORK}" ]; then
#   #  PERSONAL SSH-KEY DOESN'T EXIST BUT WORK SSH-KEY EXISTS
#   # GLOBAL_COMMIT_NAME="${COMMIT_NAME_WORK}";
#   # GLOBAL_COMMIT_EMAIL="${GIT_EMAIL_WORK}";
#   GLOBAL_COMMIT_SSH_KEY="${GIT_SSH_WORK}";
#   # GLOBAL_DEFAULT_GPG_KEY="${GPG_KEY_ID_WORK}";

# else 
#   echo "";
#   echo "Error: No SSH-Key(s) found for git-repos (work OR personal)";
#   sleep 60;
#   exit 1;

# fi;

# ------------------------------------------------------------
# [ SYSTEM ] Git Configs
#      +
# [ GLOBAL ] Git Configs

###  Download the "git_config_all" script, which will scour the current drive for all git exe's, then
###  perform config-updates on each exe's global & system config-files with the values given (below)
# GIT_CONFIG_ALL_REPO="https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/git_config_all" && \
# GIT_CONFIG_ALL_LOCAL="${HOME}/.gpg_git/git_config_all" && \
# mkdir -p $(dirname "${GIT_CONFIG_ALL_LOCAL}") && \
# curl --silent --output "${GIT_CONFIG_ALL_LOCAL}" "${GIT_CONFIG_ALL_REPO}";

# if [ 0 -eq 1 ]; then

# if [ -f "${GIT_CONFIG_ALL_LOCAL}" ]; then

# # Strings
# KEY="color.ui";        VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
# KEY="core.autocrlf";   VAL=$(test "${REPO}" == *"infrastructure" && echo "false" || echo "input";);   git config --local --replace-all  "${KEY}" "${VAL}";
# KEY="core.eol";        VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
# # Unsets
# KEY="core.sshcommand";               "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";
# KEY="commit.gpgsign";                "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";
# KEY="gpg.program";                   "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";
# KEY="push.gpgsign";                  "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";
# KEY="user.email";                    "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";
# KEY="user.name";                     "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";
# KEY="user.signingkey";               "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "--unset";

# rm -f "${GIT_CONFIG_ALL_LOCAL}";

# fi;

# fi;

# ------------------------------------------------------------
# [ GLOBAL ] Git Configs
#    |
#    |--> User-specific, e.g. Private Values
#
#
# Strings
# KEY="user.name";        VAL="${GLOBAL_COMMIT_NAME}";                   git config --global --replace-all "${KEY}" "${VAL}";
# KEY="user.email";       VAL="${GLOBAL_COMMIT_EMAIL}";                  git config --global --replace-all "${KEY}" "${VAL}";
# KEY="core.sshcommand";  VAL="ssh -4 -i '${GLOBAL_COMMIT_SSH_KEY}'${GIT_SSH_OPTS}"     git config --global --replace-all "${KEY}" "${VAL}";
# KEY="gpg.program";      VAL="${GPG4WIN_GPG_EXE_WIN32}";                git config --global --replace-all "${KEY}" "${VAL}";
# KEY="core.autocrlf";    VAL="input";  "${GIT_CONFIG_ALL_LOCAL}" "${KEY}" "${VAL}";
# KEY="core.eol";         VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
# KEY="color.ui";         VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
# Booleans
# KEY="commit.gpgsign";   VAL="true";                                    git config --global --replace-all --bool "${KEY}" "${VAL}";
#
# [ GLOBAL ] Git Config, List Values
# echo "";
# echo "[ GLOBAL ] Git-Config Updated:";
# if [ "${SHOW_GIT_CONFIG_OUTPUTS}" -gt "0" ]; then
#   echo "------------------------------------------------------------";
#   echo "$(git config --global --list;)";
#   echo "------------------------------------------------------------";
# fi;


# ------------------------------------------------------------
# Repositories  :::  Personal
# ------------------------------------------------------------

# SSH-Key, Email
# if [ -f "${GIT_SSH_PERSONAL}" ]; then
#   COMMIT_NAME="${COMMIT_NAME_PERSONAL}";
#   COMMIT_EMAIL="${GIT_EMAIL_PERSONAL}"; # Email
#   SSH_KEY="${GIT_SSH_PERSONAL}"; # SSH-Key
#   if [ -n "${GPG_KEY_ID_PERSONAL}" ]; then
#     GPG_KEY_ID="${GPG_KEY_ID_PERSONAL}"; # GPG-Key
#   fi;
# elif [ -f "${GIT_SSH_WORK}" ]; then
#   COMMIT_NAME="${COMMIT_NAME_WORK}";
#   COMMIT_EMAIL="${GIT_EMAIL_WORK}"; # Email
#   SSH_KEY="${GIT_SSH_WORK}"; # SSH-Key
#   if [ -n "${GPG_KEY_ID_WORK}" ]; then
#     GPG_KEY_ID="${GPG_KEY_ID_WORK}"; # GPG-Key
#   fi;
# else
#   echo "";
#   echo "Error: No SSH-Key(s) found for personal git-repos";
#   echo "";
#   sleep 60;
#   exit 1;
# fi;


# ------------------------------------------------------------
#   GIT REPOS
#    |--> FIND ALL IN HOME-DIR

# if [ 0 -eq 1 ]; then

  echo "------------------------------------------------------------"
  echo ""
  echo "Beginning Exclusions search..."

  unset EXCLUDED_HOMEDIRS; declare -A EXCLUDED_HOMEDIRS; # [Re-]Instantiate bash array

  # AppData
  if [ -d "${HOME}/AppData" ]; then
    EXCLUDED_HOMEDIRS+=(["${HOME}/AppData"]="");
  fi;
  # DropBox
  if [ -d "${HOME}/Dropbox" ]; then
    EXCLUDED_HOMEDIRS+=(["${HOME}/Dropbox"]="");
  fi;
  # Google Drive
  if [ -d "${HOME}/Google Drive" ]; then
    EXCLUDED_HOMEDIRS+=(["${HOME}/Google Drive"]="");
  fi;
  # iCloud (Apple)
  if [ -d "${HOME}/iCloudDrive" ]; then
    EXCLUDED_HOMEDIRS+=(["${HOME}/iCloudDrive"]="");
  fi;

  #
  # Exclude OneDrive Dirs
  #   |--> Note: Running 'find' against OneDrive files causes them to be downloaded (if cloud synced), effectively ruining the functionality of OneDrive's "Files On-Demand" feature
  #
  REGKEY_ONEDRIVE_BUSINESS="Registry::HKEY_CURRENT_USER\Software\Microsoft\OneDrive\Accounts\Business1\ScopeIdToMountPointPathCache";  # OneDrive for Business
  REGKEY_ONEDRIVE_PERSONAL="Registry::HKEY_CURRENT_USER\Software\Microsoft\OneDrive\Accounts\Personal\ScopeIdToMountPointPathCache";   # OneDrive Personal
  PS1_ONEDRIVE_BUSINESS="(Get-Item ('${REGKEY_ONEDRIVE_BUSINESS}')).Property | ForEach-Object { Get-ItemPropertyValue -Path ('${REGKEY_ONEDRIVE_BUSINESS}') -Name (\$_) -ErrorAction ('SilentlyContinue')}; ";
  PS1_ONEDRIVE_PERSONAL="(Get-Item ('${REGKEY_ONEDRIVE_PERSONAL}')).Property | ForEach-Object { Get-ItemPropertyValue -Path ('${REGKEY_ONEDRIVE_PERSONAL}') -Name (\$_) -ErrorAction ('SilentlyContinue')}; ";
  DIRS_ONEDRIVE_BUSINESS=$(PowerShell -Command "${PS1_ONEDRIVE_BUSINESS}";);
  DIRS_ONEDRIVE_PERSONAL=$(PowerShell -Command "${PS1_ONEDRIVE_PERSONAL}";);
  
  echo -e "${DIRS_ONEDRIVE_BUSINESS}""\n""${DIRS_ONEDRIVE_PERSONAL}" | while read -r EACH_PATH; do
    # Verify each path exists before excluding it (otherwise it doesn't matter)
    EACH_PATH_WIN32=""; MM=$(realpath "${EACH_PATH}" 2>/dev/null;); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; EACH_PATH_WIN32="${MM}";
    EACH_PATH_LINUX=""; MM=$(realpath "${EACH_PATH}" 2>/dev/null;); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; EACH_PATH_LINUX="${MM}";
    if [ -n "${EACH_PATH_LINUX}" ] && [ -d "${EACH_PATH_LINUX}" ]; then
      EXCLUDED_HOMEDIRS+=(["${EACH_PATH_LINUX}"]="");
      DIRNAME_EACHPATH=$(dirname "${EACH_PATH_LINUX}");
      if [ -d "${DIRNAME_EACHPATH}" ] && [ "${DIRNAME_EACHPATH}" != "${HOME}" ]; then
        EXCLUDED_HOMEDIRS+=(["${DIRNAME_EACHPATH}"]="");
      fi;
    fi;
  done;

  EXCLUDED_HOMEDIRS_NO_DUPES=($(echo "${EXCLUDED_HOMEDIRS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '));

  unset REPO_FULLPATHS; declare -A REPO_FULLPATHS; # [Re-]Instantiate bash array

  echo "------------------------------------------------------------";
  echo "";
  echo "Beginning Home-Dir search...";

  # Get all dirs within current user's home-dir
  find "${HOME}" -mindepth 1 -maxdepth 1 -type d | while read -r EACH_HOMEDIR; do

    DIR_IS_EXCLUDED=0;
    for EACH_EXCLUDED_DIR in "${!EXCLUDED_HOMEDIRS[@]}"; do
      if [ "${EACH_HOMEDIR}" == "${EACH_EXCLUDED_DIR}" ]; then
        DIR_IS_EXCLUDED=1;
      fi;
    done;

    if [ ${DIR_IS_EXCLUDED} -eq 0 ]; then
      echo "Directory NOT excluded: \"${EACH_HOMEDIR}\" - Searching it for .git config(s)..."
      # Not an excluded directory - search it for directories with name ".git"
      find "${EACH_HOMEDIR}" \
      -maxdepth 4 \
      -type d \
      -name ".git" \
      -print0 2>"/dev/null" \
      | while IFS= read -r -d $'\0' EACH_GIT_CONFIG_PATH; do
        EACH_REPO_FULLPATH=$(dirname "${EACH_GIT_CONFIG_PATH}";);
        REPO_FULLPATHS+=(["${EACH_REPO_FULLPATH}"]="");
      done;
    fi;
  done;

  # Loop through array of local repository filepaths, attempting to parse their values & set applicable [ git config ... ] settings for each
  for EACH_REPO_FULLPATH in "${!REPO_FULLPATHS[@]}"; do

    EACH_REPO_BASENAME=$(basename "${EACH_REPO_FULLPATH}";);
    EACH_REPO_ORIGIN=$(cd "${EACH_REPO_FULLPATH}" && git config --get "remote.origin.url");
    if [[ ${EACH_REPO_ORIGIN} == https://*/*/* ]]; then
      # Origin-url in [ https://SERVICE.TLD/USER/REPO ] format
      EACH_REPO_FQDN=$(echo "${EACH_REPO_ORIGIN}" | sed --regexp-extended --quiet --expression='s/^https:\/\/([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+).git$/\1/ip' 2>/dev/null;);
      EACH_REPO_OWNER=$(echo "${EACH_REPO_ORIGIN}" | sed --regexp-extended --quiet --expression='s/^https:\/\/([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+).git$/\2/ip' 2>/dev/null;);
      EACH_REPO_NAME=$(echo "${EACH_REPO_ORIGIN}" | sed --regexp-extended --quiet --expression='s/^https:\/\/([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+).git$/\3/ip' 2>/dev/null;);
    else
      # Origin-url in [ git@SERVICE.TLD/USER/REPO ] format
      EACH_REPO_FQDN=$(echo "${EACH_REPO_ORIGIN}" | sed --regexp-extended --quiet --expression='s/^[a-z0-9\_\.\-]+@([a-z0-9\_\.\-]+):([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+).git$/\1/ip' 2>/dev/null;);
      EACH_REPO_OWNER=$(echo "${EACH_REPO_ORIGIN}" | sed --regexp-extended --quiet --expression='s/^[a-z0-9\_\.\-]+@([a-z0-9\_\.\-]+):([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+).git$/\2/ip' 2>/dev/null;);
      EACH_REPO_NAME=$(echo "${EACH_REPO_ORIGIN}" | sed --regexp-extended --quiet --expression='s/^[a-z0-9\_\.\-]+@([a-z0-9\_\.\-]+):([a-z0-9\_\.\-]+)\/([a-z0-9\_\.\-]+).git$/\3/ip' 2>/dev/null;);
    fi;
    EACH_REPO_URI="${EACH_REPO_FQDN}/${EACH_REPO_OWNER}/${EACH_REPO_NAME}";

    echo "";
    echo "Updating \"${EACH_REPO_BASENAME}\" repository @ path \"${EACH_REPO_FULLPATH}\"...";
    echo "  |--> Repo Source-URI:  ${EACH_REPO_URI}";

    COMMIT_EMAIL="";
    COMMIT_NAME="";
    SSH_KEY="";
    GPG_KEY_ID="";

    # ------------------------------------------------------------

    if [ -v GIT_SYNC_REPOS_ID1[${EACH_REPO_URI}] ] && [ -z "${SSH_KEY}" ]; then
      # Use Primary ID Array values, first
      TEST_EMAIL=$(echo "${GIT_SYNC_REPOS_ID1[${EACH_REPO_URI}]}");
      TEST_FULLNAME=$(echo "${GIT_SYNC_FULLNAMES[${TEST_EMAIL}]}");
      if [ -n "${TEST_EMAIL}" ] && [ -n "${TEST_FULLNAME}" ]; then
        SSH_KEY_SYNTAX="id_rsa_${EACH_REPO_FQDN}_${TEST_EMAIL}_*.pem";
        TEST_SSH_KEY=$(find "${HOME}/.ssh/" -type f -iname "${SSH_KEY_SYNTAX}" | head -n 1 2>/dev/null;);
        if [ -z "${TEST_SSH_KEY}" ]; then
          echo "  |--> No SSH-Key(s) found to match syntax \"${SSH_KEY_SYNTAX}\"";
        else
          echo "  |--> Found SSH-Key \"${TEST_SSH_KEY}\" matching syntax \"${SSH_KEY_SYNTAX}\"";
          EACH_SSH_KEY_WIN32=""; MM=$(realpath "${TEST_SSH_KEY}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; EACH_SSH_KEY_WIN32="${MM}";
          EACH_SSH_KEY_LINUX=""; MM=$(realpath "${TEST_SSH_KEY}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; EACH_SSH_KEY_LINUX="${MM}";
          # SSH_KEY="${EACH_SSH_KEY_WIN32}";
          SSH_KEY="${EACH_SSH_KEY_LINUX}";
          COMMIT_EMAIL="${TEST_EMAIL}";
          COMMIT_NAME="${TEST_FULLNAME}";
          TEST_GPG_KEY=$(echo "${GIT_SYNC_GPG_KEYS[${COMMIT_EMAIL}]}");
          LOCAL_GPG_KEY_MATCHES=$("${GPG4WIN_GPG_EXE_LINUX}" --list-keys --keyid-format 'LONG' | grep -i '^pub' | grep "/${TEST_GPG_KEY} " | wc -l 2>/dev/null;);
          if [ ${LOCAL_GPG_KEY_MATCHES} -gt 0 ]; then # GPG-Key for given email exists on local workstation
            GPG_KEY_ID="${TEST_GPG_KEY}";
            echo "  |--> Local match found for user \"${COMMIT_EMAIL}\" w/ GPG-Key \"${GPG_KEY_ID}\" & Full-Name \"${COMMIT_NAME}\"";
          else
            echo "  |--> NO local match found for user \"${COMMIT_EMAIL}\" w/ GPG-Key \"${GPG_KEY_ID}\"";
          fi;
        fi;
      fi;
    fi;

    if [ -v GIT_SYNC_REPOS_ID2[${EACH_REPO_URI}] ] && [ -z "${SSH_KEY}" ]; then
      # Fallback to Secondary ID Array values
      TEST_EMAIL=$(echo "${GIT_SYNC_REPOS_ID2[${EACH_REPO_URI}]}");
      TEST_FULLNAME=$(echo "${GIT_SYNC_FULLNAMES[${TEST_EMAIL}]}");
      if [ -n "${TEST_EMAIL}" ] && [ -n "${TEST_FULLNAME}" ]; then
        SSH_KEY_SYNTAX="id_rsa_${EACH_REPO_FQDN}_${TEST_EMAIL}_*.pem";
        TEST_SSH_KEY=$(find "${HOME}/.ssh/" -type f -iname "${SSH_KEY_SYNTAX}" | head -n 1 2>/dev/null;);
        if [ -z "${TEST_SSH_KEY}" ]; then
          echo "  |--> No SSH-Key(s) found to match syntax \"${SSH_KEY_SYNTAX}\"";
        else
          echo "  |--> Found SSH-Key \"${TEST_SSH_KEY}\" matching syntax \"${SSH_KEY_SYNTAX}\"";
          EACH_SSH_KEY_WIN32=""; MM=$(realpath "${TEST_SSH_KEY}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; EACH_SSH_KEY_WIN32="${MM}";
          EACH_SSH_KEY_LINUX=""; MM=$(realpath "${TEST_SSH_KEY}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; EACH_SSH_KEY_LINUX="${MM}";
          # SSH_KEY="${EACH_SSH_KEY_WIN32}";
          SSH_KEY="${EACH_SSH_KEY_LINUX}";
          COMMIT_EMAIL="${TEST_EMAIL}";
          COMMIT_NAME="${TEST_FULLNAME}";
          TEST_GPG_KEY=$(echo "${GIT_SYNC_GPG_KEYS[${COMMIT_EMAIL}]}");
          LOCAL_GPG_KEY_MATCHES=$("${GPG4WIN_GPG_EXE_LINUX}" --list-keys --keyid-format 'LONG' | grep -i '^pub' | grep "/${TEST_GPG_KEY} " | wc -l 2>/dev/null;);
          if [ ${LOCAL_GPG_KEY_MATCHES} -gt 0 ]; then # GPG-Key for given email exists on local workstation
            GPG_KEY_ID="${TEST_GPG_KEY}";
            echo "  |--> Local match found for user \"${COMMIT_EMAIL}\" w/ GPG-Key \"${GPG_KEY_ID}\" & Full-Name \"${COMMIT_NAME}\"";
          else
            echo "  |--> NO local match found for user \"${COMMIT_EMAIL}\" w/ GPG-Key \"${GPG_KEY_ID}\"";
          fi;
        fi;
      fi;
    fi;

    if [ -z "${SSH_KEY}" ]; then
      echo "  |--> No sync-array index exists for \$EACH_REPO_URI = [ ${EACH_REPO_URI} ]";
      echo "  |";
      echo "  |--> Sync-array indices must be pre-emptively added to config-file  \$GIT_SYNC_CONFIG_FULLPATH = [ ${GIT_SYNC_CONFIG_FULLPATH} ]";
    fi;

    # ------------------------------------------------------------

    if [ -n "${COMMIT_EMAIL}" ] && [ -n "${COMMIT_NAME}" ] && [ -n "${SSH_KEY}" ]; then

      cd "${EACH_REPO_FULLPATH}";

      GET_PATH=$(git config --local --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
      GET_PATH_WIN32=""; MM=$(realpath "${GET_PATH}"); MM="${MM/${DISK_ROOT}\//C:\\}"; MM="${MM//\//\\}"; GET_PATH_WIN32="${MM}";
      GET_PATH_LINUX=""; MM=$(realpath "${GET_PATH}"); MM="${MM/C:/${DISK_ROOT}}";     MM="${MM//\\/\/}"; GET_PATH_LINUX="${MM}";
      GIT_CONFIGFILE_LOCAL="${GET_PATH}"; # [ LOCAL ] git config filepath

      # SSH_KEY=$(find "${HOME}/.ssh/" -iname *".pem" -type f -printf "%f\n");
      # echo "";
      # echo "${SSH_KEY}";

      # Strings
      KEY="user.name";       VAL="${COMMIT_NAME}";                        git config --local --replace-all "${KEY}" "${VAL}";
      KEY="user.email";      VAL="${COMMIT_EMAIL}";                       git config --local --replace-all "${KEY}" "${VAL}";
      KEY="core.sshcommand"; VAL="ssh -4 -i '${SSH_KEY}'${GIT_SSH_OPTS}";  git config --local --replace-all "${KEY}" "${VAL}";
      # Strings - Formatting (Line-Endings/Syntax-Highlighting)
      KEY="core.autocrlf";   VAL=$(test "${REPO}" == *"infrastructure" && echo "false" || echo "input";);   git config --local --replace-all  "${KEY}" "${VAL}";
      KEY="core.eol";        VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
      KEY="color.ui";        VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
      if [ -z "${GPG_KEY_ID}" ]; then
        echo "No GPG Key was assigned for repo \"${REPOS_DIR}/${REPO}\"";
      else
        # Strings (GPG)
        KEY="gpg.program";      VAL="${GPG4WIN_GPG_EXE_WIN32}";           git config --local --replace-all "${KEY}" "${VAL}";
        KEY="user.signingkey";  VAL="${GPG_KEY_ID}";                      git config --local --replace-all "${KEY}" "${VAL}";
        # Booleans
        KEY="commit.gpgsign";   VAL="true";                               git config --local --replace-all --bool "${KEY}" "${VAL}";
        # Unsets
        KEY="push.gpgsign";                                               git config --local --unset "${KEY}";
      fi;
      if [ "${SHOW_GIT_CONFIG_OUTPUTS}" -gt "1" ]; then
        echo "------------------------------------------------------------";
        echo "$(git config --local --list --show-origin)";
        echo "------------------------------------------------------------";
      fi;

      echo "Updated:  ${EACH_REPO_NAME}   (config-file @ \"${GIT_CONFIGFILE_LOCAL}\")";

      # for EACH_KEY in "${!ARR_CONTAINER_IDS[@]}"; do
      #   EACH_CONTAINER_ID="${ARR_CONTAINER_IDS[${EACH_KEY}]}";
      #   EACH_DOCKER_IMAGE="${ARR_DOCKER_IMAGES[${EACH_KEY}]}";
      #   echo "        ${EACH_KEY} -  ${EACH_DOCKER_IMAGE}  (${EACH_CONTAINER_ID})";
      # done;

      # EACH_REPO_BASENAME

      # for EACH_EXCLUDED_DIR in "${!EXCLUDED_HOMEDIRS[@]}"; do
      #   if [ "${EACH_HOMEDIR}" == "${EACH_EXCLUDED_DIR}" ]; then
      #     DIR_IS_EXCLUDED=1;
      #   fi;
      # done;

      # ${GIT_SYNC_REPOS_ID1}
      # ${GIT_SYNC_REPOS_ID2}
      # ${GIT_SYNC_GPG_KEYS}
      # ${GIT_SYNC_FULLNAMES}

    fi;

  done;
  
echo "";

exit 0;

# fi;


# # ------------------------------------------------------------
# #   GIT REPOS
# #    |--> PERSONAL, PUBLIC
# #
# PERSONAL_PUBLIC_REPOS_NO_DUPES=($(echo "${PERSONAL_PUBLIC_REPOS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '));
# for REPO in "${PERSONAL_PUBLIC_REPOS_NO_DUPES[@]}"; do
#   if [ -d "${REPOS_DIR}/${REPO}" ]; then
#     cd "${REPOS_DIR}/${REPO}";
#     GET_PATH=$(git config --local --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
#     GET_PATH="${GET_PATH/C:/${DISK_ROOT}}"; GET_PATH="${GET_PATH//\\/\/}"; GET_PATH=$(realpath "${GET_PATH}");
#     GIT_CONFIGFILE_LOCAL="${GET_PATH}"; # [ LOCAL ] git config filepath
#     echo "Updated:  ${REPO}   (\"${GIT_CONFIGFILE_LOCAL}\")";
#     # Strings
#     KEY="user.name";       VAL="${COMMIT_NAME}";                        git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="user.email";      VAL="${COMMIT_EMAIL}";                       git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="core.sshcommand"; VAL="ssh -4 -i '${SSH_KEY}'${GIT_SSH_OPTS}"     git config --local --replace-all "${KEY}" "${VAL}";
#     # Strings - Formatting (Line-Endings/Syntax-Highlighting)
#     KEY="core.autocrlf";   VAL=$(test "${REPO}" == *"infrastructure" && echo "false" || echo "input";);   git config --local --replace-all  "${KEY}" "${VAL}";
#     KEY="core.eol";        VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="color.ui";        VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
#     if [ -z "${GPG_KEY_ID}" ]; then
#       echo "No GPG Key was assigned for repo \"${REPOS_DIR}/${REPO}\"";
#     else
#       # Strings (GPG)
#       KEY="gpg.program";      VAL="${GPG4WIN_GPG_EXE_WIN32}";           git config --local --replace-all "${KEY}" "${VAL}";
#       KEY="user.signingkey";  VAL="${GPG_KEY_ID}";                      git config --local --replace-all "${KEY}" "${VAL}";
#       # Booleans
#       KEY="commit.gpgsign";   VAL="true";                               git config --local --replace-all --bool "${KEY}" "${VAL}";
#       # Unsets
#       KEY="push.gpgsign";                                               git config --local --unset "${KEY}";
#     fi;
#     if [ "${SHOW_GIT_CONFIG_OUTPUTS}" -gt "1" ]; then
#       echo "------------------------------------------------------------";
#       echo "$(git config --local --list --show-origin)";
#       echo "------------------------------------------------------------";
#     fi;
#   fi;
# done;


# # ------------------------------------------------------------
# #   GIT REPOS
# #    |--> PERSONAL, PRIVATE
# #
# if [ -f "${GIT_SSH_PERSONAL}" ]; then
#   PERSONAL_PRIVATE_REPOS_NO_DUPES=($(echo "${PERSONAL_PRIVATE_REPOS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '));
#   for REPO in "${PERSONAL_PRIVATE_REPOS_NO_DUPES[@]}"; do
#     if [ -d "${REPOS_DIR}/${REPO}" ]; then
#       cd "${REPOS_DIR}/${REPO}";
#       GET_PATH=$(git config --local --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
#       GET_PATH="${GET_PATH/C:/${DISK_ROOT}}"; GET_PATH="${GET_PATH//\\/\/}"; GET_PATH=$(realpath "${GET_PATH}");
#       GIT_CONFIGFILE_LOCAL="${GET_PATH}"; # [ LOCAL ] git config filepath
#       echo "Updated:  ${REPO}   (\"${GIT_CONFIGFILE_LOCAL}\")";
#       # Strings
#       KEY="user.name";       VAL="${COMMIT_NAME}";                        git config --local --replace-all "${KEY}" "${VAL}";
#       KEY="user.email";      VAL="${COMMIT_EMAIL}";                       git config --local --replace-all "${KEY}" "${VAL}";
#       KEY="core.sshcommand"; VAL="ssh -4 -i '${SSH_KEY}'${GIT_SSH_OPTS}"     git config --local --replace-all "${KEY}" "${VAL}";
#       # Strings - Formatting (Line-Endings/Syntax-Highlighting)
#       KEY="core.autocrlf";   VAL=$(test "${REPO}" == *"infrastructure" && echo "false" || echo "input";);   git config --local --replace-all  "${KEY}" "${VAL}";
#       KEY="core.eol";        VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
#       KEY="color.ui";        VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
#       if [ -z "${GPG_KEY_ID}" ]; then
#         echo "No GPG Key was assigned for repo \"${REPOS_DIR}/${REPO}\"";
#       else
#         # Strings (GPG)
#         KEY="gpg.program";      VAL="${GPG4WIN_GPG_EXE_WIN32}";           git config --local --replace-all "${KEY}" "${VAL}";
#         KEY="user.signingkey";  VAL="${GPG_KEY_ID}";                      git config --local --replace-all "${KEY}" "${VAL}";
#         # Booleans
#         KEY="commit.gpgsign";   VAL="true";                               git config --local --replace-all --bool "${KEY}" "${VAL}";
#         # Unsets
#         KEY="push.gpgsign";                                               git config --local --unset "${KEY}";
#       fi;
#       if [ "${SHOW_GIT_CONFIG_OUTPUTS}" -gt "1" ]; then
#         echo "------------------------------------------------------------";
#         echo "$(git config --local --list --show-origin)";
#         echo "$(git config --local --list --show-origin)";
#         echo "------------------------------------------------------------";
#       fi;
#     fi;
#   done;
# fi;


# # ------------------------------------------------------------
# # Repositories  :::  Work
# # ------------------------------------------------------------
# GPG_KEY_ID="";
# if [ -f "${GIT_SSH_WORK}" ]; then
#   COMMIT_NAME="${COMMIT_NAME_WORK}";
#   COMMIT_EMAIL="${GIT_EMAIL_WORK}"; # Email
#   SSH_KEY="${GIT_SSH_WORK}"; # SSH-Key
#   if [ -n "${GPG_KEY_ID_WORK}" ]; then
#     GPG_KEY_ID="${GPG_KEY_ID_WORK}"; # GPG-Key
#   fi;
# else
#   echo "";
#   echo "Error: No SSH-Key(s) found for work git-repos";
#   sleep 60;
#   exit 1;
# fi;


# # ------------------------------------------------------------
# #   GIT REPOS
# #    |--> WORK, PUBLIC
# #
# WORK_PUBLIC_REPOS_NO_DUPES=($(echo "${WORK_PUBLIC_REPOS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '));
# for REPO in "${WORK_PUBLIC_REPOS_NO_DUPES[@]}"; do
#   if [ -d "${REPOS_DIR}/${REPO}" ]; then
#     cd "${REPOS_DIR}/${REPO}";
#     GET_PATH=$(git config --local --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
#     GET_PATH="${GET_PATH/C:/${DISK_ROOT}}"; GET_PATH="${GET_PATH//\\/\/}"; GET_PATH=$(realpath "${GET_PATH}");
#     GIT_CONFIGFILE_LOCAL="${GET_PATH}"; # [ LOCAL ] git config filepath
#     echo "Updated:  ${REPO}   (\"${GIT_CONFIGFILE_LOCAL}\")";
#     # Strings
#     KEY="user.name";       VAL="${COMMIT_NAME}";                        git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="user.email";      VAL="${COMMIT_EMAIL}";                       git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="core.sshcommand"; VAL="ssh -4 -i '${SSH_KEY}'${GIT_SSH_OPTS}"     git config --local --replace-all "${KEY}" "${VAL}";
#     # Strings - Formatting (Line-Endings/Syntax-Highlighting)
#     KEY="core.autocrlf";   VAL=$(test "${REPO}" == *"infrastructure" && echo "false" || echo "input";);   git config --local --replace-all  "${KEY}" "${VAL}";
#     KEY="core.eol";        VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="color.ui";        VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
#     if [ -z "${GPG_KEY_ID}" ]; then
#       echo "No GPG Key was assigned for repo \"${REPOS_DIR}/${REPO}\"";
#     else
#       # Strings (GPG)
#       KEY="gpg.program";      VAL="${GPG4WIN_GPG_EXE_WIN32}";           git config --local --replace-all "${KEY}" "${VAL}";
#       KEY="user.signingkey";  VAL="${GPG_KEY_ID}";                      git config --local --replace-all "${KEY}" "${VAL}";
#       # Booleans
#       KEY="commit.gpgsign";   VAL="true";                               git config --local --replace-all --bool "${KEY}" "${VAL}";
#       # Unsets
#       KEY="push.gpgsign";                                               git config --local --unset "${KEY}";
#     fi;
#     if [ "${SHOW_GIT_CONFIG_OUTPUTS}" -gt "1" ]; then
#       echo "------------------------------------------------------------";
#       echo "$(git config --local --list --show-origin)";
#       echo "------------------------------------------------------------";
#     fi;
#   fi;
# done;


# # ------------------------------------------------------------
# #   GIT REPOS
# #    |--> WORK, PRIVATE
# #
# WORK_PRIVATE_REPOS_NO_DUPES=($(echo "${WORK_PRIVATE_REPOS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '));
# for REPO in "${WORK_PRIVATE_REPOS_NO_DUPES[@]}"; do
#   if [ -d "${REPOS_DIR}/${REPO}" ]; then
#     cd "${REPOS_DIR}/${REPO}";
#     GET_PATH=$(git config --local --list --show-origin | head -n 1 | sed --regexp-extended --quiet --expression='s/^file\:(.+)\s+(.+)=(.+)$/\1/p');
#     GET_PATH="${GET_PATH/C:/${DISK_ROOT}}"; GET_PATH="${GET_PATH//\\/\/}"; GET_PATH=$(realpath "${GET_PATH}");
#     GIT_CONFIGFILE_LOCAL="${GET_PATH}"; # [ LOCAL ] git config filepath
#     echo "Updated:  ${REPO}   (\"${GIT_CONFIGFILE_LOCAL}\")";
#     # Strings
#     KEY="user.name";       VAL="${COMMIT_NAME}";                        git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="user.email";      VAL="${COMMIT_EMAIL}";                       git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="core.sshcommand"; VAL="ssh -4 -i '${SSH_KEY}'${GIT_SSH_OPTS}"     git config --local --replace-all "${KEY}" "${VAL}";
#     # Strings - Formatting (Line-Endings/Syntax-Highlighting)
#     KEY="core.autocrlf";   VAL=$(test "${REPO}" == *"infrastructure" && echo "false" || echo "input";);   git config --local --replace-all  "${KEY}" "${VAL}";
#     KEY="core.eol";        VAL="lf";     git config --local --replace-all "${KEY}" "${VAL}";
#     KEY="color.ui";        VAL="auto";   git config --local --replace-all "${KEY}" "${VAL}";
#     if [ -z "${GPG_KEY_ID}" ]; then
#       echo "No GPG Key was assigned for repo \"${REPOS_DIR}/${REPO}\"";
#     else
#       # Strings (GPG)
#       KEY="gpg.program";      VAL="${GPG4WIN_GPG_EXE_WIN32}";           git config --local --replace-all "${KEY}" "${VAL}";
#       KEY="user.signingkey";  VAL="${GPG_KEY_ID}";                      git config --local --replace-all "${KEY}" "${VAL}";
#       # Booleans
#       KEY="commit.gpgsign";   VAL="true";                               git config --local --replace-all --bool "${KEY}" "${VAL}";
#       # Unsets
#       KEY="push.gpgsign";                                               git config --local --unset "${KEY}";
#     fi;
#     if [ "${SHOW_GIT_CONFIG_OUTPUTS}" -gt "1" ]; then
#       echo "------------------------------------------------------------";
#       echo "$(git config --local --list --show-origin)";
#       echo "------------------------------------------------------------";
#     fi;
#   fi;
# done;


# # ------------------------------------------------------------

# if [ -f "${GIT_CONF_GLOBAL_PATHS_LINUX}" ]; then
#   rm -f "${GIT_CONF_GLOBAL_PATHS_LINUX}";
# fi;
# GIT_CONF_GLOBAL_PATHS_LINUX="";
# GIT_CONF_GLOBAL_PATHS_WIN32="";

# if [ -f "${GIT_CONF_SYSTEM_PATHS_LINUX}" ]; then
#   rm -f "${GIT_CONF_SYSTEM_PATHS_LINUX}";
# fi;
# GIT_CONF_SYSTEM_PATHS_LINUX="";
# GIT_CONF_SYSTEM_PATHS_WIN32="";


# ------------------------------------------------------------
#
# Citation(s)
#
#   docs.microsoft.com  |  "OpenSSH Server Configuration for Windows | Microsoft Docs"  |  https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_server_configuration#:~:text=In%20Windows%2C%20sshd%20reads%20configuration,exe%20with%20the%20%2Df%20parameter.
#
#   docs.microsoft.com  |  "reg query - Returns a list of the next tier of subkeys and entries that are located under a specified subkey in the registry."  |  https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg-query
#
#   github.com  |  "Signing Git commit with GPG ask passphrase everytime"  |  https://github.com/fish-shell/fish-shell/issues/4665#issuecomment-359020584
#
#   gist.github.com  |  "How to enable auto-signing Git commits with GnuPG ..."  |  https://gist.github.com/BoGnY/f9b1be6393234537c3e247f33e74094a
#
#   joshfrankel.me  |  "Signing commits for Github and Sublime Merge"  |  https://joshfrankel.me/blog/signing-commits-for-github-and-sublime-merge
#
#   riseup.net  |  "OpenPGP Best Practices"  |  https://riseup.net/en/security/message-security/openpgp/best-practices
#
#   riseup.net  |  "Managing OpenPGP Keys"  |  https://riseup.net/en/security/message-security/openpgp/gpg-keys
#
#   superuser.com  |  "Where is my gpgconf file on Windows?"  |  https://superuser.com/questions/1068980
#
#   superuser.com  |  "How to prevent gpg-agent from timing out during passphrase collection?"  |  https://superuser.com/questions/1172804
#
#   superuser.com  |  "How to name openssh public and private key pairs?"  |  https://superuser.com/a/1261644
#
#   www.gpg4win.org  |  "Upated Installed - Gpg4win"  |  https://www.gpg4win.org/thanks-for-download.html
#
#   www.gpg4win.org  |  "The Gpg4win Compendium"  |  https://www.gpg4win.org/doc/en/gpg4win-compendium.html
#
#   www.gpg4win.org  |  "22 Files and settings in Gpg4win"  |  https://www.gpg4win.org/doc/en/gpg4win-compendium_28.html
#
# ------------------------------------------------------------