#!/bin/bash
#
# LOCAL_SBIN="/usr/local/sbin/sync_cloud_infrastructure" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------
if [[ 0 -eq 1 ]]; then # RUN THIS SCRIPT REMOTELY:

# Option 1:  Sync basic + utility methods (only)
curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" | bash;

# Option 2 (--all):  Sync basic + utility + optional methods using opt-In methodology (will ask user per-module before installing them)
curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" | bash -s -- --all;

fi;
# ------------------------------
#
# Log all shell output & error output to logfile
#
LOGDIR="${HOME}/sync_cloud_infrastructure_logs"; if [[ -w "/var/log/" ]]; then LOGDIR="/var/log/sync_cloud_infrastructure"; fi;
mkdir -p "${LOGDIR}"; chown $(stat -c '%u:%g' $(dirname ${LOGDIR})) "${LOGDIR}" 2>'/dev/null'; chmod 0770 "${LOGDIR}" 2>'/dev/null';
LOGFILE="${LOGDIR}/$(basename ${LOGDIR})_$(date --utc +'%Y%m%d';)"; touch "${LOGFILE}"; chmod 0660 "${LOGFILE}";
exec > >(tee -a "${LOGFILE}" );
exec 2>&1;
#
# ------------------------------
#
# Instantiate static runtime variables
#

START_SECONDS_NANOSECONDS=$(date +'%s.%N');
START_EPOCHSECONDS=$(echo ${START_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 1);
START_NANOSECONDS=$(echo ${START_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 2 | cut --characters 1-9);
START_MICROSECONDS=$(echo ${START_NANOSECONDS} | cut --characters 1-6);
START_DATETIME="$(date --date=@${START_EPOCHSECONDS} +'%Y-%m-%d %H:%M:%S';)";
START_TIMESTAMP="$(date --date=@${START_EPOCHSECONDS} +'%Y%m%d_%H%M%S';)";

DEFAULT_GIT_SOURCE_REPO_URL="https://github.com/mcavallo-git/cloud-infrastructure.git";
DEFAULT_GIT_SOURCE_BRANCH="master";
SYNC_CI_LOCAL="/usr/local/sbin/sync_cloud_infrastructure";

WAN_TEST_FQDN="${WAN_TEST_FQDN:-www.example.com}";

# ------------------------------
#
# Instantiate dymamic runtime variables
#

LOCAL_CONFIG_DIR_FULLPATH="/etc/$(basename "${SYNC_CI_LOCAL}";)"; # holds configurations (if any) specific to this script

EXIT_CODE=0; # sum of errors from specific required calls - returned as the final exit-code from this script

UPDATE_SELF_REQUIRED=1; # Flag variable which determines if the self-update will run or not

RECURSIVE_CALLBACK_ECHO="";

RECURSIVE_CALLBACK_COMMAND="";

# ------------------------------
#
# Log the starting timestamp for the current runtime
#

echo "------------------------------";
echo "-- Info:  Start of \"$(basename "${SYNC_CI_LOCAL}";)\" runtime at [ ${START_DATETIME}.${START_MICROSECONDS}$(date +'%z';) ]  (ID: ${START_SECONDS_NANOSECONDS})";

# ------------------------------
#
# Script must run as root (or via sudo)
#
if [[ "$(id -un)" != "root" ]]; then
  echo "";
  echo "$(date --utc +'%Y-%m-%dT%H:%M:%S.%NZ';) Error: Script must run as user \"root\" or via \"sudo\" command";
  EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
else

  # ------------------------------
  # Determine if the current shell is running-in/connected-to a tty shell (available to user input)
  TTY_VAR_MATCHES_REQUIRED=5;
  TTY_VARS_MATCHED=0;
  # Check for specific environment variables which are set (and contain a non-empty value) when the current shell is running-in/connected-to a tty shell
  unset TTY_VARS_ARR; declare -a TTY_VARS_ARR; # [Re-]Instantiate bash array
  TTY_VARS_ARR+=("EDITOR");
  TTY_VARS_ARR+=("GCC_COLORS");
  TTY_VARS_ARR+=("LESSCLOSE");
  TTY_VARS_ARR+=("LESSOPEN");
  TTY_VARS_ARR+=("LS_COLORS");
  TTY_VARS_ARR+=("OLDPWD");
  TTY_VARS_ARR+=("PROMPT_COMMAND");
  TTY_VARS_ARR+=("TERM");  # may be set to "dumb" on non-tty (backend-only) shells
  TTY_VARS_ARR+=("USER");
  TTY_VARS_ARR+=("VISUAL");
  TTY_VARS_ARR+=("XDG_DATA_DIRS");
  for EACH_TTY_VAR_NAME in "${TTY_VARS_ARR[@]}"; do
    EACH_TTY_VAR_VALUE="";
    declare -n EACH_TTY_VAR_VALUE="${EACH_TTY_VAR_NAME}" 2>'/dev/null';
    if [[ -n "${EACH_TTY_VAR_VALUE}" ]]; then
      TTY_VARS_MATCHED=$((${TTY_VARS_MATCHED}+1));
    fi;
  done;
  IS_TTY_TERMINAL=$(if [[ ${TTY_VARS_MATCHED} -ge ${TTY_VAR_MATCHES_REQUIRED} ]]; then echo 1; else echo 0; fi;);
  # ------------------------------
  READ_TIMEOUT=$(( 60 * ${IS_TTY_TERMINAL} ));
  SYNC_CONFIRMED=0;
  if [[ -f "${SYNC_CI_LOCAL}" ]]; then
    #
    # The [ sync_cloud_infrastructure ] module DOES already exist (not initial sync)
    #
    echo -e "\nInfo:  Auto-confirming cloud-infrastructure module sync (not initial sync)";
    SYNC_CONFIRMED=1;
  elif [[ "${IS_TTY_TERMINAL}" -eq 0 ]]; then
    #
    # Non-TTY shell (backend request) - Do not require confirmation to sync modules
    #
    echo -e "\nInfo:  Auto-confirming cloud-infrastructure module sync (no TTY detected)";
    SYNC_CONFIRMED=1;
  else
    #
    # TTY shell + [ sync_cloud_infrastructure ] module does NOT yet exist (is initial sync)
    #  |
    #  |--> Request user to verify/confirm the initial sync of cloud infrastructure modules (adheres to 'opt-in' methodologies and not 'opt-out' methodologies)
    #
    echo "";
    REPLY="";
    echo -n "Info:  Perform initial sync of cloud-infrastructure modules?  (press 'y' to confirm)  ";
    read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
    echo "";
    if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
      SYNC_CONFIRMED=1;
      echo "  |--> Confirmed";
    else
      SYNC_CONFIRMED=0;
      echo "  |--> Denied";
    fi;
  fi;

  if [[ "${SYNC_CONFIRMED}" -eq 0 ]]; then
    # Do not sync cloud-infrastructure modules & exit this script with an error code, instead
    EXIT_CODE=1;

  else
    # ------------------------------
    #
    # Script-specific config overrides
    #

    # Create parent directory for script-specific config overrides
    if [[ ! -d "${LOCAL_CONFIG_DIR_FULLPATH}" ]]; then
      mkdir -pv "${LOCAL_CONFIG_DIR_FULLPATH}";
    fi;
    if [[ -d "${LOCAL_CONFIG_DIR_FULLPATH}" ]]; then
      if [[ -n "$(command -v stat 2>'/dev/null';)" ]]; then
        if [[ "$(stat --format '%a' ${LOCAL_CONFIG_DIR_FULLPATH})" != "755" ]]; then
          chmod 755 "${LOCAL_CONFIG_DIR_FULLPATH}";
        fi;
      fi;
    fi;

    # Git Repo URL - Allow overriding default repo URL with local filepath
    OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL="${LOCAL_CONFIG_DIR_FULLPATH}/git_source_repo.url";
    if [[ -f "${OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL}" ]]; then
      OVERRIDE_GIT_SOURCE_REPO_URL="$(cat ${OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL};)"; # Override the git source repo URL
    fi;
    GIT_SOURCE_REPO_URL="${OVERRIDE_GIT_SOURCE_REPO_URL:-${DEFAULT_GIT_SOURCE_REPO_URL}}";


    # ------------------------------
    #
    # Parse inline arguments (passed to current script)
    #

    ARGS=("$@");
    ARGS_COUNT=${#ARGS[@]};

    ARGS_CHECK_WSL=$(if [[ -z "$(uname -r 2>&1 | grep -i 'microsoft' 2>&1;)" ]]; then echo 0; else echo 1; fi;);

    RESTART_SERVICE_CRON=0;
    RESTART_SERVICE_JENKINS=0;
    RESTART_SERVICE_NGINX=0;
    RESTART_SERVICE_SSH=0;
    RESTART_SERVICE_UFW=0;

    # Walk through any inline-arguments passed to this function
    for (( i=0;i<${ARGS_COUNT};i++ )); do

      EACH_ARG=${ARGS[${i}]};

      # Check if this is the last inline-argument or if there are more to follow
      if [[ $((${i}+1)) -eq ${ARGS_COUNT} ]]; then # if this is the last argument
        NEXT_ARG="";
      else
        NEXT_ARG=${ARGS[$((${i}+1))]};
        if [[ "${NEXT_ARG}" == "--"* ]]; then # Do not allow inline-arguments starting with "--..." to use the next bash-argument as an associated value if it, also, starts with "--..."
          NEXT_ARG="";
        fi;
      fi;

      if [[ -n "${EACH_ARG}" ]]; then # Parse each non-empty inline argument

        # Use "--all" inline-arg. to sync all modules
        if [[ "${EACH_ARG}" == "--all" ]]; then
          ARGS_CRONJOB_REMOVE=0; # Do not delete cronjobs since we're going to sync all of them
          ARGS_CRONJOB_SYNC=1;
          # ARGS_DEBUG_MODE=1;
          # ARGS_SYNC_DDNS=1;
          ARGS_SYNC_JENKINS=1;
          ARGS_SYNC_NGINX=1;
          ARGS_SYNC_SSH_CONFIG=1;
          ARGS_SYNC_TIMEZONE=1;
          ARGS_SYNC_UFW=1;
        fi;

        if [[ "${EACH_ARG}" == "--wsl" ]] || [[ "${EACH_ARG}" == "--windows" ]]; then
          ARGS_CHECK_WSL=1; # Parse WSL check calls
        fi;

        if [[ "${EACH_ARG}" == "--remove-cronjobs" ]] || [[ "${EACH_ARG}" == "--remove" ]]; then
          ARGS_CRONJOB_REMOVE=1; # Parse cronjobs removal calls
        fi;

        if [[ "${EACH_ARG}" == "--cron" ]]; then
          if [[ "${NEXT_ARG}" == "remove" ]] && [[ ${ARGS_CRONJOB_SYNC} -eq 0 ]]; then
            ARGS_CRONJOB_REMOVE=1; # Parse cronjob removal calls
          elif [[ "${NEXT_ARG}" == "sync" ]] && [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
            ARGS_CRONJOB_SYNC=1; # Parse cronjob sync calls
          else
            # Error - Invalid argument syntax (but also show user an example of valid argument syntax)
            echo "Error:  Invalid inline argument:  ${EACH_ARG} ${NEXT_ARG}";
            echo "                        |";
            echo "                        |--> Sync cron-job(s) via '--cron sync' argument";
            echo "                        |--> Remove synced cron-job(s) via '--cron remove' argument";
            echo "";
            EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          fi;
        fi;

        if [[ "${EACH_ARG}" == "--debug" ]] || [[ "${EACH_ARG}" == "--verbose" ]]; then
          ARGS_DEBUG_MODE=1; # Parse debug/verbose calls
        fi;

        if [[ "${EACH_ARG}" == "--git-branch" ]]; then
          if [[ -n "${NEXT_ARG}" ]]; then
            ARGS_GIT_BRANCH="${NEXT_ARG}"; # Parse git repo branch calls
          else
            # Error - Invalid argument syntax (but also show user an example of valid argument syntax)
            echo "Error:  Invalid inline argument:  ${EACH_ARG} ${NEXT_ARG}";
            echo "                        |";
            echo "                        |--> Change repository branch via '--git-branch BRANCH_NAME_HERE' argument";
            echo "";
            EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          fi;
        fi;

        if [[ "${EACH_ARG}" == "--force-self-update" ]]; then
          ARGS_FORCE_SELF_UPDATE=1; # Parse force-self-update calls
        fi;

        if [[ "${EACH_ARG}" == "--skip-self-update" ]]; then
          ARGS_SKIP_SELF_UPDATE=1; # Parse skip-self-update calls
        fi;

        if [[ "${EACH_ARG}" == "--ddns" ]]; then
          ARGS_SYNC_DDNS=1; # Parse DDNS sync Calls
        fi;

        if [[ "${EACH_ARG}" == "--jenkins" ]]; then
          ARGS_SYNC_JENKINS=1; # Parse Jenkins sync calls
        fi;

        if [[ "${EACH_ARG}" == "--nginx" ]]; then
          ARGS_SYNC_NGINX=1; # Parse NGINX sync calls
        fi;

        if [[ "${EACH_ARG}" == "--ssh" ]] || [[ "${EACH_ARG}" == "--sshd" ]]; then
          ARGS_SYNC_SSH_CONFIG=1; # Parse SSH config calls
        fi;

        if [[ "${EACH_ARG}" == "-z" ]] || [[ "${EACH_ARG}" == "--timezone" ]]; then
          ARGS_SYNC_TIMEZONE=1; # Parse Timezone config calls
        fi;

        if [[ "${EACH_ARG}" == "--ufw" ]]; then
          ARGS_SYNC_UFW=1; # Parse UFW sync calls
        fi;

      fi;

    done;

    # Integer arguments
    ARGS_CHECK_WSL=${ARGS_CHECK_WSL:-0};                  # Parsed from $@
    ARGS_CRONJOB_REMOVE=${ARGS_CRONJOB_REMOVE:-0};        # Parsed from $@
    ARGS_CRONJOB_SYNC=${ARGS_CRONJOB_SYNC:-0};            # Parsed from $@
    ARGS_DEBUG_MODE=${ARGS_DEBUG_MODE:-0};                # Parsed from $@
    ARGS_FORCE_SELF_UPDATE=${ARGS_FORCE_SELF_UPDATE:-0};  # Parsed from $@
    ARGS_SKIP_SELF_UPDATE=${ARGS_SKIP_SELF_UPDATE:-0};    # Parsed from $@
    ARGS_SYNC_DDNS=${ARGS_SYNC_DDNS:-0};                  # Parsed from $@
    ARGS_SYNC_JENKINS=${ARGS_SYNC_JENKINS:-0};            # Parsed from $@
    ARGS_SYNC_NGINX=${ARGS_SYNC_NGINX:-0};                # Parsed from $@
    ARGS_SYNC_SSH_CONFIG=${ARGS_SYNC_SSH_CONFIG:-0};      # Parsed from $@
    ARGS_SYNC_TIMEZONE=${ARGS_SYNC_TIMEZONE:-0};          # Parsed from $@
    ARGS_SYNC_UFW=${ARGS_SYNC_UFW:-0};                    # Parsed from $@

    # String arguments
    ARGS_GIT_BRANCH=${ARGS_GIT_BRANCH};               # Parsed from $@

    # ------------------------------

    WIN32_HOMEDIR="";

    DIR_REPO_BASE="";

    GIT_REPO_OWNER="$(basename $(dirname ${GIT_SOURCE_REPO_URL};);)";

    GIT_REPO_NAME="$(basename ${GIT_SOURCE_REPO_URL} | cut -d. -f1;)";

    GIT_LOCAL_PARENT_PATH="${HOME}/Documents/GitHub";

    GIT_LOCAL_REPO_PATH="${GIT_LOCAL_PARENT_PATH}/${GIT_REPO_NAME}/";

    GIT_SOURCE_BRANCH="${ARGS_GIT_BRANCH:-${DEFAULT_GIT_SOURCE_BRANCH}}";

    SYNC_CI_REMOTE="https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${SYNC_CI_LOCAL}?t=${START_SECONDS_NANOSECONDS}";

    # ------------------------------
    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
      echo "";
      echo "Debug:  ARGS = [ ${ARGS[@]} ]";
      echo "Debug:  ARGS_COUNT = [ ${ARGS_COUNT} ]";
      echo "";
      echo "Debug:  ARGS_CHECK_WSL = [ ${ARGS_CHECK_WSL} ]";
      echo "Debug:  ARGS_CRONJOB_REMOVE = [ ${ARGS_CRONJOB_REMOVE} ]";
      echo "Debug:  ARGS_CRONJOB_SYNC = [ ${ARGS_CRONJOB_SYNC} ]";
      echo "Debug:  ARGS_DEBUG_MODE = [ ${ARGS_DEBUG_MODE} ]";
      echo "Debug:  ARGS_GIT_BRANCH = [ ${ARGS_GIT_BRANCH} ]";
      echo "Debug:  ARGS_FORCE_SELF_UPDATE = [ ${ARGS_FORCE_SELF_UPDATE} ]";
      echo "Debug:  ARGS_SKIP_SELF_UPDATE = [ ${ARGS_SKIP_SELF_UPDATE} ]";
      echo "Debug:  ARGS_SYNC_DDNS = [ ${ARGS_SYNC_DDNS} ]";
      echo "Debug:  ARGS_SYNC_JENKINS = [ ${ARGS_SYNC_JENKINS} ]";
      echo "Debug:  ARGS_SYNC_NGINX = [ ${ARGS_SYNC_NGINX} ]";
      echo "Debug:  ARGS_SYNC_SSH_CONFIG = [ ${ARGS_SYNC_SSH_CONFIG} ]";
      echo "Debug:  ARGS_SYNC_TIMEZONE = [ ${ARGS_SYNC_TIMEZONE} ]";
      echo "Debug:  ARGS_SYNC_UFW = [ ${ARGS_SYNC_UFW} ]";
      echo "";
      echo "Debug:  GIT_LOCAL_PARENT_PATH = [ ${GIT_LOCAL_PARENT_PATH} ]";
      echo "Debug:  GIT_LOCAL_REPO_PATH = [ ${GIT_LOCAL_REPO_PATH} ]";
      echo "Debug:  GIT_REPO_NAME = [ ${GIT_REPO_NAME} ]";
      echo "Debug:  GIT_REPO_OWNER = [ ${GIT_REPO_OWNER} ]";
      echo "";
      echo "Debug:  GIT_SOURCE_BRANCH = [ ${GIT_SOURCE_BRANCH} ]";
      echo "Debug:  DEFAULT_GIT_SOURCE_BRANCH = [ ${DEFAULT_GIT_SOURCE_BRANCH} ]";
      echo "";
      echo "Debug:  GIT_SOURCE_REPO_URL = [ ${GIT_SOURCE_REPO_URL} ]";
      echo "Debug:  DEFAULT_GIT_SOURCE_REPO_URL = [ ${DEFAULT_GIT_SOURCE_REPO_URL} ]";
      echo "";
      echo "Debug:  IS_TTY_TERMINAL = [ ${IS_TTY_TERMINAL} ]";
      echo "Debug:  READ_TIMEOUT = [ ${READ_TIMEOUT} ]";
      echo "";
      echo "Debug:  LOCAL_CONFIG_DIR_FULLPATH = [ ${LOCAL_CONFIG_DIR_FULLPATH} ]";
      echo "Debug:  SYNC_CI_LOCAL = [ ${SYNC_CI_LOCAL} ]";
      echo "Debug:  SYNC_CI_REMOTE = [ ${SYNC_CI_REMOTE} ]";
      echo "";
      echo "Debug:  LOGDIR = [ ${LOGDIR} ]";
      echo "Debug:  LOGFILE = [ ${LOGFILE} ]";
      echo "";
      echo "Debug:  OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL = [ ${OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL} ]";
      echo "Debug:  OVERRIDE_GIT_SOURCE_REPO_URL = [ ${OVERRIDE_GIT_SOURCE_REPO_URL} ]";
      echo "";
      echo "Debug:  START_SECONDS_NANOSECONDS = [ ${START_SECONDS_NANOSECONDS} ]";
      echo "Debug:  START_EPOCHSECONDS = [ ${START_EPOCHSECONDS} ]";
      echo "Debug:  START_DATETIME = [ ${START_DATETIME} ]";
      echo "Debug:  START_TIMESTAMP = [ ${START_TIMESTAMP} ]";
    fi;
    # ------------------------------
    #
    # Check for a valid WAN (internet) connection
    #
    echo -e "\nInfo:  Checking internet connectivity...";
    BENCHMARK_START=$(date +'%s.%N');
    WAN_TEST_CURL_RESPONSE=$(curl -sLI "${WAN_TEST_FQDN}";);
    WAN_TEST_CURL_FAILED=${?};
    WAN_TEST_HTTP_CODE=$(echo "${WAN_TEST_CURL_RESPONSE}" | grep '^HTTP' | tail -n 1 | cut -d' ' -f2;);
    WAN_TEST_FAILED=$(if [[ ${WAN_TEST_CURL_FAILED} -eq 0 ]] && [[ ${WAN_TEST_HTTP_CODE} -ge 200 ]] && [[ ${WAN_TEST_HTTP_CODE} -le 400 ]]; then echo 0; else echo 1; fi;);
    if [[ "${WAN_TEST_FAILED}" == "1" ]]; then
      echo "";
      echo "! |--> Error:  WAN network (internet) connection is required to sync cloud-infrastructure modules, but is unable to be verified";
      EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
    elif [[ -z "${GIT_REPO_NAME}" ]]; then
      echo "";
      echo "! |--> Error:  Required variable empty/unset:  \${GIT_REPO_NAME}";
      EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
    elif [[ -z "${GIT_REPO_OWNER}" ]]; then
      echo "";
      echo "! |--> Error:  Required variable empty/unset:  \${GIT_REPO_OWNER}";
      EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
    else
      if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Verified WAN (internet) network connection"; fi;
    fi;
    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
      #
      # Handle benchmarking differently (e.g. more 'compatibly') before we've ensured that the command 'bc' has been installed
      #
      if [[ -n "$(command -v bc 2>'/dev/null';)" ]]; then
        BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l;);
      else
        BENCHMARK_DELTA=$(perl -le "print($(date +'%s.%N') - ${BENCHMARK_START})");
      fi;
      echo "  |--> Finished after ${BENCHMARK_DELTA}s";
    fi;
    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
      echo "";
      echo "Debug:  WAN_TEST_FQDN = [ ${WAN_TEST_FQDN} ]";
      echo "Debug:  WAN_TEST_CURL_FAILED = [ ${WAN_TEST_CURL_FAILED} ]";
      echo "Debug:  WAN_TEST_FAILED = [ ${WAN_TEST_FAILED} ]";
      echo "Debug:  WAN_TEST_HTTP_CODE = [ ${WAN_TEST_HTTP_CODE} ]";
    fi;
    # ------------------------------
    #
    # If no errors are found up-until this point, continue
    #
    if [[ -z "${EXIT_CODE}" ]] || [[ "${EXIT_CODE}" == "0" ]]; then
      # ------------------------------
      #
      # Packages / Prereqs  -  Make sure prerequisite-packages are installed
      #
      echo -e "\nInfo:  Checking for required/prerequite packages...";
      BENCHMARK_START=$(date +'%s.%N');
      unset REQUIRED_PKGS_ARRAY; declare -a REQUIRED_PKGS_ARRAY; # [Re-]Instantiate bash array
      unset MISSING_PKGS_ARRAY; declare -a MISSING_PKGS_ARRAY; # [Re-]Instantiate bash array
      unset FAILED_INSTALL_PKGS_ARRAY; declare -a FAILED_INSTALL_PKGS_ARRAY; # [Re-]Instantiate bash array
      unset NEWLY_INSTALLED_PKGS_ARRAY; declare -a NEWLY_INSTALLED_PKGS_ARRAY; # [Re-]Instantiate bash array
      REQUIRED_PKGS_ARRAY=();
      REQUIRED_PKGS_ARRAY+=("bc");
      REQUIRED_PKGS_ARRAY+=("dos2unix");
      REQUIRED_PKGS_ARRAY+=("git");
      REQUIRED_PKGS_ARRAY+=("lsof");
      REQUIRED_PKGS_ARRAY+=("rsync");
      REQUIRED_PKGS_ARRAY+=("vim-common");
      REQUIRED_PKGS_ARRAY+=("wget");
      # Debian-specific packages
      if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then  # Distros: Debian, Ubuntu, etc.
        REQUIRED_PKGS_ARRAY+=("cron");
        REQUIRED_PKGS_ARRAY+=("jq");
        # REQUIRED_PKGS_ARRAY+=("sslscan");
      elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then  # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
        REQUIRED_PKGS_ARRAY+=("bind-utils");
        REQUIRED_PKGS_ARRAY+=("epel-release");
        REQUIRED_PKGS_ARRAY+=("policycoreutils-devel");
        # Install the "jq" (JSON Parser) package manually for RHEL distros
        if [[ ! -f "/usr/bin/jq" ]] || [[ -f "/usr/bin/jq" && $(stat --printf="%s" "/usr/bin/jq";) -le 1000 ]]; then # stat command is for hotfix on invalid downloads
          curl -o "/usr/bin/jq" -sL "https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" && chmod 0755 "/usr/bin/jq";
        fi;
      fi;

      # Determine if any required packages are missing
      for EACH_REQUIRED_PKG in "${REQUIRED_PKGS_ARRAY[@]}"; do
        if [[ -n "${EACH_REQUIRED_PKG}" ]]; then
          if [[ -n "$(command -v dpkg 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
            # Query Debian's Package-Manager for each package
            if [[ $(dpkg -L "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo ${?};) -ne 0 ]]; then
              MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Package missing:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            else
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Package already installed:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            fi;
          elif [[ -n "$(command -v rpm 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
            # Query RHEL's Package-Manager for each package
            if [[ $(rpm --quiet --query "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo ${?};) -ne 0 ]]; then
              MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Package missing:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            else
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Package already installed:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            fi;
          else # Other distros
            if [[ -z "$(command -v ${EACH_REQUIRED_PKG} 2>'/dev/null';)" ]]; then
              MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Package missing:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            else
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Package already installed:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            fi;
          fi;
        fi;
      done;
      # ------------------------------
      #
      # Install missing packages
      #
      if [[ ${#MISSING_PKGS_ARRAY[@]} -ne 0 ]]; then
        if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then
          if [[ 1 -eq 1 ]]; then
            #
            # Debian distros (Ubuntu, Raspbian, etc.)
            #  |--> Individually install missing packages (to avoid errors from single-packages from taking-out the entire bulk-install attempt)
            #
            echo -e "\nInfo:  Calling [ apt-get update -y; ]...";
            apt-get -y update;
            for EACH_MISSING_PKG in "${MISSING_PKGS_ARRAY[@]}"; do
              echo -e "\nInfo:  Calling [ apt-get -y install ${EACH_MISSING_PKG}; ]...";
              apt-get -y install ${EACH_MISSING_PKG};
            done;
          else
            #
            # Debian distros (Ubuntu, Raspbian, etc.)
            #  |--> Bulk install missing packages
            #
            echo -e "\nInfo:  Calling [ apt-get -y update; apt-get -y install ${MISSING_PKGS_ARRAY[@]}; ]...";
            apt-get -y update; apt-get -y install ${MISSING_PKGS_ARRAY[@]};
          fi;
        elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then
          #
          # RHEL, CentOS distros
          #  |--> Bulk install missing packages
          #
          echo -e "\nInfo:  Calling [ yum check-update -y; yum -y install ${MISSING_PKGS_ARRAY[@]}; ]...";
          yum check-update -y; yum -y install ${MISSING_PKGS_ARRAY[@]};
        elif [[ -n "$(command -v apk 2>'/dev/null';)" ]]; then
          #
          # Alpine distros
          #  |--> Bulk install missing packages
          #
          echo -e "\nInfo:  Calling [ apk update -y; apk add -y ${MISSING_PKGS_ARRAY[@]}; ]...";
          apk update -y; apk add -y ${MISSING_PKGS_ARRAY[@]};
        fi;
        # ------------------------------
        #
        # Verify all required packages are installed as-intended
        #
        for EACH_REQUIRED_PKG in "${REQUIRED_PKGS_ARRAY[@]}"; do
          if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
            # Query Debian's Package-Manager for each package
            if [[ $(dpkg -L "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo ${?};) -ne 0 ]]; then
              # Package install failed
              FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              echo -e "! |--> Error:  Failed to install package:  [ ${EACH_REQUIRED_PKG} ]";
            else
              # Package install success
              NEWLY_INSTALLED_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Successfully installed package:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            fi;
          elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
            # Query RHEL's Package-Manager for each package
            if [[ $(rpm --quiet --query "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo ${?};) -ne 0 ]]; then
              # Package install failed
              FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              echo -e "! |--> Error:  Failed to install package:  [ ${EACH_REQUIRED_PKG} ]";
            else
              # Package install success
              NEWLY_INSTALLED_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Successfully installed package:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            fi;
          else # Other distros
            if [[ -z "$(command -v ${EACH_REQUIRED_PKG} 2>'/dev/null';)" ]]; then
              # Package install failed
              FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              echo -e "! |--> Error:  Failed to install package:  [ ${EACH_REQUIRED_PKG} ]";
            else
              # Package install success
              NEWLY_INSTALLED_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Successfully installed package:  [ ${EACH_REQUIRED_PKG} ]"; fi;
            fi;
          fi;
        done;
      fi;
      if [[ ${#FAILED_INSTALL_PKGS_ARRAY[@]} -ne 0 ]]; then
        #
        # At least one package is missing & failed to install
        #
        EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
      fi;
      if [[ ${#FAILED_INSTALL_PKGS_ARRAY[@]} -eq 0 ]] && [[ ${#NEWLY_INSTALLED_PKGS_ARRAY[@]} -eq 0 ]]; then
        #
        # No package changes were made
        #
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> No package changes made (all required/prerequite packages are installed locally)"; fi;
      fi;
      if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
      if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
        echo "";
        echo "Debug:  REQUIRED_PKGS_ARRAY[@] = [ ${REQUIRED_PKGS_ARRAY[@]} ]";
        echo "Debug:  MISSING_PKGS_ARRAY[@] = [ ${MISSING_PKGS_ARRAY[@]} ]";
        echo "Debug:  FAILED_INSTALL_PKGS_ARRAY[@] = [ ${FAILED_INSTALL_PKGS_ARRAY[@]} ]";
        echo "Debug:  NEWLY_INSTALLED_PKGS_ARRAY[@] = [ ${NEWLY_INSTALLED_PKGS_ARRAY[@]} ]";
      fi;
      # ------------------------------
      #
      # Self-update - If changes exist between the local & the remote (source) runtime versions of this script, then update it and recursively call it
      #
      if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then
        UPDATE_SELF_REQUIRED=0;
        echo -e "\nInfo:  Self-update skipped (script called with '--skip-self-update')";
      else
        CHECKSUM_LOCAL=$(if [[ -f "${SYNC_CI_LOCAL}" ]]; then cat "${SYNC_CI_LOCAL}" | sed -e '/^\s*$/d' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | cksum | cut -d" " -f1; else echo 0; fi;); # remove commented & whitespace-only lines from script
        CHECKSUM_REMOTE=$(curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "${SYNC_CI_REMOTE}" | sed -e '/^\s*$/d' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | cksum | cut -d" " -f1;); # remove commented & whitespace-only lines from script
        CHECKSUM_ERROR_UNSIGNED=4294967295;
        TOTAL_LINES_THISSCRIPT_REMOTE=$(curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "${SYNC_CI_REMOTE}" | wc -l);
        TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED=10;
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  SYNC_CI_REMOTE = [ ${SYNC_CI_REMOTE} ]";
          echo "Debug:  TOTAL_LINES_THISSCRIPT_REMOTE = [ ${TOTAL_LINES_THISSCRIPT_REMOTE} ]";
          echo "Debug:  TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED = [ ${TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED} ]";
          echo "";
          echo "Debug:  CHECKSUM_LOCAL = [ ${CHECKSUM_LOCAL} ]";
          echo "Debug:  CHECKSUM_REMOTE = [ ${CHECKSUM_REMOTE} ]";
          echo "Debug:  CHECKSUM_ERROR_UNSIGNED = [ ${CHECKSUM_ERROR_UNSIGNED} ]";
        fi;
        # ------------------------------
        #
        # Apply conditional logic to determine whether the self-update will run or not
        #
        if [[ ${ARGS_FORCE_SELF_UPDATE} -eq 1 ]]; then
          UPDATE_SELF_REQUIRED=1;
          echo -e "\nInfo:  Self-update forced (via argument '--force-self-update')";
        elif [[ ${TOTAL_LINES_THISSCRIPT_REMOTE} -lt ${TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED} ]]; then
          UPDATE_SELF_REQUIRED=0;
          echo -e "\nInfo:  Self-update skipped (minimum lines of code (${TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED}) not met while resolving remote source code (${TOTAL_LINES_THISSCRIPT_REMOTE}) from path/url \"${SYNC_CI_REMOTE}\")";
        elif [[ "${CHECKSUM_REMOTE}" == "${CHECKSUM_ERROR_UNSIGNED}" ]]; then
          UPDATE_SELF_REQUIRED=0;
          echo -e "\nInfo:  Self-update skipped (checksum of remote version (${CHECKSUM_REMOTE}) is invalid (unsigned int error))";
        elif [[ "${CHECKSUM_REMOTE}" == "${CHECKSUM_LOCAL}" ]]; then
          UPDATE_SELF_REQUIRED=0;
          echo -e "\nInfo:  Self-update skipped (checksum equal between local version (${CHECKSUM_LOCAL}) & remote version (${CHECKSUM_REMOTE}))";
        elif [[ "${CHECKSUM_REMOTE}" != "${CHECKSUM_LOCAL}" ]]; then
          UPDATE_SELF_REQUIRED=1;
          echo -e "\nInfo:  Self-update required (checksum difference detected between local version (${CHECKSUM_LOCAL}) & remote version (${CHECKSUM_REMOTE}))";
        fi;

      fi;

      if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
        echo "";
        echo "Debug:  UPDATE_SELF_REQUIRED = [ ${UPDATE_SELF_REQUIRED} ]";
      fi;

      if [[ "${UPDATE_SELF_REQUIRED}" -eq 1 ]]; then
        # ------------------------------
        #
        # Self-update >> IS << required
        #  |
        #  |--> Recursively call the latest version of this script, making sure to use the same CLI parameters
        #

        ### ------------------------------
        ### DEPRECATED APPROACH (local callback) - Threw preposterous amounts of unintelligable errors when the source repo's script file differed from the local script file - likely due to the fact that the script file is running within itself locally while also updating itself
        ### if [[ 0 -eq 1 ]]; then
        ###   echo "Info:  Running self-update...";
        ###   if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "Info:  Downloading updated runtime from remote path \"${SYNC_CI_REMOTE}\" to local path \"${SYNC_CI_LOCAL}\""; fi;
        ###   BENCHMARK_START=$(date +'%s.%N');
        ###   # Download the latest version of this script
        ###   curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "${SYNC_CI_REMOTE}" | sed -e '/^\s*$/d' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' > "${SYNC_CI_LOCAL}"; # remove commented & whitespace-only lines from script
        ###   chmod 0755 "${SYNC_CI_LOCAL}";
        ###   RECURSIVE_CALLBACK_COMMAND+="${SYNC_CI_LOCAL} --skip-self-update $@}";
        ###   if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "      |--> Calling [ eval \" ${RECURSIVE_CALLBACK_COMMAND}\"; ]...\n"; fi;
        ###   eval " ${RECURSIVE_CALLBACK_COMMAND}"; # trigger the recursive callback
        ###   if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
        ### fi;
        ### ------------------------------

        RECURSIVE_CALLBACK_ECHO="\n---- Info:  Recursively calling latest revision of this script  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))\n";

        # if [[ -n "$(command -v eval 2>'/dev/null';)" ]]; then
          # ------------------------------
          #
          # 'eval' DOES exist as a local command - build a recursive callback command to pass to it
          #   |
          #   |--> Call script directly from source as a remote URL (to avoid conflict updating/running the file which is already running and executing these commands)
          #
          RECURSIVE_CALLBACK_COMMAND+="curl -H 'Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' -sL '${SYNC_CI_REMOTE}'";
          # remove whitespace-only lines
          RECURSIVE_CALLBACK_COMMAND+=" | sed -e '/^\s*$/d'";
          # trim leading/trailing whitespace (from all lines)
          RECURSIVE_CALLBACK_COMMAND+=" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'";
          # remove comment-only lines
          RECURSIVE_CALLBACK_COMMAND+=" | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p'";
          # remove comments appended to the end of lines
          RECURSIVE_CALLBACK_COMMAND+=" | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/'";
          # set the script to use the local bash shell
          RECURSIVE_CALLBACK_COMMAND+=" | /bin/bash -s -- --skip-self-update $@";
          # EVAL COMMAND MOVED TO END OF SCRIPT
        # else
        #   ------------------------------
          
        #   'eval' does NOT exist as a local command - call the recursive callback command directly (via curL) without eval
        #     |
        #     |--> Call script directly from source (to avoid conflict updating/running the file which is already running and executing these commands)
          
        #   if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "      |--> Calling [ curl -H 'Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' -sL \"${SYNC_CI_REMOTE}\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -e '/^\s*$/d' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | /bin/bash -s -- --skip-self-update $@; ]..."; fi;
        #   echo "";
        #   curl -H 'Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' -sL "${SYNC_CI_REMOTE}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -e '/^\s*$/d' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | /bin/bash -s -- --skip-self-update $@; # trigger the recursive callback
        # fi;

        # echo -e "\n==== Info:  Returned to parent runtime from recursive call  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";

      else
        # ------------------------------
        #
        # Self-update >> NOT << required  (possibly already running as a recursive call)
        #
        if [[ -z "$(command -v git 2>'/dev/null';)" ]]; then
          #
          # 'git' does NOT exist as a local command
          #
          echo -e "\nWarning:  Unable to pull/update repository codebase - Pre-requisite command \"git\" not found";
        else
          #
          # 'git' DOES exist as a local command
          #
          # Fetch/Pull/Clone the Remote Repo
          echo -e "\nInfo:  Pulling the latest revision of the \"${GIT_REPO_NAME}\" repository using the \"${GIT_SOURCE_BRANCH}\" branch";
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Source (Repo URL):   ${GIT_SOURCE_REPO_URL}"; fi;
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Destination (Path):  ${GIT_LOCAL_REPO_PATH}"; fi;
          BENCHMARK_START=$(date +'%s.%N');
          if [[ ! -d "${GIT_LOCAL_PARENT_PATH}" ]]; then
            # Ensure that the directory designated to contain git repos exists (locally)
            mkdir -p "${GIT_LOCAL_PARENT_PATH}";
          fi;          # Clone the repo if it hasn't been synced, yet
          if [[ ! -d "${GIT_LOCAL_REPO_PATH}" ]]; then
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Calling [ cd \"${GIT_LOCAL_PARENT_PATH}\" && git clone --quiet \"${GIT_SOURCE_REPO_URL}\"; ]..."; fi;
            cd "${GIT_LOCAL_PARENT_PATH}" && \
            git clone --quiet "${GIT_SOURCE_REPO_URL}";
          fi;
          # Sync local workstation's commands with the repo's commands
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Calling [ cd \"${GIT_LOCAL_REPO_PATH}\" && git fetch --quiet && git reset --quiet --hard \"origin/${GIT_SOURCE_BRANCH}\" && git pull --quiet; ]..."; fi;
          cd "${GIT_LOCAL_REPO_PATH}" && \
          git fetch --quiet && \
          git reset --quiet --hard "origin/${GIT_SOURCE_BRANCH}" && \
          git pull --quiet;
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # Set ownership for git-repo files as-intended
          echo -e "\nInfo:  Setting ownership for directories within the local \"${GIT_REPO_NAME}\" repo clone";
          BENCHMARK_START=$(date +'%s.%N');
          # find "${GIT_LOCAL_REPO_PATH}" -type d -exec chmod 0700 "{}" ";"; # directories, find + chmod
          find "${GIT_LOCAL_REPO_PATH}" -type d -print0 | xargs -0 chmod 0700; # directories, xargs + chmod
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # Set ownership for git-repo directories as-intended
          echo -e "\nInfo:  Setting ownership for files within the local \"${GIT_REPO_NAME}\"  repo clone";
          BENCHMARK_START=$(date +'%s.%N');
          # find "${GIT_LOCAL_REPO_PATH}" -type f -exec chmod 0600 "{}" ";"; # files, find + chmod
          find "${GIT_LOCAL_REPO_PATH}" -type f -print0 | xargs -0 chmod 0600; # files, xargs + chmod
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
        fi;
        # ------------------------------
        #
        # Detect WSL shells
        #  |--> Attempt to detect WSL shells, and (if shell is a WSL shell) resolve the Windows user who is running the current WSL shell
        #
        if [[ ${ARGS_CHECK_WSL} -eq 1 ]]; then
          # WSL_CHECK_EXISTS="$(command -v get_username_windows_wsl 2>'/dev/null';)";
          # if [[ -n "${WSL_CHECK_EXISTS}" ]]; then
          #   echo -e "\nInfo:  Checking for Windows Subsystem for Linux (WSL) Environment";
          #   WIN32_USERNAME=$(get_username_windows_wsl);
          #   WIN32_USER_ERRORS="$?";
          # fi;
          WSL_CHECK_EXISTS="$(command -v wslvar 2>'/dev/null';)";
          if [[ -n "${WSL_CHECK_EXISTS}" ]]; then
            echo -e "\nInfo:  Checking for Windows Subsystem for Linux (WSL) Environment";
            WIN32_USERNAME=$(wslvar --sys "USERNAME";);
            WIN32_USER_ERRORS="${?}";
          fi;
          if [[ -n "${WIN32_USERNAME}" ]] && [[ -n "${WIN32_USER_ERRORS}" ]] && [[ "${WIN32_USER_ERRORS}" == "0" ]]; then
            # ------------------------------
            #
            # Running in WSL (Windows Subsystem for Linux) shell on a Windows-based OS
            #  |--> Locate source directory from amongst Win32 Host-User's files
            #
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Detected Windows Subsystem for Linux (WSL) Environment - Checking for local repo files"; fi;
            BENCHMARK_START=$(date +'%s.%N');
            WIN32_HOMEDIR=$(find /mnt/*/Users/${WIN32_USERNAME} -mindepth 0 -maxdepth 0 -type d 2>'/dev/null';);
            # WIN32_USR_LOCAL=$(find ${WIN32_HOMEDIR}/Documents -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
            WIN32_USR_LOCAL=$(find "${WIN32_HOMEDIR}/Documents/"**"/${GIT_REPO_NAME}/usr/local" -maxdepth 0 -type d 2>'/dev/null' | head -n 1;);
            if [[ -z "${WIN32_USR_LOCAL}" ]]; then
              # echo "  |--> Warning:  Unable to locate directory matching '${GIT_REPO_NAME}/usr/local' within win32-user's documents @ '${WIN32_USERNAME}'";
              # EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
              WIN32_HOMEDIR="";
              WIN32_USR_LOCAL="";
            else
              DIR_REPO_USR="$(dirname ${WIN32_USR_LOCAL})";
              DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Using repository directory @ [ ${DIR_REPO_BASE} ]"; fi;
            fi;
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          fi;
        fi;
        # ------------------------------
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  WSL_CHECK_EXISTS = [ ${WSL_CHECK_EXISTS} ]";
          echo "Debug:  WIN32_HOMEDIR = [ ${WIN32_HOMEDIR} ]";
          echo "Debug:  WIN32_USR_LOCAL = [ ${WIN32_USR_LOCAL} ]";
          echo "Debug:  WIN32_USERNAME = [ ${WIN32_USERNAME} ]";
          echo "Debug:  WIN32_USER_ERRORS = [ ${WIN32_USER_ERRORS} ]";
        fi;
        # ------------------------------
        #
        # WSL shell
        #  |--> Create symbolic links back to windows user directories
        #
        if [[ -n "${WIN32_HOMEDIR}" ]] && [[ -d "${WIN32_HOMEDIR}" ]]; then
          #
          # Create symbolic link to WSL user's manuals directory
          #
          WSL_DIR="${WIN32_HOMEDIR}/Documents/GitHub/Coding/man";
          if [[ -d "${WSL_DIR}" ]]; then
            # Create link(s) to the Windows user's directory (who is masquerading as the current WSL User)
            if [[ -d "${HOME}" ]]; then
              # Home Dir - Current User
              if [[ ! -h "${HOME}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${HOME}/$(basename ${WSL_DIR})" ]]; then
                ln -sf "${WSL_DIR}" "${HOME}/$(basename ${WSL_DIR})";
              fi;
            fi;
            if [[ -n "${SUDO_USER}" ]]; then
              # Home Dir - Sudoer User (also create link in default user's homedir)
              SUDOER_HOMEDIR="$(getent passwd ${SUDO_USER} | cut -d: -f 6;)";
              if [[ -d "${SUDOER_HOMEDIR}" ]]; then
                if [[ ! -h "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]]; then
                  ln -sf "${WSL_DIR}" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
                fi;
                chown --no-dereference "${SUDO_USER}:$(id -gn ${SUDO_USER})" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
              fi;
            fi;
          fi;
          #
          # Create symbolic link to WSL user's desktop
          #
          WSL_DIR="${WIN32_HOMEDIR}/Desktop";
          if [[ -d "${WSL_DIR}" ]]; then
            # Current User
            if [[ -d "${HOME}" ]]; then
              if [[ ! -h "${HOME}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${HOME}/$(basename ${WSL_DIR})" ]]; then
                ln -sf "${WSL_DIR}" "${HOME}/$(basename ${WSL_DIR})";
              fi;
            fi;
            if [[ -n "${SUDO_USER}" ]]; then
              # Sudoer User (also create link in default user's homedir)
              SUDOER_HOMEDIR="$(getent passwd ${SUDO_USER} | cut -d: -f 6;)";
              if [[ -d "${SUDOER_HOMEDIR}" ]]; then
                if [[ ! -h "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]]; then
                  ln -sf "${WSL_DIR}" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
                fi;
                chown --no-dereference "${SUDO_USER}:$(id -gn ${SUDO_USER})" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
              fi;
            fi;
          fi;
        fi;
        # ------------------------------
        if [[ -z "${WIN32_HOMEDIR}" ]]; then
          #
          # Non-WSL shell
          #  |--> Check for required Linux filepath(s)
          #
          echo -e "\nInfo:  Checking for local repository files within user [ $(whoami) ]'s home-directory";
          BENCHMARK_START=$(date +'%s.%N');
          WHOAMI_HOME_DIR="$(getent passwd $(id -un) | cut --delimiter=: --fields=6)";
          WHOAMI_USR_LOCAL=$(find ${WHOAMI_HOME_DIR} -mindepth 2 -maxdepth 5 -name 'local' -type d 2>'/dev/null' | grep "/${GIT_REPO_NAME}/usr/local");
          DIR_REPO_USR="$(dirname ${WHOAMI_USR_LOCAL})";
          DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
          RET_CODE=$?;
          if [[ ${RET_CODE} -eq 0 ]]; then
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Using [ $(whoami) ] user's repository directory @ [ ${DIR_REPO_BASE} ]"; fi;
          else 
            if [[ -n "${SUDO_USER}" ]]; then
              #  Linux OS - Locate source directory from amongst Non-Sudo User's files
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Repository not found within [ $(whoami) ] user's home-directory"; fi;
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Checking for local repository files within [ ${SUDO_USER} ] user's home-directory"; fi;
              SUDOER_HOME_DIR="$(getent passwd ${SUDO_USER} | cut --delimiter=: --fields=6)";
              SUDOER_USR_LOCAL=$(find ${SUDOER_HOME_DIR} -mindepth 2 -maxdepth 5 -name 'local' -type d 2>'/dev/null' | grep "/${GIT_REPO_NAME}/usr/local");
              DIR_REPO_USR="$(dirname ${SUDOER_USR_LOCAL})";
              DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
              RET_CODE=$?;
              if [[ ${RET_CODE} -eq 0 ]]; then
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Using [ ${SUDO_USER} ] user's repository directory @ [ ${DIR_REPO_BASE} ]"; fi;
              fi;
            fi;
          fi;
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
        fi;
        # ------------------------------
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  DIR_REPO_BASE = [ ${DIR_REPO_BASE} ]";
          echo "Debug:  DIR_REPO_USR = [ ${DIR_REPO_USR} ]";
          echo "Debug:  SUDO_USER = [ ${SUDO_USER} ]";
          echo "Debug:  SUDOER_HOMEDIR = [ ${SUDOER_HOMEDIR} ]";
        fi;
        # ------------------------------
        if [[ -z "${DIR_REPO_BASE}" ]]; then
          # Required variable(s) are empty/unset
          EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          echo "";
          echo "Error:  Required variable is empty/unset: \${DIR_REPO_BASE}";
        elif [[ ! -d "${DIR_REPO_BASE}/usr/local/bin/" ]] || [[ ! -d "${DIR_REPO_BASE}/usr/local/sbin/" ]]; then
          # Required source directory/directories not found
          EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          if [[ ! -d "${DIR_REPO_BASE}/usr/local/bin/" ]]; then
            echo "";
            echo "Error:  Directory not-found: [ ${DIR_REPO_BASE}/usr/local/bin/ ]";
          fi;
          if [[ ! -d "${DIR_REPO_BASE}/usr/local/sbin/" ]]; then
            echo "";
            echo "Error:  Directory not-found: [ ${DIR_REPO_BASE}/usr/local/sbin/ ]";
          fi;
        fi;
        # ------------------------------
        if [[ "${EXIT_CODE}" == "0" ]] && [[ "${UPDATE_SELF_REQUIRED}" -ne 1 ]]; then
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  'If' main statement block - No errors detected thus far  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;
          #
          # No known/caught errors were thrown up-until this point - Assume prereq installs/packages/modules exist
          #  |--> Run the part of the sync job which actually performs the sync
          #
          # ------------------------------
          #
          # /usr/local/bin
          #
          DESTINATION_PATH="/usr/local/bin";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0755"; DIR_PERMS="0755";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
          rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------
          #
          # /usr/local/sbin
          #
          EXCLUDE_PATTERN="*/$(basename "${SYNC_CI_LOCAL}";)";
          DESTINATION_PATH="/usr/local/sbin";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0755"; DIR_PERMS="0755";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" --exclude=\"${EXCLUDE_PATTERN}\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
          rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" --exclude="${EXCLUDE_PATTERN}" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------
          #
          # /etc/inputrc
          #
          if [[ -f '/etc/inputrc' ]]; then
            if [[ $(sed -rne 's/^#\s*(set\s+bell-style\s+none\s*)$/\0/p' '/etc/inputrc' | wc -l 2>'/dev/null';) -gt 0 ]]; then
              ### Bash - Do not bell on tab-completion (silence it, instead - especially intended for WSL (Windows Subsystem for Linux))
              BENCHMARK_START=$(date +'%s.%N');
              echo -e "\nInfo:  Setting bell-style the bell sound effect in \"/etc/inputrc\")";
              sed -i".${START_TIMESTAMP}.bak" -r -e 's/^#\s*(set\s+bell-style\s+none\s*)$/\1/' '/etc/inputrc'; # Uncomment lines starting with  [ # set bell-style none ]
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------
          #
          # /etc/profile
          #
          if [[ $(sed -rne 's/^MAIL=""$/\0/p' '/etc/profile' | wc -l 2>'/dev/null';) -eq 0 ]]; then
            if [[ $(sed -rne 's/^(\s*export ?.*)( MAIL)( ?.*)$/\0/p' '/etc/profile' | wc -l 2>'/dev/null';) -gt 0 ]]; then
              ### Bash - Disable "You have mail in ..." && "You have new mail in /var/spool/mail/..." alerts
              BENCHMARK_START=$(date +'%s.%N');
              echo -e "\nInfo:  Disabling \"You have new mail in ...\" alerts (commenting MAIL=... in \"/etc/profile\")";
              sed -i".${START_TIMESTAMP}.bak" -r -e 's/^ *MAIL=".+"/#\0/p' "/etc/profile"; # Comment out all lines which set variable  [ MAIL ]  to anything OTHER THAN an empty string
              sed -i".${START_TIMESTAMP}.bak" -r -e '/^ *export ?.* MAIL ?.*/{' -e 'i\MAIL=""' -e '}' "/etc/profile"; # Remove MAIL from the  [ export ... ]  variables
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------
          #
          # /etc/pki/ca-trust/source/anchors  (Server root-certificates & CA-bundles)
          #
          if [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
            DESTINATION_PATH="/etc/pki/ca-trust/source/anchors";
            SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
            FILE_PERMS="0644"; DIR_PERMS="0644";
            echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
            BENCHMARK_START=$(date +'%s.%N');
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
            rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
            chown -R "root:root" "${DESTINATION_PATH}";
            find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
            find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
            if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
            dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            # Reference:  https://manuals.gfi.com/en/kerio/connect/content/server-configuration/ssl-certificates/adding-trusted-root-certificates-to-the-server-1605.html
            update-ca-trust force-enable;
            update-ca-trust extract; # Update for Rhel/Centos
          fi;
          # ------------------------------
          #
          # /etc/profile.d/required_paths.sh
          #
          DESTINATION_PATH="/etc/profile.d/required_paths.sh";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0644"; DIR_PERMS="0644";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
          rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------
          #
          # /etc/profile.d/bash_history_logging.sh
          #
          DESTINATION_PATH="/etc/profile.d/bash_history_logging.sh";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0644"; DIR_PERMS="0644";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
          rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------
          #
          # /etc/whitelist.d
          #
          DESTINATION_PATH="/etc/whitelist.d";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0644"; DIR_PERMS="0755";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
          rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------
          #
          # /etc/ssh/sshd_config
          #
          if [[ ${ARGS_SYNC_SSH_CONFIG} -eq 1 ]]; then
            if [[ -z "$(command -v ssh 2>'/dev/null';)" ]]; then
              echo -e "\nInfo:  Skipped SSH config update - Pre-requisite command 'ssh' not found";
            else
              # ------------------------------
              #
              # Backup & Update the sshd_config (SSH Server) file
              #
              SSHD_CONFIG_LIVE="/etc/ssh/sshd_config";
              SSHD_CONFIG_MFA="${SSHD_CONFIG_LIVE}.mfa"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_MFA}" "${SSHD_CONFIG_MFA}";
              SSHD_CONFIG_NO_MFA="${SSHD_CONFIG_LIVE}.no_mfa"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_NO_MFA}" "${SSHD_CONFIG_NO_MFA}";
              SSHD_CONFIG_PASS_AUTH="${SSHD_CONFIG_LIVE}.password_auth"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_PASS_AUTH}" "${SSHD_CONFIG_PASS_AUTH}";
              SSHD_CONFIG_SED="${SSHD_CONFIG_LIVE}.sed";
              if [[ ! -d "/etc/ssh/authorized_keys" ]]; then
                echo -e "\nInfo:  Creating directory \"/etc/ssh/authorized_keys\"";
                mkdir "/etc/ssh/authorized_keys";
                chmod 0755 "/etc/ssh/authorized_keys";
                chown "root:root" "/etc/ssh/authorized_keys";
              fi;
              if [[ -d "/etc/ssh/authorized_keys" ]] && [[ "$(find /etc/ssh/authorized_keys -type f | wc -l;)" != "0" ]]; then
                #
                # Set ownership of "/etc/ssh/authorized_keys" directory as-intended
                #
                ### chmod 0755 "/etc/ssh/authorized_keys"; # Keep for reference on intended permissions for "/etc/ssh/authorized_keys" (chmod 0755 as-of 20200310-063820)
                #
                # At least one SSH-Key exists in the standard keyfile directory (/etc/ssh/authorized_keys)
                #
                MFA_CONFIG_LOGIN_DUO="/etc/duo/login_duo.conf";
                MFA_CONFIG_PAM_DUO="/etc/duo/pam_duo.conf";
                if [[ -f "${MFA_CONFIG_PAM_DUO}" ]] || [[ -f "${MFA_CONFIG_LOGIN_DUO}" ]]; then
                  #
                  # Duo MFA Installed --> Use it (through PAM) for SSH-Authentication
                  #
                  SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_MFA}";
                else
                  #
                  # No MFA, but at least one SSH-Key exists
                  #
                  SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_NO_MFA}";
                fi;
              else
                #
                # No SSH Key(s) exist in the standard keyfile directory (/etc/ssh/authorized_keys) --> Allow passwords, for now
                #
                SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_PASS_AUTH}";
              fi;
              # ------------------------------
              dos2unix --quiet "${SSHD_CONFIG_LIVE}";
              dos2unix --quiet "${SSHD_CONFIG_REPLACEMENT}";
              if [[ $(cmp -s "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_REPLACEMENT}" 1>'/dev/null' 2>&1; echo ${?};) -eq 0 ]]; then
                #
                # SSH config file already fully up-to-date
                #
                echo "";
                echo "Info:  Skipped SSH config update for file \"${SSHD_CONFIG_LIVE}\"";
                echo "  |--> Checksum already up-to-date with \"$(basename "${SSHD_CONFIG_REPLACEMENT}";)\"";
              elif [[ ! -d "/home/" ]] || [[ $(find '/home/' -mindepth 1 -maxdepth 1 | wc -l 2>'/dev/null') -eq 0 ]]; then
                #
                # Need another user other than root to SSH into this machine --> No user directories found in /home/.
                #
                echo "";
                echo "Info:  Skipped SSH config update for file \"${SSHD_CONFIG_LIVE}\"";
                echo "  |--> There must be at least one user (other than root) who can access this workstation via SSH, and has a home directory within [ /home/ ]";
                echo "  |--> The updated SSH config will deny the root user from accessing this device via SSH (to prevent Brute-force/Dictionary SSH Attacks on this device)";
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Debug:  Citation:  https://www.cmu.edu/iso/aware/be-aware/brute-force_ssh_attack.html"; fi;
              elif [[ ! -d "/etc/ssh/authorized_keys/" ]] || [[ $(find '/etc/ssh/authorized_keys/' -mindepth 1 -maxdepth 1 | wc -l 2>'/dev/null') -eq 0 ]]; then
                #
                # Need at least one SSH-Key to exist in /etc/ssh/authorized_keys/.
                #
                echo "";
                echo "Info:  Skipped SSH config update for file \"${SSHD_CONFIG_LIVE}\"";
                echo "  |--> There must be at least one SSH public key matching filepath [ /etc/ssh/authorized_keys/USERNAME_HERE ]";
                echo "  |--> Example filepath:  [ /etc/ssh/authorized_keys/${SUDO_USER} ]";
              else
                #
                # Suggest to the user that they should open an additional SSH terminal to avoid being locked out of the server
                #
                ECHO_SSH_WARNING="";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n !!! Warning !!!";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |--> Update to SSH Configuration Requested";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |--> To avoid being locked-out, ensure you have a separate SSH connection open (aside from this terminal) before continuing";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
                ECHO_SSH_CONFIRMATION="  |--> Update SSH config '/etc/ssh/sshd_config'? If you are unsure, press 'n'  (press 'y' to confirm)  ";
                if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
                  #
                  # Require user-confirmation to proceed with config update
                  #
                  echo -e "${ECHO_SSH_WARNING}";
                  REPLY="";
                  if [[ "${IS_TTY_TERMINAL}" -eq 1 ]]; then
                    echo -n "${ECHO_SSH_CONFIRMATION}";
                    read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                  fi;
                  if [[ -z "${REPLY}" ]] || [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" != "y" ]]; then
                    #
                    # User declined the config update
                    #
                    echo "  |--> Denied - Skipped SSH config update";
                  else
                    #
                    # User accepted/confirmed the config update
                    #
                    echo "  |--> Confirmed - Updating SSH config file \"${SSHD_CONFIG_LIVE}\" with contents from file \"${SSHD_CONFIG_REPLACEMENT}\"";
                    #
                    # Backup & Update the sshd_config (SSH Server) file
                    #
                    BENCHMARK_START=$(date +'%s.%N');
                    cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_LIVE}.${START_TIMESTAMP}.bak" \
                      && wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${SSHD_CONFIG_REPLACEMENT}" -O "${SSHD_CONFIG_REPLACEMENT}" -q \
                      && chmod 0644 "${SSHD_CONFIG_REPLACEMENT}" \
                      && cp -f "${SSHD_CONFIG_REPLACEMENT}" "${SSHD_CONFIG_LIVE}" \
                      && RESTART_SERVICE_SSH=1;
                    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                  fi;
                elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
                  #
                  # Amongst other things, disable the "root" user and require that users login with SSH private keys (deny password-based login)
                  #
                  BENCHMARK_START=$(date +'%s.%N');
                  cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_SED}";
                  chmod 0644 "${SSHD_CONFIG_SED}";
                  sed -r -i \
                    -e "/^#?AuthorizedKeysFile/c\AuthorizedKeysFile /etc/ssh/authorized_keys/%u" \
                    -e "/^#?AuthenticationMethods/c\AuthenticationMethods publickey" \
                    -e "/^#?ChallengeResponseAuthentication/c\ChallengeResponseAuthentication no" \
                    -e "/^#?LogLevel/c\LogLevel INFO" \
                    -e "/^#?PasswordAuthentication/c\PasswordAuthentication no" \
                    -e "/^#?PermitEmptyPasswords/c\PermitEmptyPasswords no" \
                    -e "/^#?PermitRootLogin/c\PermitRootLogin no" \
                    -e "/^#?PubkeyAuthentication/c\PubkeyAuthentication yes" \
                    -e "/^#?SyslogFacility/c\SyslogFacility AUTH" \
                    -e "/^#?TCPKeepAlive/c\TCPKeepAlive no" \
                    -e "/^#?UseDNS/c\UseDNS no" \
                    -e "/^#?UsePAM/c\UsePAM yes" \
                    "${SSHD_CONFIG_SED}";
                  #
                  # Remove duplicated lines in target file (while keeping one copy of each line)
                  #
                  echo "$(tac ${SSHD_CONFIG_SED};)" > "${SSHD_CONFIG_SED}";
                  echo "$(cat -n ${SSHD_CONFIG_SED} | sort -uk2 | sort -nk1 | cut -f2-;)" > "${SSHD_CONFIG_SED}";
                  echo "$(tac ${SSHD_CONFIG_SED};)" > "${SSHD_CONFIG_SED}";
                  #
                  # Update the service's config-file only if its checksum is not the same as the updated config-file's checksum
                  #
                  CHECKSUM_SOURCE=$(cat "${SSHD_CONFIG_LIVE}" | cksum | cut -d" " -f1;);
                  CHECKSUM_UPDATED=$(cat "${SSHD_CONFIG_SED}" | cksum | cut -d" " -f1;);
                  if [[ "${CHECKSUM_SOURCE}" != "${CHECKSUM_UPDATED}" ]]; then
                    #
                    # Require user-confirmation to proceed with config update
                    #
                    echo -e "${ECHO_SSH_WARNING}";
                    REPLY="";
                    echo -n "${ECHO_SSH_CONFIRMATION}";
                    read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                    echo "";
                    if [[ -z "${REPLY}" ]] || [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" != "y" ]]; then
                      #
                      # User declined the config update
                      #
                      echo "  |--> Denied - Skipped SSH config update";
                    else
                      #
                      # User accepted/confirmed the config update
                      #
                      echo -e "  |--> Confirmed - Updating SSH config file \"${SSHD_CONFIG_LIVE}\" with contents from file \"${SSHD_CONFIG_SED}\"";
                      cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_LIVE}.${START_TIMESTAMP}.bak" \
                        && cp -f "${SSHD_CONFIG_SED}" "${SSHD_CONFIG_LIVE}" \
                        && RESTART_SERVICE_SSH=1;
                    fi;
                  else
                    echo -e "\nInfo:  Skipped SSH config update - Already running the latest revision";
                  fi;
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                fi;
              fi;
              # ------------------------------
            fi;
          fi;
          # ------------------------------
          # Sync Timezone
          TZ="America/New_York";
          if [[ ${ARGS_SYNC_TIMEZONE} -eq 1 ]] && [[ "$(cat /etc/timezone;)" != "${TZ}" ]]; then
              echo -e "\nInfo:  Request to set Timezone to \"${TZ}\"";
              echo -n "  |--> Set timezone to '${TZ}'?  (press 'y' to confirm)  ";
              read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
              echo "";
              if [[ $REPLY =~ ^[Yy]$ ]]; then
                ln -snf "/usr/share/zoneinfo/$TZ" "/etc/localtime";
                echo $TZ > "/etc/timezone";
              fi;
            fi;
          fi;
          # ------------------------------
          # Sync UFW ("Uncomplicated Firewall")
          ENABLE_CRON_DDNS_UPDATER=0;
          if [[ ${ARGS_SYNC_UFW} -eq 1 ]]; then
            # Ensure that the UFW module exists on the current Linux Distro before continuing to setting it up
            if [[ -n "$(command -v ufw 2>'/dev/null';)" ]]; then
              # Distros: Debian, Ubuntu, etc.
              if [[ $(ufw status 1>'/dev/null' 2>&1; echo ${?};) -eq 0 ]]; then
                # Check if UFW is enabled or disabled
                UFW_ENABLED=$(test -n "$(ufw status | grep 'Status' | grep 'inactive')" && echo 0 || echo 1;);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
                  echo "";
                  echo "Debug:  UFW_ENABLED = [ ${UFW_ENABLED} ]";
                fi;
                if [[ ${UFW_ENABLED} -eq 0 ]]; then
                  # UFW DISABLED - Show recommendations for general-practice setup
                  echo -e "\nWarning:  Firewall package UFW (uncomplicated firewall) is installed but disabled";
                  echo -e "  |--> Call this script with \"--debug\" for suggested resolution path";
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
                    echo "  |";
                    echo "  |--> Recommend applying the following ruleset, enabling UFW, then tweaking rules as-needed:";
                    echo "         ufw allow proto tcp from 10.0.0.0/8 to any port 22;     # Allow incoming SSH/SFTP requests from LAN IPv4 addresses (RFC-1918)";
                    echo "         ufw allow proto tcp from 172.16.0.0/12 to any port 22;  # Allow incoming SSH/SFTP requests from LAN IPv4 addresses (RFC-1918)";
                    echo "         ufw allow proto tcp from 192.168.0.0/16 to any port 22; # Allow incoming SSH/SFTP requests from LAN IPv4 addresses (RFC-1918)";
                    echo "         ufw allow proto tcp from 0.0.0.0/0 to any port 80;      # Allow incoming HTTP requests from any IPv4 address";
                    echo "         ufw allow proto tcp from 0.0.0.0/0 to any port 443;     # Allow incoming HTTPS requests from any IPv4 address";
                    echo "         ufw allow proto tcp from ::/0 to any port 80;           # Allow incoming HTTP requests from any IPv6 address";
                    echo "         ufw allow proto tcp from ::/0 to any port 443;          # Allow incoming HTTPS requests from any IPv6 address";
                    echo "         ufw default allow outgoing; # allow all non-matched outgoing requests";
                    echo "         ufw default deny incoming;  # deny all non-matched incoming requests";
                    echo "         ufw logging on; # enable logging";
                    echo "         ufw enable; # enforce all ufw rules, including aforementioned 'allow' and 'deny' rules (if applied)";
                    echo "         ## Add / remove / tweak UFW rules as-needed (based on machine's environment and designated purpose)";
                  fi;
                  SUGGEST_ENABLING_UFW=0;  # DISABLED
                  if [[ "${SUGGEST_ENABLING_UFW}" -eq 1 ]]; then
                    # UFW DISABLED - Prompt for confirmation before auto-enabling UFW (and potentially locking user out of being able to access the machine)
                    echo "  |";
                    echo "  |--> UFW sync requested, however UFW is currently disabled";
                    echo "  |";
                    REPLY="";
                    echo -n "  |--> Enable UFW (uncomplicated firewall)? If you are unsure, press 'n'  (press 'y' to confirm)  ";
                    read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                    echo "";
                    if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                      echo "  |--> Confirmed - Enabling UFW...";
                      ufw enable;
                      # Re-check UFW Enabled/Disabled Status
                      UFW_ENABLED=$(test -n "$(ufw status | grep 'Status' | grep 'inactive')" && echo 0 || echo 1;);
                      if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
                        echo "Debug:  UFW_ENABLED = [ ${UFW_ENABLED} ]";
                      fi;
                    else
                      echo "  |--> Denied - UFW will remain disabled";
                    fi;
                  fi;
                fi;
                if [[ ${UFW_ENABLED} -eq 1 ]]; then
                  # UFW is enabled
                  RESTART_SERVICE_UFW=1;
                  RESTART_SERVICE_SSH=1;
                  # Sync Cronjob Automation:  UFW DDNS Updates
                  if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
                    ENABLE_CRON_DDNS_UPDATER=1;
                  fi;
                fi;
              fi;
            elif [[ -n "$(command -v firewall-cmd 2>'/dev/null';)" ]]; then
              # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
              if [[ $(systemctl is-enabled firewalld 1>'/dev/null' 2>&1; echo $?) -eq 0 ]]; then
                ENABLE_CRON_DDNS_UPDATER=1;
              fi;
            fi;
            if [[ ${ENABLE_CRON_DDNS_UPDATER} -ne 0 ]]; then
              # Enable a cronjob to perform scheduled updates/syncs of the UFW firewall whitelist
              CRON_DDNS_UFW_UPDATE="/etc/cron.d/CRON_ddns_ufw_update";
              echo -e "\nInfo:  Updating \"${CRON_DDNS_UFW_UPDATE}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${CRON_DDNS_UFW_UPDATE}" -O "${CRON_DDNS_UFW_UPDATE}" -q \
                && chmod 0644 "${CRON_DDNS_UFW_UPDATE}" \
                && RESTART_SERVICE_CRON=1;
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;

          fi;
          # ------------------------------
          #
          # /etc/cron.d/...
          #
          if [[ ${ARGS_CRONJOB_SYNC} -eq 1 ]]; then
            RESTART_SERVICE_CRON=1;
            # ------------------------------
            #
            # /etc/cron.d/CRON_sync_cloud_infrastructure
            #
            DESTINATION_PATH="/etc/cron.d/CRON_sync_cloud_infrastructure";
            SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
            FILE_PERMS="0644"; DIR_PERMS="0644";
            echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
            BENCHMARK_START=$(date +'%s.%N');
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
            rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
            chown -R "root:root" "${DESTINATION_PATH}";
            find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
            find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
            if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
            dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            # ------------------------------
            #
            # /etc/cron.d/CRON_certbot_renew_all
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              if [[ -n "$(command -v certbot 2>'/dev/null';)" ]]; then
                DESTINATION_PATH="/etc/cron.d/CRON_certbot_renew_all";
                UPDATING_ECHO="$(echo -e "Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";)";
                REPLY="";
                if [[ -f "${DESTINATION_PATH}" ]]; then
                  REPLY="y";
                  echo -e "\nInfo:  ${UPDATING_ECHO}";
                else
                  echo "";
                  echo -n "Enable SSL/TLS certificate auto renewal? (Runs 'certbot_renew_all' every Sunday at 06:10 AM)  (press 'y' to confirm)  ";
                  read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                  echo "";
                  if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                    echo "  |--> Confirmed - ${UPDATING_ECHO}";
                  fi;
                fi;
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                  FILE_PERMS="0644"; DIR_PERMS="0644";
                  BENCHMARK_START=$(date +'%s.%N');
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
                  rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                  chown -R "root:root" "${DESTINATION_PATH}";
                  find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                  find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                  if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                  dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                else
                  echo "  |--> Denied - SSL/TLS certificate auto renewal disabled";
                fi;
              fi;
            fi;
            # ------------------------------
            #
            # /etc/cron.d/CRON_journalctl_logfile_cleanup
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              DESTINATION_PATH="/etc/cron.d/CRON_journalctl_logfile_cleanup";
              UPDATING_ECHO="$(echo -e "Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";)";
              REPLY="";
              if [[ -f "${DESTINATION_PATH}" ]]; then
                REPLY="y";
                echo -e "\nInfo:  ${UPDATING_ECHO}";
              else
                echo "";
                echo -n "Enable logfile auto cleanup? (Runs 'journalctl --vacuum-time=90d --vacuum-size=5G' daily at 02:00 AM)  (press 'y' to confirm)  ";
                read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                echo "";
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  echo "  |--> Confirmed - ${UPDATING_ECHO}";
                fi;
              fi;
              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                BENCHMARK_START=$(date +'%s.%N');
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
                rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              else
                echo "  |--> Denied - Logfile auto cleanup disabled";
              fi;
              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                CONF_FILEPATH="/etc/systemd/journald.conf";
                if [[ 0 -eq 1 ]]; then
                  # Set journalctl/journald system wide defaults via its config file in /etc/systemd
                  OPT="SystemMaxUse";  VAL="768M"; sed -re "s/^[#\s]*${OPT}=.*$/${OPT}=${VAL}/" -i "${CONF_FILEPATH}";  # SystemMaxUse:  Specifies the maximum disk space that can be used by the journal in persistent storage.
                  OPT="RuntimeMaxUse"; VAL="32M";  sed -re "s/^[#\s]*${OPT}=.*$/${OPT}=${VAL}/" -i "${CONF_FILEPATH}";  # RuntimeMaxUse: Specifies the maximum disk space that can be used in volatile storage (within the /run filesystem).
                else
                  # WARNING: Setting the values directly in /etc/systemd/journald.conf seems to make Raspberry Pis hiccup and max their disk I/O usage while running (mild speculation, but issue presented itself intermittently after setting these values)
                  #  |--> Revert the change by re-commending out these lines
                  OPT="SystemMaxUse";  sed -re "s/^\s*${OPT}=.*$/#\0/" "${CONF_FILEPATH}";  # SystemMaxUse:  Specifies the maximum disk space that can be used by the journal in persistent storage.
                  OPT="RuntimeMaxUse"; sed -re "s/^\s*${OPT}=.*$/#\0/" "${CONF_FILEPATH}";  # RuntimeMaxUse: Specifies the maximum disk space that can be used in volatile storage (within the /run filesystem).
                fi;
              fi;
            fi;
            # ------------------------------
            #
            # /etc/cron.d/CRON_update_dns_config
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              DESTINATION_PATH="/etc/cron.d/CRON_update_dns_config";
              UPDATING_ECHO="$(echo -e "Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";)";
              REPLY="";
              if [[ -f "${DESTINATION_PATH}" ]]; then
                REPLY="y";
                echo -e "\nInfo:  ${UPDATING_ECHO}";
              else
                echo "";
                echo -n "Enable DNS server sync? (Runs 'update_dns_config' daily at 04:05 AM)  (press 'y' to confirm)  ";
                read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                echo "";
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  echo "  |--> Confirmed - ${UPDATING_ECHO}";
                fi;
              fi;
              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                BENCHMARK_START=$(date +'%s.%N');
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
                rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              else
                echo "  |--> Denied - DNS server sync disabled";
              fi;
            fi;
            # ------------------------------
            #
            # /etc/cron.d/CRON_update_system
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              DESTINATION_PATH="/etc/cron.d/CRON_update_system";
              UPDATING_ECHO="$(echo -e "Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";)";
              REPLY="";
              if [[ -f "${DESTINATION_PATH}" ]]; then
                REPLY="y";
                echo -e "\nInfo:  ${UPDATING_ECHO}";
              else
                echo "";
                echo -n "Enable system & package weekly updates? (Runs 'update_system' every Sunday at 04:10 AM)  (press 'y' to confirm)  ";
                read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                echo "";
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  echo "  |--> Confirmed - ${UPDATING_ECHO}";
                fi;
              fi;
              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                BENCHMARK_START=$(date +'%s.%N');
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
                rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              else
                echo "  |--> Denied - System & package weekly updates disabled";
              fi;
            fi;
            # ------------------------------
            #
            # /etc/cron.d/CRON_raspi_hw_monitor
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              RaspberryPi_Check=$(grep 'Hardware' '/proc/cpuinfo' | sed --regexp-extended --quiet --expression='s/^Hardware\s*:\s*([a-zA-Z0-9]+)\s*$/\1/p');
              if [[ "${RaspberryPi_Check}" == "BCM2835" ]]; then
                DESTINATION_PATH="/etc/cron.d/CRON_raspi_hw_monitor";
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
                rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              fi;
            fi;
          fi;
          # ------------------------------
          #
          # ${HOME}/.
          #
          # Get list of files to Copy into Home-Dirs
          COPY_FROM_SOURCE="${DIR_REPO_BASE}/root";
          FILES_TO_COPY=$(ls -hAl "${COPY_FROM_SOURCE}/" | awk '{print $9}';);
          # User-List whose Home-Dirs will be updated
          LINUX_BASH_USERS=$(cat /etc/passwd | grep /bin/bash | awk -F':' '{ print $1}';);
          # Determine longest Username to enhance log-readability by left-padding (right-aligning) output text, below
          #   NOTE: Linux usernames cannot be longer than 32 chars (according to useradd man page)
          USERNAMES_MOSTCHARS=0;
          for EACH_SSH_USER in ${LINUX_BASH_USERS}; do
            EACH_USERNAME_LENGTH=${#EACH_SSH_USER};
            if (( ${EACH_USERNAME_LENGTH} > ${USERNAMES_MOSTCHARS} )); then
              USERNAMES_MOSTCHARS=${EACH_USERNAME_LENGTH};
            fi;
          done;
          echo -e "\nInfo:  Syncing bash-config & terminal-formatting files for SSH enabled users...$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          # Begin copying files to SSH enabled users' home directories
          for EACH_FILE in ${FILES_TO_COPY}; do
            if [[ ! -z "${EACH_FILE// }" ]]; then # Ignore blank/empty filenames
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> \"~/${EACH_FILE}\""; fi;
              SRC_FULLPATH="${COPY_FROM_SOURCE}/${EACH_FILE}";
              for EACH_SSH_USER in ${LINUX_BASH_USERS}; do
                EACH_PRIMARY_GROUP="$(id -gn ${EACH_SSH_USER})";
                DIR_USER_HOME="$(eval echo ~${EACH_SSH_USER})";
                # Only copy files to SSH enabled users' home directories (plus root)
                if [[ -d "${DIR_USER_HOME}/.ssh" ]] || [[ -f "${DIR_USER_HOME}/.bash_history" ]] || [[ -f "/etc/ssh/authorized_keys/${EACH_SSH_USER}" ]] || [[ "${EACH_SSH_USER}" == "root" ]]; then
                  DEST_FULLPATH="${DIR_USER_HOME}/${EACH_FILE}";
                  if [[ -d "${SRC_FULLPATH}" ]] && [[ -f "${SRC_FULLPATH}/"* ]]; then
                    # Directories containing at least one file
                    dos2unix --quiet "${SRC_FULLPATH}/"*;
                    cp -rf "${SRC_FULLPATH}" "${DIR_USER_HOME}";
                    chown -R "${EACH_SSH_USER}:${EACH_PRIMARY_GROUP}" "${DEST_FULLPATH}";
                    chmod -R 600 "${DEST_FULLPATH}";
                    chmod 700 "${DEST_FULLPATH}";
                  else
                    # Files
                    dos2unix --quiet "${SRC_FULLPATH}";
                    cp -f "${SRC_FULLPATH}" "${DEST_FULLPATH}";
                    chown "${EACH_SSH_USER}:${EACH_PRIMARY_GROUP}" "${DEST_FULLPATH}";
                    chmod 600 "${DEST_FULLPATH}";
                  fi;
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then USERNAME_RPAD="  "$(printf '%-'${USERNAMES_MOSTCHARS}'s' "|----> ${EACH_SSH_USER}"); echo "${USERNAME_RPAD}:  [ ${DEST_FULLPATH} ]"; fi;
                fi;
              done;
            fi;
          done;
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------
          #
          # /etc/cron.d/CRON_ddns_updater
          #
          if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
            if [[ ${ARGS_SYNC_DDNS} -eq 1 ]]; then
              # Syncs the cronjob trigger to update a given DNS-Provider with current WAN IP
              CRON_UPDATE_DNS_A_RECORDS="/etc/cron.d/CRON_ddns_updater";
              echo -e "\nInfo:  Updating \"${CRON_UPDATE_DNS_A_RECORDS}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');

              /usr/local/bin/ddns_setup \
                && wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${CRON_UPDATE_DNS_A_RECORDS}" -O "/etc/cron.d/CRON_ddns_updater" -q \
                && chmod 0644 "/etc/cron.d/CRON_ddns_updater" \
                && RESTART_SERVICE_CRON=1;

              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------
          #
          # /etc/nginx
          #
          if [[ ${ARGS_SYNC_NGINX} -eq 1 ]]; then
            if [[ -z "$(command -v nginx 2>'/dev/null';)" ]]; then
              # NGINX does NOT exist locally
              echo -e "\nInfo:  Skipped NGINX config-sync - No local 'nginx' service exists";
            else
              # NGINX exists locally
              RESTART_SERVICE_NGINX=1;
              # ------------------------------
              #
              # /etc/nginx
              #
              DESTINATION_PATH="/etc/nginx"; if [[ ! -d "${DESTINATION_PATH}" ]]; then mkdir -p "${DESTINATION_PATH}"; fi;
              SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
              FILE_PERMS="0644"; DIR_PERMS="0755";
              echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
              rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
              chown -R "root:root" "${DESTINATION_PATH}";
              find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
              find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
              if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
              dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
              # ------------------------------
              #
              # /var/log/nginx
              #
              DESTINATION_PATH="/var/log/nginx"; if [[ ! -d "${DESTINATION_PATH}" ]]; then mkdir -p "${DESTINATION_PATH}"; fi;
              DIR_PERMS="755";
              NGINX_LOGS_USER="$(cat "/etc/nginx/nginx.conf" 2>'/dev/null' | sed -rne "s/^user\s+([a-zA-Z0-9_-]+);.*$/\1/pi";)";
              if [[ -d "${DESTINATION_PATH}" ]] && [[ -n "${NGINX_LOGS_USER}" ]]; then
                CURRENT_LOGS_USER="$(stat -c "%U" "${DESTINATION_PATH}";)";
                if [[ "${CURRENT_LOGS_USER}" != "${NGINX_LOGS_USER}" ]]; then
                  NGINX_LOGS_GROUP="$(getent passwd "${NGINX_LOGS_USER}" | cut -d':' -f5;)";
                  CURRENT_LOGS_GROUP="$(stat -c "%G" "${DESTINATION_PATH}";)";
                  echo -e "  |--> Updating \"${DESTINATION_PATH}\" user:group ownership to \"${NGINX_LOGS_USER}:${CURRENT_LOGS_GROUP:-${NGINX_LOGS_GROUP}}\"$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                  chown "${NGINX_LOGS_USER}:${CURRENT_LOGS_GROUP:-${NGINX_LOGS_GROUP}}" "${DESTINATION_PATH}";
                fi;
                CURRENT_LOGS_PERMS="$(stat -c "%a" "${DESTINATION_PATH}";)";
                if [[ "${CURRENT_LOGS_PERMS}" != "${DIR_PERMS}" ]]; then
                  echo -e "  |--> Updating \"${DESTINATION_PATH}\" file mode (access) permissions to \"${DIR_PERMS}\"$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                  chmod "${DIR_PERMS}" "${DESTINATION_PATH}";
                fi;
              fi;
              # ------------------------------
              #
              # /var/www/error
              #
              DESTINATION_PATH="/var/www/error"; if [[ ! -d "${DESTINATION_PATH}" ]]; then mkdir -p "${DESTINATION_PATH}"; fi;
              SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
              FILE_PERMS="0644"; DIR_PERMS="0755";
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then  echo -e "  |--> Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)"; fi;
              BENCHMARK_START=$(date +'%s.%N');
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |--> Debug:  Calling [ rsync --archive --inplace --checksum --quiet --exclude=\".gitkeep\" \"${SOURCE_PATH}\" \"${DESTINATION_PATH}\"; ]..."; fi;
              rsync --archive --inplace --checksum --quiet --exclude=".gitkeep" "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
              chown -R "root:root" "${DESTINATION_PATH}";
              find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
              find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
              if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
              dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
              # Check if running on Fedora
              if [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
                # Selinux - Whitelist/allow read actions on a specific file/directory filepath (otherwise Selinux (by-default) will prevent read requests on said filepath(s) for the local web service user (commonly 'wwww-data') and therefore fail web requests to servers hosted from this device
                chcon -Rt httpd_sys_content_t "${DESTINATION_PATH}";
              fi;
              # Ensure that the Diffie-Hellman parameter for DHE ciphersuites exists
              DH_PARAM_FILEPATH="/etc/ssl/certs/dhparam.pem";
              DH_ENCRYPTION_BIT_STRENGTH=2048; # 2048 / 3072 / 4096 <-- Do not go lower than 2048 (as-of late 2019)
              if [[ ! -f "${DH_PARAM_FILEPATH}" ]]; then
                echo "  |--> Creating Diffie-Hellman Parameters File @ \"${DH_PARAM_FILEPATH}\"...";
                openssl dhparam -out "${DH_PARAM_FILEPATH}" ${DH_ENCRYPTION_BIT_STRENGTH};
              fi;
              # Set the environment-specific web-server runtime user
              if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
                sed -i 's|user www-data;|user www-data;|g' "/etc/nginx/nginx.conf";
              elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
                sed -i 's|user www-data;|user nginx;|g' "/etc/nginx/nginx.conf";
              fi;
              # Walk through all sites-available (from repo), resolve their WAN IPv4 address & compare it against the WAN IPv4 address of the current device - only sync if the two IPv4 addresses are a direct match
              find "/etc/nginx/sites-available/" -mindepth 1 -maxdepth 1 -name "*.nginx" -type "f" -print0 | while IFS= read -r -d $'\0' Each_SitesAvailable; do
                Each_FQDN=$(echo "$(basename ${Each_SitesAvailable})" | rev | cut -d. -f 1 --complement | rev);
                Each_SitesEnabled="/etc/nginx/sites-enabled/${Each_FQDN}";
                if [[ "$(dig +short ${Each_FQDN};)" == "$(curl -s -4 https://icanhazip.com;)" ]] || [[ "$(dig +short ${Each_FQDN};)" == "$(hostname --all-ip-addresses | tr ' ' '\n' | grep -v ':' | grep -v '^$' | head -n 1;)" ]]; then
                  # The FQDN resolved to an IPv4 which matches the WAN IPv4 address of the current device
                  #  |--> Set this FQDN to "Enabled" for the current NGINX server
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |\n  |--> $(if [[ -e "${Each_SitesEnabled}" ]]; then echo "Updating"; else echo "Enabling"; fi;) NGINX FQDN \"${Each_FQDN}\" via file \"${Each_SitesEnabled}\"\n  |--> Debug:  Exact match found between [ the resolved WAN IPv4 address for target FQDN \"${Each_FQDN}\" ] and [ the resolved WAN IPv4 address of the current device ]"; fi;
                  ln -sf "${Each_SitesAvailable}" "${Each_SitesEnabled}";
                elif [[ "${Each_FQDN}" == "$(hostname --fqdn;)" ]] && [[ "$(dig +short ${Each_FQDN};)" == "$(hostname --all-ip-addresses | tr ' ' '\n' | grep -v ':' | grep -v '^$' | head -n 1;)" ]]; then
                  # The FQDN is equal to the hostname (as a FQDN) for the current device and the WAN IPv4 address of the hostname resolved to this device's IPv4 address, as well
                  #  |--> Set this FQDN to "Enabled" for the current NGINX server
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |\n  |--> $(if [[ -e "${Each_SitesEnabled}" ]]; then echo "Updating"; else echo "Enabling"; fi;) NGINX FQDN \"${Each_FQDN}\" via file \"${Each_SitesEnabled}\"\n  |--> Debug:  Exact match found between [ the target FQDN \"${Each_FQDN}\" ] and [ the hostname (formatted as a FQDN) of the current device ]"; fi;
                  ln -sf "${Each_SitesAvailable}" "${Each_SitesEnabled}";
                else
                  # Skipped - The FQDN doesnt match the hostname or IPv4 address of the current device
                  rm -f "${Each_SitesAvailable}";
                  if [[ -h "${Each_SitesEnabled}" ]] || [[ -f "${Each_SitesEnabled}" ]]; then
                    # If this NGINX site (FQDN) is enabled (but should be disabled as no matches were found between it and the current device), then disable it
                    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |\n  |--> Disabling NGINX FQDN \"${Each_FQDN}\" (removing/unlinking \"${Each_SitesEnabled}\")\n  |--> Debug:  No match found between [ the resolved WAN IPv4 address for target FQDN \"${Each_FQDN}\" ] and [ the resolved WAN IPv4 address of the current device ]\n  |--> Debug:  No match found between [ the target FQDN \"${Each_FQDN}\" ] and [ the hostname (formatted as a FQDN) of the current device ]"; fi;
                    if [[ -h "${Each_SitesEnabled}" ]]; then
                      unlink "${Each_SitesEnabled}";
                    elif [[ -f "${Each_SitesEnabled}" ]]; then
                      rm -f "${Each_SitesEnabled}";
                    fi;
                  fi;
                fi;
              done;
              # Setup certbot to reload NGINX whenever a Let's Encrypt HTTPS certificate is renewed via certbot
              if [[ -d "/etc/letsencrypt/renewal-hooks/deploy" ]] && [[ ! -e "/etc/letsencrypt/renewal-hooks/deploy/reload_nginx" ]] && [[ -f "/usr/local/sbin/reload_nginx" ]]; then
                ln --symbolic --verbose --force "/usr/local/sbin/reload_nginx" "/etc/letsencrypt/renewal-hooks/deploy/reload_nginx";
              fi;
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';); echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------
          #
          # /etc/cron.d/CRON_*
          #
          if [[ ${ARGS_CRONJOB_REMOVE} -eq 1 ]]; then
            #
            # --remove-cronjobs  -->  Removes all scripts matching /etc/cron.d/CRON_*  (other than CRON_sync_cloud_infrastructure, which triggers this, current script)
            #
            LOCAL_CRON_D_SCRIPTS=$(ls /etc/cron.d/CRON_* | grep -v "$(basename "${SYNC_CI_LOCAL}";)" 2>'/dev/null';);
            COUNT_CRON_D_SCRIPTS=$(echo "${LOCAL_CRON_D_SCRIPTS}" | wc -l;);
            if [[ $(echo "${LOCAL_CRON_D_SCRIPTS}" | wc -l) -eq 0 ]]; then
              echo -e "\nInfo:  Skipped removal of cron sync-triggers - No scripts found matching \"/etc/cron.d/CRON_*\"";
            else
              echo -e "\nInfo:  Found ${COUNT_CRON_D_SCRIPTS} cron sync-triggers matching \"/etc/cron.d/CRON_*\":";
              for EACH_CRON_TRIGGER in ${LOCAL_CRON_D_SCRIPTS}; do
                echo "  |";
                REPLY="";
                echo -n "  |--> Are you sure you want to remove cron sync trigger '${EACH_CRON_TRIGGER}'?  (press 'y' to confirm)  ";
                read -p "" -n 1 -t ${READ_TIMEOUT} REPLY <'/dev/tty'; # Await single keypress
                echo "";
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  echo "  |----> Confirmed - Removing cron sync trigger '${EACH_CRON_TRIGGER}'...";
                  rm -f "${EACH_CRON_TRIGGER}";
                else
                  echo "  |----> Skipped/Denied - Leaving cron sync trigger '${EACH_CRON_TRIGGER}' unchanged";
                fi;
              done;
            fi;
          fi;

          # ------------------------------
          #
          # Remove deprecated files/symlinks
          #

          DELDIR="/usr/local/bin/";
            TO_DEL="${DELDIR}/docker_check_installation_status"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/docker_list_volume_maps.sh"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/get_enabled_services"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
            TO_DEL="${DELDIR}/get_lan_ipv4"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/get_open_ports"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/get_port_available_on_localhost"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
            TO_DEL="${DELDIR}/get_ports_open_on_host"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
            TO_DEL="${DELDIR}/get_services"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
            TO_DEL="${DELDIR}/get_unused_local_port"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/get_wan_ip"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/get_wan_ipv4"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/port_sniffer"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/pvk.exe"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/pvk2pfx.exe"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/raspi_stress_test"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/wsl_get_windows_username"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;

          DELDIR="/usr/local/sbin/";
            TO_DEL="${DELDIR}/disable_mail_alerts"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/install_devops_packages"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/install_minio_mc"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/install_mongod"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/install_utilities"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/install_vmware-tools"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/jenkins-config-export"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/jenkins_war_update"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/sudoer_edit"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/sync_Cloud_infrastructure"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2020-01-06
            TO_DEL="${DELDIR}/sync_config_gpg_git"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/sync_gpg_git_config"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
            TO_DEL="${DELDIR}/sync_upd"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/update_bins_from_sftp"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
            TO_DEL="${DELDIR}/wsl_conf"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20191220-164752
            TO_DEL="${DELDIR}/wsl_reboot"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20191220-164752
            TO_DEL="${DELDIR}/wsl_vpn_hotfix"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20191220-164752

          DELDIR="/etc/ddns_ufw_update";
            if [[ -d "${DELDIR}" ]]; then rm -rf "${DELDIR}" fi; # Added 20200115-223014 - Moved to /etc/whitelist.d

          DELDIR="/etc/nginx/conf.ddns";
            TO_DEL="${DELDIR}/rz.mcavallo.com"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200115-224618
            TO_DEL="${DELDIR}/x1.mcavallo.com"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200115-224620

          DELDIR="/etc/nginx/conf.vendor";
            TO_DEL="${DELDIR}/LAN_subnets.conf"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-192658

          DELDIR="/var/cache/jenkins/war";
            TO_DEL="${DELDIR}/Jenkins Artwork (jenkins.io).url"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456
            TO_DEL="${DELDIR}/Jenkins Material Theme (GitHub).url"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456

          DELDIR="/var/www/error/css";
            TO_DEL="${DELDIR}/error_animation_once.gif"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456
            TO_DEL="${DELDIR}/error_stylesheet.css"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456
            TO_DEL="${DELDIR}/f4109k-27.jpg"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456
            TO_DEL="${DELDIR}/wave75.gif"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456

          # ------------------------------
          #
          # cron  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_CRON} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            CRON_SVC_FOUND=0; CRON_SVC_NAMES="";
            # cron  -->  Restart service
            SERVICE_NAME="cron";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo ${?};);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              CRON_SVC_FOUND=$((${CRON_SVC_FOUND}+1));
              CRON_SVC_NAMES="${SERVICE_NAME}";
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            fi;
            # crond  -->  Restart service
            SERVICE_NAME="crond";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo ${?};);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              CRON_SVC_FOUND=$((${CRON_SVC_FOUND}+1));
              CRON_SVC_NAMES="${SERVICE_NAME}";
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            fi;
            if [[ ${CRON_SVC_FOUND} -eq 0 ]]; then
              echo "Skipped restart of the \"${CRON_SVC_NAMES}\" service(s) (not found as a local service)";
            fi;
          fi;

          # ------------------------------
          #
          # jenkins  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_JENKINS} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="jenkins";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo ${?};);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;

          # ------------------------------
          #
          # nginx  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_NGINX} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="nginx";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo ${?};);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              eval " /usr/local/sbin/reload_nginx";
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;

          # ------------------------------
          #
          # ssh  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_SSH} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="sshd";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo ${?};);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;

          # ------------------------------
          #
          # ufw  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_UFW} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="ufw";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo ${?};);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/sbin/service "${SERVICE_NAME}" restart;
              if [[ -n "$(command -v ${SERVICE_NAME} 2>'/dev/null';)" ]]; then
                ufw reload;
              fi;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;

          # ------------------------------

        elif [[ "${UPDATE_SELF_REQUIRED}" -eq 1 ]]; then

          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  'Elif' main statement block - Skipped main 'If' in favor of recursive call handling it (UPDATE_SELF_REQUIRED=[${UPDATE_SELF_REQUIRED}])  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;

        elif [[ -n "${EXIT_CODE}" ]] && [[ "${EXIT_CODE}" != "0" ]]; then

          echo -e "\nError:  One or more errors were found (EXIT_CODE=[${EXIT_CODE}])  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";

        else

          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  'Else' statement placeholder (to-be-updated) (EXIT_CODE=[${EXIT_CODE}])  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;

        fi;

      fi;

      # ------------------------------
      #
      # Cleanup log files outside of the retention policy's max-age
      #
      LOGDIR="${LOGDIR:-/var/log/sync_cloud_infrastructure}";
      RETENTION_DAYS=60;
      if [[ -d "${LOGDIR}" ]] && [[ "$(find "${LOGDIR}" -type f -mtime +${RETENTION_DAYS} | wc -l;)" -gt 0 ]]; then
        echo "";
        echo "Info:  Cleaning logs older than [ ${RETENTION_DAYS} days old ] from directory \"${LOGDIR}\"";
        find "${LOGDIR}" -type f -mtime +${RETENTION_DAYS} -exec rm -- '{}' \;;
      fi;
      # ------------------------------

    fi;

  fi;

fi;


# ------------------------------
#
# Log the ending timestamp for the current runtime
#

END_SECONDS_NANOSECONDS="$(date +'%s.%N';)";
END_EPOCHSECONDS="$(echo ${END_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 1;)";
END_NANOSECONDS=$(echo ${END_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 2 | cut --characters 1-9;);
END_MICROSECONDS=$(echo ${END_NANOSECONDS} | cut --characters 1-6;);
END_DATETIME="$(date --date=@${END_EPOCHSECONDS} +'%Y-%m-%d %H:%M:%S';)";
END_BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${START_SECONDS_NANOSECONDS})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
  echo "";
  echo "Debug:  END_SECONDS_NANOSECONDS = [ ${END_SECONDS_NANOSECONDS} ]";
  echo "Debug:  END_EPOCHSECONDS = [ ${END_EPOCHSECONDS} ]";
  echo "Debug:  END_DATETIME = [ ${END_DATETIME} ]";
  echo "Debug:  END_BENCHMARK_DELTA = [ ${END_BENCHMARK_DELTA} ]";
fi;

echo "";
echo "== Info:  End of $(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo "recursive "; fi;)\"$(basename "${SYNC_CI_LOCAL}";)\" runtime $(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "at [ ${END_DATETIME}.${END_MICROSECONDS}$(date +'%z';) ] after [ ${END_BENCHMARK_DELTA}s ] "; fi;) (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";

# ------------------------------
#
# Exit & return the value of EXIT_CODE back to caller
#

# if [[ ${ARGS_SKIP_SELF_UPDATE:-0} -eq 0 ]]; then
#   if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  Calling [ exit ${EXIT_CODE:-0}; ]...  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;
#   exit ${EXIT_CODE:-0};
# fi;


# ------------------------------
#
# Recursive Callback - Trigger
#

echo -e -n "${RECURSIVE_CALLBACK_ECHO}";

# if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "Debug:  Calling [ eval \" ${RECURSIVE_CALLBACK_COMMAND}\"; ]..."; fi;

# eval " ${RECURSIVE_CALLBACK_COMMAND}"

if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "Debug:  Calling [ eval \" ${RECURSIVE_CALLBACK_COMMAND}\" & ]..."; fi;

eval " ${RECURSIVE_CALLBACK_COMMAND}" &

