#!/bin/bash
#
# LOCAL_SBIN="/usr/local/sbin/ddns_ufw_update" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------------------------------------
# Run in Debug mode
#
if [ 0 -eq 1 ]; then

env DEBUG_MODE=1 "/usr/local/sbin/ddns_ufw_update";

fi;
#
# ------------------------------------------------------------
#
# Log all shell output & error output to logfile
#
LOGDIR="${HOME}/$(basename ${0})_logs"; if [ -w "/var/log/" ]; then LOGDIR="/var/log/$(basename ${0})"; fi;
mkdir -p "${LOGDIR}"; chown $(stat -c '%u:%g' $(dirname ${LOGDIR})) "${LOGDIR}"; chmod 0770 "${LOGDIR}";
LOGFILE="${LOGDIR}/$(basename ${LOGDIR})_$(date +'%Y%m%d_%H%M%S')"; echo "" > "${LOGFILE}"; chmod 0660 "${LOGFILE}";
exec > >(tee -a "${LOGFILE}" );
exec 2>&1;
#
# ------------------------------------------------------------
#
# Script must run as root or via sudo
#
if [ "$(id -un)" != "root" ]; then
	echo "";
	echo "$(date +'%Y-%m-%d %H:%M:%S') | Error: Script must run as user \"root\" or via \"sudo\" command";
	exit 1;
else
	# ------------------------------------------------------------
	# Declare runtime variable(s)
	
	# Determine if running in debug-mode (increases verbosity-level of script's output, e.g. shows all info/notices/details/etc. and not just warnings/errors)
	if [ -n "${DEBUG_MODE}" ] && [[ "${DEBUG_MODE}" =~ ^-?[0-9]+$ ]] && (("${DEBUG_MODE}" >= "1")); then
		DEBUG_MODE=1;
	elif [ -n "${VERBOSITY}" ] && [[ "${VERBOSITY}" =~ ^-?[0-9]+$ ]] && (("${VERBOSITY}" >= "1")); then
		DEBUG_MODE=1;
	elif [ -n "${VERBOSE}" ] && [[ "${VERBOSE}" =~ ^-?[0-9]+$ ]] && (("${VERBOSE}" >= "1")); then
		DEBUG_MODE=1;
	else
		DEBUG_MODE=0;
	fi;

	DIRNAME_LOCAL_CONFIG="/etc/ddns_ufw_update";
	mkdir -p "${DIRNAME_LOCAL_CONFIG}";

	# File containing hosts to allow through UFW
	#  |--> All lines in given whitelist file must be in a specific format/syntax
	#        |
	#        |--> Syntax:    tcp/udp:PORT:SUBDOMAIN.DOMAIN.TLD
	#        |--> Example:   tcp:22:demo.example.com
	#
	if [ -v RUNTIME_SERVICE_USERS ]; then unset RUNTIME_SERVICE_USERS; fi; # Re-instantiate bash array (if-set) via unset + declare
	if [ -v RUNTIME_SERVICE_USERS[@] ]; then unset RUNTIME_SERVICE_USERS; fi; # Re-instantiate bash array (if-set) via unset + declare
	declare -A RUNTIME_SERVICE_USERS;
	RUNTIME_SERVICE_USERS+=(["sshd"]="root");
	RUNTIME_SERVICE_USERS+=(["nginx"]="www-data");
	RUNTIME_SERVICE_USERS+=(["jenkins"]="jenkins");

	# Defaults for UFW (out-of-the-box)
	UFW_OUT_OF_THE_BOX_DEFAULTS="Default: deny (incoming), allow (outgoing), disabled (routed)";

	# Config pulled-in by UFW (sets default values to block/allow/etc. and more)
	UFW_CONFIG_FILEPATH="/etc/default/ufw";

	# ------------------------------------------------------------
	# Function to add a rule to UFW
	add_rule() {
		local proto=$1;
		local port=$2;
		local ip=$3;
		local regex="${port}\/${proto}.*ALLOW.*IN.*${ip}";
		local rule=$(/usr/sbin/ufw status numbered | grep ${regex});

		if [ ${DEBUG_MODE} -eq 1 ]; then
			echo "Debug: -> IN FUNCTION [ add_rule()  ]";
			echo "Debug: -> proto = [ ${proto} ]";
			echo "Debug: -> port = [ ${port} ]";
			echo "Debug: -> ip = [ ${ip} ]";
			echo "Debug: -> regex = [ ${regex} ]";
			echo "Debug: -> rule = [ ${rule} ]";
		fi;

		# If rule doesn't exist, then add (allow) it to UFW's ruleset
		if [ -z "${rule}" ]; then
			echo -e "\n""Info: Deleting rule [ ${proto}/${port} ALLOW IN ${ip} ]";
			echo "  |--> Time: [ $(date +'%Y-%m-%d %H:%M:%S') ]";
			echo "  |--> Call: [ /usr/sbin/ufw allow proto ${proto} from ${ip} to any port ${port}; ]";
			/usr/sbin/ufw allow proto ${proto} from ${ip} to any port ${port};
		else
			if [ ${DEBUG_MODE} -eq 1 ]; then
				echo "Debug: Rule already exists for [ ${proto}/${port} ALLOW IN ${ip} ]";
				echo "  |--> Time: [ $(date +'%Y-%m-%d %H:%M:%S') ]";
			fi;
		fi;
	}


	# ------------------------------------------------------------
	# Function to delete a rule from UFW
	delete_rule() {
		local proto=$1;
		local port=$2;
		local ip=$3;
		local regex="${WHITELIST_PORT}\/${proto}.*ALLOW.*IN.*${ip}";
		local rule=$(ufw status numbered | grep ${regex});

		if [ ${DEBUG_MODE} -eq 1 ]; then
			echo "Debug: -> IN FUNCTION [ delete_rule()  ]";
			echo "Debug: -> proto = [ ${proto} ]";
			echo "Debug: -> port = [ ${port} ]";
			echo "Debug: -> ip = [ ${ip} ]";
			echo "Debug: -> regex = [ ${regex} ]";
			echo "Debug: -> rule = [ ${rule} ]";
		fi;

		# If rule exists, then remove (delete) it from UFW's ruleset
		if [ -n "${rule}" ]; then
			echo -e "\n""Info: Deleting rule [ ${proto}/${port} ALLOW IN ${ip} ]";
			echo "  |--> Time: [ $(date +'%Y-%m-%d %H:%M:%S') ]";
			echo "  |--> Call: [ /usr/sbin/ufw delete allow proto ${proto} from ${ip} to any port ${port}; ]...";
			/usr/sbin/ufw delete allow proto ${proto} from ${ip} to any port ${port};
			# ex) /usr/sbin/ufw allow proto tcp from any to any port 80,443

		else
			if [ ${DEBUG_MODE} -eq 1 ]; then
				echo "Debug: Skipped delete (No rule found to delete): ${proto}/${port} ALLOW IN ${ip}";
				echo "  |--> Time: [ $(date +'%Y-%m-%d %H:%M:%S') ]";
			fi;

		fi;
	}


	# ------------------------------------------------------------
	# Main Runtime
	#
	
	# Set UFW Defaults --> Incoming Requests
	CURRENT_DEFAULT_INPUT_POLICY=$(sed --regexp-extended --quiet --expression='s/^DEFAULT_INPUT_POLICY="(.+)"$/\1/p' "${UFW_CONFIG_FILEPATH}";);
	DESIRED_DEFAULT_INPUT_POLICY="DROP";
	if [ "${CURRENT_DEFAULT_INPUT_POLICY}" != "${DESIRED_DEFAULT_INPUT_POLICY}" ]; then
		/usr/sbin/ufw default deny incoming;  # DEFAULT_INPUT_POLICY="DROP"
		# sed --in-place --regexp-extended --expression="/^DEFAULT_INPUT_POLICY/c\DEFAULT_INPUT_POLICY=\"${DESIRED_DEFAULT_INPUT_POLICY}\"" "${UFW_CONFIG_FILEPATH}";
	fi;

	# Set UFW Defaults --> Outgoing Requests
	CURRENT_DEFAULT_OUTPUT_POLICY=$(sed --regexp-extended --quiet --expression='s/^DEFAULT_OUTPUT_POLICY="(.+)"$/\1/p' "${UFW_CONFIG_FILEPATH}";);
	DESIRED_DEFAULT_OUTPUT_POLICY="ACCEPT";
	if [ "${CURRENT_DEFAULT_INPUT_POLICY}" != "${DESIRED_DEFAULT_OUTPUT_POLICY}" ]; then
		/usr/sbin/ufw default allow outgoing;  # DEFAULT_OUTPUT_POLICY="ACCEPT"
		# sed --in-place --regexp-extended --expression="/^DEFAULT_OUTPUT_POLICY/c\DEFAULT_OUTPUT_POLICY=\"${DESIRED_DEFAULT_OUTPUT_POLICY}\"" "${UFW_CONFIG_FILEPATH}";
	fi;

	# Set UFW Defaults --> ROuted Requests
	CURRENT_DEFAULT_APPLICATION_POLICY=$(sed --regexp-extended --quiet --expression='s/^DEFAULT_APPLICATION_POLICY="(.+)"$/\1/p' "${UFW_CONFIG_FILEPATH}";);
	DESIRED_DEFAULT_APPLICATION_POLICY="SKIP";
	if [ "${CURRENT_DEFAULT_INPUT_POLICY}" != "${DESIRED_DEFAULT_INPUT_POLICY}" ]; then
		# /usr/sbin/ufw default skip routed;
		sed --in-place --regexp-extended --expression="/^DEFAULT_APPLICATION_POLICY/c\DEFAULT_APPLICATION_POLICY=\"${DESIRED_DEFAULT_APPLICATION_POLICY}\"" "${UFW_CONFIG_FILEPATH}";
	fi;

	# ------------------------------------------------------------
	# Whitelisting by-Service
	#
	for EACH_SERVICE in "${!RUNTIME_SERVICE_USERS[@]}"; do
		# File containing hosts to allow through UFW
		#  |--> All lines in given whitelist file must be in a specific format/syntax
		#        |
		#        |--> Syntax:    tcp/udp:PORT:SUBDOMAIN.DOMAIN.TLD
		#        |--> Example:   tcp:22:demo.example.com
		#
		EACH_SERVICE_RUNTIME_USER="${RUNTIME_SERVICE_USERS[${EACH_SERVICE}]}";

		# Only whitelist services which are found to exist, locally
		pgrep -u jenkins java
		SERVICE_PROCESSES=$(ps --format "pid,fname,user,%cpu,%mem,maj_flt,cmd" --no-headers -C "${EACH_SERVICE}" | wc -l;);
		if [ ${SERVICE_PROCESSES} -eq 0 ]; then
			# Service does NOT exist locally - do NOT whitelist associated ports/hosts
			echo -e "\n""Info: Skipping UFW (Firewall) Whitelisting for \"${EACH_SERVICE}\" Service (not found locally)";

		else
			# Service DOES exist locally - DO whitelist associated ports/hosts
			EACH_HOSTS_FILE="${DIRNAME_LOCAL_CONFIG}/whitelist-${EACH_SERVICE}.hosts";
			echo -e "\n""Info: Applying UFW (Firewall) Whitelisting for \"${EACH_SERVICE}\" Service";
			echo "  |-> Using whitelist-file \"${EACH_HOSTS_FILE}\"";

			# Iterate-over each line in the whitelist-file
			sed '/^[[:space:]]*$/d' ${EACH_HOSTS_FILE} | sed '/^[[:space:]]*#/d' | while read EACH_WHITELIST_LINE;	do
				if [ -n "${EACH_WHITELIST_LINE}" ]; then

					# Define the location of the file to output resolved ipv4's to
					EACH_RESOLVED_FILE="${EACH_HOSTS_FILE}.resolved";
					if [ ! -f "${EACH_RESOLVED_FILE}" ]; then
						echo -n "" > "${EACH_RESOLVED_FILE}";
					fi;

					if [ ${DEBUG_MODE} -eq 1 ]; then
						echo -e "\n""------------------------------------------------------------";
					fi;

					WHITELIST_PROTOCOL=$(echo ${EACH_WHITELIST_LINE} | cut -d: -f1);
					WHITELIST_PORT=$(echo ${EACH_WHITELIST_LINE} | cut -d: -f2);
					WHITELIST_HOST=$(echo ${EACH_WHITELIST_LINE} | cut -d: -f3);

					if [ ${DEBUG_MODE} -eq 1 ]; then
						echo "Debug: EACH_WHITELIST_LINE = [ ${EACH_WHITELIST_LINE} ]";
						echo "Debug: WHITELIST_PROTOCOL = [ ${WHITELIST_PROTOCOL} ]";
						echo "Debug: WHITELIST_PORT = [ ${WHITELIST_PORT} ]";
						echo "Debug: WHITELIST_HOST = [ ${WHITELIST_HOST} ]";
					fi;

					CURRENT_RESOLVED_IPv4="";
					OLD_RESOLVED_IPV4="";
					if [ "$(echo ${WHITELIST_HOST} | tr '[:upper:]' '[:lower:]';)" == "any" ]; then
						# Allow "Any" host to be used
						CURRENT_RESOLVED_IPv4="any";
					else
						# Determine current & previous IPv4(s) for each hostname
						CURRENT_RESOLVED_IPv4=$(dig +short ${WHITELIST_HOST} | tail -n 1);
						OLD_RESOLVED_IPV4=$(cat ${EACH_RESOLVED_FILE} | grep ${WHITELIST_HOST} | cut -d: -f2);
						# Remove old IPv4 rule(s)
						if [ -z ${CURRENT_RESOLVED_IPv4} ]; then
							if [ -n "${OLD_RESOLVED_IPV4}" ]; then
								delete_rule ${WHITELIST_PROTOCOL} ${WHITELIST_PORT} ${OLD_RESOLVED_IPV4};
							fi;
							echo "$(date +'%Y-%m-%d %H:%M:%S') Error: Hostname resolution failed for \"${WHITELIST_HOST}\" (could not be converted to an IPv4/IPv6 address)" 1>&2;
							# exit 1;
						fi;
						# Remove old whitelist-rule(s)
						if [ -n "${OLD_RESOLVED_IPV4}" ]; then
							if [ ${CURRENT_RESOLVED_IPv4} != ${OLD_RESOLVED_IPV4} ]; then
								delete_rule ${WHITELIST_PROTOCOL} ${WHITELIST_PORT} ${OLD_RESOLVED_IPV4};
							fi;
						fi;
					fi;

					if [ ${DEBUG_MODE} -eq 1 ]; then
						echo "Debug: CURRENT_RESOLVED_IPv4 = [ ${CURRENT_RESOLVED_IPv4} ]";
						echo "Debug: OLD_RESOLVED_IPV4 = [ ${OLD_RESOLVED_IPV4} ]";
					fi;

					add_rule ${WHITELIST_PROTOCOL} ${WHITELIST_PORT} ${CURRENT_RESOLVED_IPv4};

					if [ -f ${EACH_RESOLVED_FILE} ]; then
						sed -i.bak /^${WHITELIST_HOST}*/d ${EACH_RESOLVED_FILE};
					fi;

					echo "${WHITELIST_HOST}:${CURRENT_RESOLVED_IPv4}" >> ${EACH_RESOLVED_FILE};

				fi;
			done;

		fi;

	done;


	# ------------------------------------------------------------
	# Set ownership & privileges for the logging directory & sub-contents
	chown -R "syslog:adm" "${LOGDIR}";
	find "${LOGDIR}" -type d -print0 | xargs -0 chmod 0750; # directories 
	find "${LOGDIR}" -type f -print0 | xargs -0 chmod 0640; # files

	# ------------------------------------------------------------
	# Cleanup log files outside of the retention-policy's max-age
	# ------------------------------------------------------------
	DIRECTORY_TO_CLEAN="${LOGDIR}/";
	MAX_RETENTION_DAYS=3;
	if [ -d "${DIRECTORY_TO_CLEAN}" ]; then
		find ${DIRECTORY_TO_CLEAN} -type f -mtime +${MAX_RETENTION_DAYS} -exec rm -- "{}" ";";
	fi;

fi;


# ------------------------------------------------------------
#
#### Setting up this file can be done via:
#
#		vi "/usr/local/sbin/ddns_ufw_update";
#
#		chmod 0755 "/usr/local/sbin/ddns_ufw_update";
#
#
#
#### The content of "/etc/ddns_ufw_update.whitelist" should match the format:
#	
#		vi "/etc/ddns_ufw_update.whitelist";
#
#		tcp:22:yourpc.no-ip.org
#
#
#
#### Shortcuts to this script, whitelist, and logfile-directory can be set via:
#	
#		mkdir -p "/root/ddns_ufw_update";
#		chmod 0700 "/root/ddns_ufw_update";
#		ln -sf "/etc/ddns_ufw_update.whitelist" "/root/ddns_ufw_update/whitelist";
#		ln -sf "/usr/local/sbin/ddns_ufw_update" "/root/ddns_ufw_update/runtime";
#		ln -sf "/var/log/ddns_ufw_update" "/root/ddns_ufw_update/logs";
#
#
#
#### A crontab entry for executing the script every 3 minutes could look like this:
#
#		crontab -e
#
#		*/3 * * * * sudo "ddns_ufw_update"
#
#
#
# ------------------------------------------------------------
#
# Citation(s)
#
#		Thanks to stackoverflow user "Force" on forum: https://superuser.com/questions/646958/ufw-rules-for-specific-host-dynamic-dns
#		Original script from https://notepad2.blogspot.com/2012/06/shell-script-update-ufw-rules-for-hosts.html
#
# ------------------------------------------------------------