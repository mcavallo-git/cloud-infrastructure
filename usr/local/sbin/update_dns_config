#!/bin/bash
#
# LOCAL_SBIN="/usr/local/sbin/update_dns_config" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------------------------------------
#
# Log all shell output & error output to logfile
#
LOGDIR="${HOME}/$(basename ${0})_logs"; if [ -w "/var/log/" ]; then LOGDIR="/var/log/$(basename ${0})"; fi;
mkdir -p "${LOGDIR}"; chown $(stat -c '%u:%g' $(dirname ${LOGDIR})) "${LOGDIR}"; chmod 0770 "${LOGDIR}";
LOGFILE="${LOGDIR}/$(basename ${LOGDIR})_$(date +'%Y%m%d_%H%M%S')"; echo -n "" > "${LOGFILE}"; chmod 0660 "${LOGFILE}";
exec > >(tee -a "${LOGFILE}" );
exec 2>&1;
#
# ------------------------------------------------------------
#
# Script must run as root or via sudo
#
if [ "$(id -un)" != "root" ]; then
	echo -e "\n""$(date +'%Y-%m-%d %H:%M:%S') | Error: Script must run as user \"root\" or via \"sudo\" command";
	exit 1;
else

	# ------------------------------------------------------------
	# Parse inline arguments (passed to current script)
	#

	ARGS=("$@");
	COUNT_ARGS=${#ARGS[@]};
	ARGS_HOSTNAME_DEFINED=0;
	USE_WAN_IPV4=0;
	USE_STATIC_IPV4=0;
	DRY_RUN=1;
	# Walk through any inline-arguments passed to this function
	for (( i=0;i<$COUNT_ARGS;i++ )); do

		EACH_ARG=${ARGS[${i}]};
		# BASH_ARG_NUMBER=$((${i}+1)); # Bash arg-number is one greater than the ARGS arg-number -> this is due-to bash's ${0} arg, which contains the base-command

		# Check if this is the last inline-argument or if there are more to follow
		if [ $((${i}+1)) -eq ${COUNT_ARGS} ]; then # if this is the last argument
			NEXT_ARG="";
		else
			NEXT_ARG=${ARGS[$((${i}+1))]};
			if [[ "${NEXT_ARG}" == "--"* ]]; then # Do not allow inline-arguments starting with "--..." to use the next bash-argument as an associated value if it, also, starts with "--..."
				NEXT_ARG="";
			fi;
		fi;

		if [ -n "${EACH_ARG}" ]; then # Parse each non-empty inline argument

			# Parse inline hostname
			if [ ${i} -eq 0 ] && [ -n "${EACH_ARG}" ] && [[ "${EACH_ARG}" != "-"* ]]; then # Allow the first argument to be the hostname (without needing --hostname before it)
				NEXT_ARG="${EACH_ARG}";
				EACH_ARG="--hostname";
			fi;

			if [ "${EACH_ARG}" == "--wan" ]; then # --force
				USE_WAN_IPV4=1;
			fi;

			# Parse static-IP calls
			if [ "${EACH_ARG}" == "--static-ip" ]; then
				USE_STATIC_IPV4=1;
				if [ -n "${NEXT_ARG}" ]; then
					SET_STATIC_IPV4="${NEXT_ARG}";
				fi;
			fi;

		fi;
	done;

	# ------------------------------------------------------------

	if [ $(which nmcli 2>'/dev/null' | wc -l;) -gt 0 ]; then
		#
		# Prioritize DHCP DNS Nameservers from nmcli (NetworkManager), where available
		#
		DNSV4_SERVERS=$(nmcli device show | grep 'IP4.DNS' | awk '{print $2}');
		if [ -n "${DNSV4_SERVERS}" ]; then
			for EACH_DNSV4_SERVER in ${DNSV4_SERVERS}; do
				if [ -z "${DHCP_NAMESRVR_1}" ]; then
					DHCP_NAMESRVR_1="${EACH_DNSV4_SERVER}"; # Set primary DNS Server
				elif [ -z "${DHCP_NAMESRVR_2}" ]; then
					DHCP_NAMESRVR_2="${EACH_DNSV4_SERVER}"; # Set secondary DNS Server
				elif [ -z "${DHCP_NAMESRVR_3}" ]; then
					DHCP_NAMESRVR_3="${EACH_DNSV4_SERVER}"; # Set tertiary DNS Server
				fi;
			done;
		fi;
	fi;

	# ------------------------------------------------------------
	#
	#		DNS SERVER OPTIONS
	#

	GOOGLE_DNS_1="8.8.8.8";       # https://developers.google.com/speed/public-dns/docs/using
	GOOGLE_DNS_2="8.8.4.4";       # https://developers.google.com/speed/public-dns/docs/using

	GOOGLE_DNSv6_1="2001:4860:4860::8888";       # https://developers.google.com/speed/public-dns/docs/using
	GOOGLE_DNSv6_2="2001:4860:4860::8844";       # https://developers.google.com/speed/public-dns/docs/using

	CLOUDFARE_DNS_1="1.1.1.1";    # https://developers.cloudflare.com/1.1.1.1/setting-up-1.1.1.1/
	CLOUDFARE_DNS_2="1.0.0.1";    # https://developers.cloudflare.com/1.1.1.1/setting-up-1.1.1.1/

	CLOUDFARE_DNSv6_1="2606:4700:4700::1111";       # https://developers.cloudflare.com/1.1.1.1/setting-up-1.1.1.1/
	CLOUDFARE_DNSv6_2="2606:4700:4700::1001";       # https://developers.cloudflare.com/1.1.1.1/setting-up-1.1.1.1/

	OPEN_DNS_1="208.67.222.222";  # https://use.opendns.com
	OPEN_DNS_2="208.67.220.220";  # https://use.opendns.com

	OPEN_DNSv6_1="2620:119:35::35";  # https://www.opendns.com/about/innovations/ipv6
	OPEN_DNSv6_2="2620:119:53::53";  # https://www.opendns.com/about/innovations/ipv6

	VERISIGN_DNS_1="64.6.64.6";   # https://www.verisign.com/en_US/security-services/public-dns/index.xhtml
	VERISIGN_DNS_2="64.6.65.6";   # https://www.verisign.com/en_US/security-services/public-dns/index.xhtml

	VERISIGN_DNSv6_1="2620:74:1b::1:1";   # https://publicdnsforum.verisign.com/discussion/13/verisign-public-dns-set-up-configuration-instructions
	VERISIGN_DNSv6_2="2620:74:1c::2:2";   # https://publicdnsforum.verisign.com/discussion/13/verisign-public-dns-set-up-configuration-instructions

	# ------------------------------------------------------------
	#
	#		SELECTED DNS SERVERS (HOSTS/IPS TO TARGET AS DNS NAMESERVERS)

	DNS_NAMESRVR_1="${DHCP_NAMESRVR_1:-${GOOGLE_DNS_1}}";
	DNS_NAMESRVR_2="${DHCP_NAMESRVR_2:-${GOOGLE_DNS_2}}";
	DNS_NAMESRVR_3="${DHCP_NAMESRVR_3:-${CLOUDFARE_DNS_1}}";
	DNS_FALLBACK_1="${OPEN_DNS_1}";
	DNS_FALLBACK_2="${CLOUDFARE_DNS_2}";
	DNS_FALLBACK_3="${VERISIGN_DNS_1}";

	# ------------------------------------------------------------

	# DNS "SEARCH": TAKES A SET OF ONE OR MORE DOMAINS AND TRIES CONCATENATING EACH OF THEM
	# WITH THE LOCAL ENVIRONMENT'S HOSTNAME (to try and resolve dns query) BEFORE REVERTING TO
	# GOING EXTERNAL FOR RESOLUTION OF THE DNS QUERY IN_QUESTION
	#
	# MAX IS 6 DOMAINS TOTALING 256 OR LESS CHARACTERS)
	#
	DNS_SEARCH_DOMAIN="";

	# Dingbats, intuitive logging chars/info
	BOX_CHECK="☑";
	BOX_XMARK="☒":
	DASHES="-----------------------------------------------------------------------";
	START_TIMESTAMP="$(date +'%Y%m%d_%H%M%S')";

	# Kernel-Info
	IS_LINUX=$(if [[ $(uname -s | grep Linux | wc -l) -gt 0 ]]; then echo 1; else echo 0; fi; );
	IS_WINDOWS_WSL=$(if [[ "$(< /proc/version)" == *@(Microsoft|WSL)* ]]; then echo 1; else echo 0; fi; );
	if [ "${IS_LINUX}" != "1" ]; then echo -e "\n""ERROR:  Must run in a Linux-based environment"; exit 1; fi;

	# Detect current IP Config
	THIS_LAN_SUBNET=$(ip route | grep -v '169.254.0.0/16' | sed -rne "s/^([a-zA-Z0-9]* )*((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\/([0-9]+)) dev ([a-zA-Z0-9]+) [a-zA-Z0-9 ]* (((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))( [a-zA-Z0-9 ]*)?$/\2/p";); \
	THIS_LAN_BROADCAST=$(ip route | grep -v '169.254.0.0/16' | sed -rne "s/^([a-zA-Z0-9]* )*((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\/([0-9]+)) dev ([a-zA-Z0-9]+) [a-zA-Z0-9 ]* (((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))( [a-zA-Z0-9 ]*)?$/\3/p";); \
	THIS_LAN_NETMASK=$(ip route | grep -v '169.254.0.0/16' | sed -rne "s/^([a-zA-Z0-9]* )*((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\/([0-9]+)) dev ([a-zA-Z0-9]+) [a-zA-Z0-9 ]* (((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))( [a-zA-Z0-9 ]*)?$/\7/p";); \
	THIS_LAN_IPV4=$(ip route | grep -v '169.254.0.0/16' | sed -rne "s/^([a-zA-Z0-9]* )*((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\/([0-9]+)) dev ([a-zA-Z0-9]+) [a-zA-Z0-9 ]* (((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))( [a-zA-Z0-9 ]*)?$/\9/p" | head -n 1;); \
	THIS_GATEWAY_IPV4=$(ip route | grep 'default via '| sed -rne "s/^([a-zA-Z0-9]* )*default +via +([0-9a-fA-F\:\.]+) +[a-zA-Z0-9]+ +([a-zA-Z0-9]+).+$/\2/p" ;); \
	THIS_LAN_NIC=$(ip route | grep 'default via '| sed -rne "s/^([a-zA-Z0-9]* )*default +via +([0-9a-fA-F\:\.]+) +[a-zA-Z0-9]+ +([a-zA-Z0-9]+).+$/\3/p" | head -n 1;); \
	test -z "${THIS_LAN_IPV4}" && THIS_LAN_IPV4=$(ip addr show ${THIS_LAN_NIC} | grep 'inet' | grep 'scope global' | awk '{ print $2; }' | sed 's/\/.*$//' | grep '\.' 2>'/dev/null';); \
	test -z "${THIS_LAN_NETMASK}" && THIS_LAN_NETMASK=$(ip addr show ${THIS_LAN_NIC} | grep 'inet' | grep 'scope global' | awk '{ print $2; }' | sed 's/^.*\///' 2>'/dev/null';); \
	test -z "${THIS_LAN_SUBNET}" && THIS_LAN_SUBNET=$(ip route | grep "$(echo ${THIS_LAN_IPV4} | cut -d. -f1-2)" | sed -rne "s/^([a-zA-Z0-9]* )*((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\/([0-9]+)) dev ${THIS_LAN_NIC}.*$/\2/p";); \
	test -z "${THIS_LAN_BROADCAST}" && THIS_LAN_BROADCAST=$(ip route | grep "$(echo ${THIS_LAN_IPV4} | cut -d. -f1-2)" | sed -rne "s/^([a-zA-Z0-9]* )*((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\/([0-9]+)) dev ${THIS_LAN_NIC}.*$/\3/p";);

	# Network config filepaths
	ETC_RESOLVCONF="/etc/resolv.conf"; # Final output which is-built-from/pulls-from from multiple sources
	DEBIAN_NETWORK_CONF="/etc/network/interfaces.d/50-cloud-init.cfg"; # AWS default cloud-config
	NMCLI_CONF=$(find '/etc/sysconfig/network-scripts/' -name "ifcfg-${THIS_LAN_NIC}" | head -n 1 2>'/dev/null';);

	if [ -n "${NMCLI_CONF}" ]; then

		# NetworkManager Device Configuration

		if [ ! -f "${NMCLI_CONF}" ]; then 

			echo "ERROR: DNS Config-File not found @ path \"${NMCLI_CONF}\" - exiting...";
			exit 1;

		else

			if [ ${USE_STATIC_IPV4} -eq 1 ]; then

				if [ -z "${SET_STATIC_IPV4}" ]; then
					SET_STATIC_IPV4="${THIS_LAN_IPV4}";
				fi;

				echo -e "\n";
				echo "Info: Current LAN IPv4 is \"${THIS_LAN_IPV4}\" on NIC \"${THIS_LAN_NIC}\"";
				echo "Info: Request to set LAN IPv4 as STATIC w/ value \"${SET_STATIC_IPV4}\"";
				read -p "  |--> Set STATIC IPv4 to \"${SET_STATIC_IPV4}\", now? (y/n)  " -n 1 -t 60 -r; # Await single keypress
				echo "";
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					# ------------------------------------------------------------

					# Local LAN IPv4 Address
					if [ $(cat "${NMCLI_CONF}" | grep 'IPADDR=' | wc -l;) -gt 0 ]; then
						echo "";
						sed -i -e "/^IPADDR=/c\IPADDR=${SET_STATIC_IPV4}" "${NMCLI_CONF}";
					else
						echo "";
						echo "IPADDR=${SET_STATIC_IPV4}" >> "${NMCLI_CONF}";
					fi;

					# Gateway LAN IPv4 Address
					if [ $(cat "${NMCLI_CONF}" | grep 'GATEWAY=' | wc -l;) -gt 0 ]; then
						echo "";
						sed -i -e "/^GATEWAY=/c\GATEWAY=${THIS_GATEWAY_IPV4}" "${NMCLI_CONF}";
					else
						echo "";
						echo "GATEWAY=${THIS_GATEWAY_IPV4}" >> "${NMCLI_CONF}";
					fi;

					# LAN Netmask
					if [ $(cat "${NMCLI_CONF}" | grep 'PREFIX=' | wc -l;) -gt 0 ]; then
						echo "";
						sed -i -e "/^PREFIX=/c\PREFIX=${THIS_LAN_NETMASK}" "${NMCLI_CONF}";
					else
						echo "";
						echo "PREFIX=${THIS_LAN_NETMASK}" >> "${NMCLI_CONF}";
					fi;

					# PEERDNS
					if [ $(cat "${NMCLI_CONF}" | grep 'PEERDNS=' | wc -l;) -gt 0 ]; then
						echo "";
						sed -i -e "/^PEERDNS=/c\PEERDNS=no" "${NMCLI_CONF}";
					else
						echo "";
						echo "PEERDNS=no" >> "${NMCLI_CONF}";
					fi;

					# ------------------------------------------------------------
				fi;
			fi;


			# Set DNS Nameserver(s)
			if [ -v SET_STATIC_IPV4 ] && [ -n "${SET_STATIC_IPV4}" ]; then
				echo -e "\n";
				echo "Info: Request to set DNS NameServers to \"${DNS_NAMESRVR_1}\" (Primary) & \"${DNS_NAMESRVR_2}\" (Secondary)";
				read -p "  |--> Set DNS Nameservers, now? (y/n)  " -n 1 -t 60 -r; # Await single keypress
				echo "";
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					# ------------------------------------------------------------

					# DNS Nameserver #1
					if [ $(cat "${NMCLI_CONF}" | grep 'DNS1=' | wc -l;) -gt 0 ]; then
						echo "";
						sed -i -e "/^DNS1=/c\DNS1=${DNS_NAMESRVR_1}" "${NMCLI_CONF}";
					else
						echo "";
						echo "DNS1=${DNS_NAMESRVR_1}" >> "${NMCLI_CONF}";
					fi;

					# DNS Nameserver #2
					if [ $(cat "${NMCLI_CONF}" | grep 'DNS2=' | wc -l;) -gt 0 ]; then
						sed -i -e "/^DNS2=/c\DNS2=${DNS_NAMESRVR_2}" "${NMCLI_CONF}";
						echo "";
					else
						echo "";
						echo "DNS2=${DNS_NAMESRVR_2}" >> "${NMCLI_CONF}";
					fi;

					# ------------------------------------------------------------
				fi;
			fi;

			echo -e "\n""NetworkManager must reload connection profiles to apply changes ( required command [ nmcli connection reload ] )";
			read -p "  |--> Reload connection profiles, now? (y/n)  " -n 1 -t 60 -r; # Await single keypress
			echo "";
			if [[ $REPLY =~ ^[Yy]$ ]]; then
				echo -e "\n""Reloading all NetworkManager connection profiles via command [ nmcli connection reload ]";
				nmcli connection reload;
				RET_CODE=$?;
				if [ ${RET_CODE} -eq 0 ]; then
					echo "";
				else
					echo -e "\n""Error:  Unable to reload profiles";
					echo "NetworkManager must be restarted to apply changes ( required command [ service NetworkManger restart ] )";
					read -p "  |--> Restart NetworkManager, now? (y/n)  " -n 1 -t 60 -r; echo ""; # Await single keypress
					if [[ $REPLY =~ ^[Yy]$ ]]; then
						echo -e "\n""Restarting NetworkManager via command [ service NetworkManger restart ]";
						service NetworkManger restart;
					else
						echo -e "\n""Postponing NetworkManager restart";
						exit 1;
					fi;

				fi;

			else
				echo -e "\n""Postponing NetworkManager restart";
				exit 1;
			fi;

		fi;

	else # ------------------------------------------------------------

		# Resolv.conf

		FILE_DNS_BUILDER_BASE="/etc/resolvconf/resolv.conf.d/base";
		FILE_DNS_BUILDER_TAIL="/etc/resolvconf/resolv.conf.d/base";
		FILE_NETWORK_RESOLVER="${FILE_DNS_BUILDER_BASE}";
		FILE_NETWORK_RESOLVER="${FILE_DNS_BUILDER_TAIL}";
		if [ "${IS_WINDOWS_WSL}" == "1" ]; then
			FILE_NETWORK_RESOLVER="${ETC_RESOLVCONF}"; # Windows subsystem for linux - wipe all of resolver (for testing-only as it is rebuilt on WSL-close, or 'shut down' from its perspective)
		fi;

		# Backup-filepaths
		BACKUP_CONFIGS_DIR="/root/backup/update_dns_config";
		OLD_BACKUP_CONFIGS_DIR="/root/backup_network_configs";
		if [ -d "${OLD_BACKUP_CONFIGS_DIR}" ]; then
			mkdir -p $(dirname "${BACKUP_CONFIGS_DIR}");
			mv "${OLD_BACKUP_CONFIGS_DIR}" "${BACKUP_CONFIGS_DIR}";
		else
			mkdir -p "${BACKUP_CONFIGS_DIR}";
		fi;
		chmod 700 "${BACKUP_CONFIGS_DIR}"; chown "root:root" "${BACKUP_CONFIGS_DIR}";

		# Backup necesarry config file(s), if-existent
		FILE_TO_BACKUP="${ETC_RESOLVCONF}";
		if [ -f "${FILE_TO_BACKUP}" ]; then
			BASENAME_TO_BACKUP=$(basename "${FILE_TO_BACKUP}");
			echo -e "\n""Calling [cp -f \"${FILE_TO_BACKUP}\" \"${BACKUP_CONFIGS_DIR}/${START_TIMESTAMP}_${BASENAME_TO_BACKUP}.bak\";]...";
			cp -f "${FILE_TO_BACKUP}" "${BACKUP_CONFIGS_DIR}/${START_TIMESTAMP}_${BASENAME_TO_BACKUP}.bak";
		fi;
		FILE_TO_BACKUP="${DEBIAN_NETWORK_CONF}";
		if [ -f "${FILE_TO_BACKUP}" ]; then
			BASENAME_TO_BACKUP=$(basename "${FILE_TO_BACKUP}");
			echo -e "\n""Calling [cp -f \"${FILE_TO_BACKUP}\" \"${BACKUP_CONFIGS_DIR}/${START_TIMESTAMP}_${BASENAME_TO_BACKUP}.bak\";]...";
			cp -f "${FILE_TO_BACKUP}" "${BACKUP_CONFIGS_DIR}/${START_TIMESTAMP}_${BASENAME_TO_BACKUP}.bak";
		fi;

		# Setup the nameserver info to make it (eventually) into resolv.conf
		echo "" > "${FILE_NETWORK_RESOLVER}";
		if [ -n "${DNS_NAMESRVR_1}" ]; then echo "nameserver ${DNS_NAMESRVR_1}" >> "${FILE_NETWORK_RESOLVER}"; fi;
		if [ -n "${DNS_NAMESRVR_2}" ]; then echo "nameserver ${DNS_NAMESRVR_2}" >> "${FILE_NETWORK_RESOLVER}"; fi;
		if [ -n "${DNS_NAMESRVR_3}" ]; then echo "nameserver ${DNS_NAMESRVR_3}" >> "${FILE_NETWORK_RESOLVER}"; fi;
		if [ -n "${DNS_SEARCH_DOMAIN}" ]; then echo "search ${DNS_SEARCH_DOMAIN}" >> "${FILE_NETWORK_RESOLVER}"; fi;
		echo "" >> "${FILE_NETWORK_RESOLVER}";

		if [ "${IS_WINDOWS_WSL}" != "1" ]; then

			#
			# Required package:
			#   resolvconf
			#
			# Method(s) used:
			#   > resolvconf   ### manage nameserver information
			#
			REQUIRED_PACKAGE_NAME="resolvconf";
			REQUIRED_METHOD_NAME="resolvconf";
			if [ -n "$(which ${REQUIRED_METHOD_NAME} 2>'/dev/null')" ]; then
				echo -e "\n""Info:  Resolved package \"${REQUIRED_METHOD_NAME}\" to path \"$(which ${REQUIRED_METHOD_NAME})\"";
			else
				echo -e "\n""Error:  Package \"${REQUIRED_METHOD_NAME}\" not found locally";
				echo -e "\n""Please install required package via:";
				echo -e "\n""  > apt-get -y update; apt-get -y install \"${REQUIRED_PACKAGE_NAME}\";";
				echo -e "\n""  > reboot;";
				echo ""; exit 1;
			fi;

			#
			# Required package:
			#   ifupdown
			#
			# Method(s) used:
			#   > ifup        ### bring a network interface up
			#   > ifdown      ### take a network interface down
			#
			REQUIRED_PACKAGE_NAME="ifupdown";
			REQUIRED_METHOD_NAME="ifup";
			if [ -n "$(which ${REQUIRED_METHOD_NAME} 2>'/dev/null')" ]; then
				echo -e "\n""${BOX_CHECK} Passed  [which \"${REQUIRED_METHOD_NAME}\";] ";
			else
				echo -e "\n""${BOX_XMARK} Failed [which \"${REQUIRED_METHOD_NAME}\";] ";
				echo -e "\n""Please install required package via:";
				echo -e "\n""  > apt-get -y update; apt-get -y install \"${REQUIRED_PACKAGE_NAME}\";";
				echo -e "\n""  > reboot;";
				echo ""; exit 1;
			fi;
			REQUIRED_PACKAGE_NAME="ifupdown";
			REQUIRED_METHOD_NAME="ifdown";
			if [ -n "$(which ${REQUIRED_METHOD_NAME} 2>'/dev/null')" ]; then
				echo -e "\n""${BOX_CHECK} Passed  [which \"${REQUIRED_METHOD_NAME}\";] ";
			else
				echo -e "\n""${BOX_XMARK} Failed [which \"${REQUIRED_METHOD_NAME}\";] ";
				echo -e "\n""Please install required package via:";
				echo -e "\n""  > apt-get -y update; apt-get -y install \"${REQUIRED_PACKAGE_NAME}\";";
				echo -e "\n""  > reboot;";
				echo ""; exit 1;
			fi;

			# show "${ETC_RESOLVCONF}" file (configuration before-start)
			echo -e "\n""Calling [cat \"${ETC_RESOLVCONF}\"]";
			echo "${DASHES}"; cat "${ETC_RESOLVCONF}"; echo "${DASHES}";

			# show DNS_NAMESRVR_1,2,3 & Domain-search vars
			echo -e "\n""Attempting to configure $(hostname) to use the following DNS Next-Hops:";
			echo "${DASHES}";
			echo "DNS_NAMESRVR_1 = \"${DNS_NAMESRVR_1}\"";
			echo "DNS_NAMESRVR_2 = \"${DNS_NAMESRVR_2}\"";
			echo "DNS_NAMESRVR_3 = \"${DNS_NAMESRVR_3}\"";
			echo "DNS_SEARCH_DOMAIN = \"${DNS_SEARCH_DOMAIN}\"";
			echo "${DASHES}";

			# Create the eth0 config file (if it is a valid filepath yet doesnt exist)
			if [ -n "${DEBIAN_NETWORK_CONF}" ] && [ ! -f "${DEBIAN_NETWORK_CONF}" ]; then
				echo -e "\n""Calling [echo \"\" > \"${DEBIAN_NETWORK_CONF}\";]...";
				echo "" > "${DEBIAN_NETWORK_CONF}";
			fi;

			DNS_SEARCH_DOMAIN="";
			THIS_HYPERVISOR="/sys/hypervisor/uuid";
			AWS_HV_STARTS_WITH="ec2";
			if [ -f "${THIS_HYPERVISOR}" ]; then
				if [[ "$(cat ${THIS_HYPERVISOR})" == "${AWS_HV_STARTS_WITH}"* ]] && [ -n "${DOMAIN}" ]; then
					DNS_SEARCH_DOMAIN="${DOMAIN}";
				fi;
			fi;

			DNS_LOOKUP_1=$(cat ${DEBIAN_NETWORK_CONF} | grep ${DNS_NAMESRVR_1});
			DNS_LOOKUP_2=$(cat ${DEBIAN_NETWORK_CONF} | grep ${DNS_NAMESRVR_2});
			DNS_LOOKUP_3=$(cat ${DEBIAN_NETWORK_CONF} | grep ${DNS_NAMESRVR_3});

			REFRESH_DNS_FILE="0";

			ACTION_DOMAIN_RESOLUTION="";
			DOMAIN_RESOLUTION_CONFIGURED="$(cat ${DEBIAN_NETWORK_CONF} | grep 'search ')";
			if [ -n "${DNS_SEARCH_DOMAIN}" ]; then
				DOMAIN_RESOLUTION_CONFIGURED="$(echo ${DOMAIN_RESOLUTION_CONFIGURED} | grep ${DNS_SEARCH_DOMAIN};)";
				if [ ! -n "${DOMAIN_RESOLUTION_CONFIGURED}" ]; then
					ACTION_DOMAIN_RESOLUTION="SET"; # Need to configure local domain-name resolution
				fi;
			fi;

			if [ -n "${DNS_LOOKUP_1}" ] && [ -n "${DNS_LOOKUP_2}" ] && [ -n "${DNS_LOOKUP_3}" ] && [ -n "${ACTION_DOMAIN_RESOLUTION}" ]; then # all variables are not null

				echo -e "\n""\"${DEBIAN_NETWORK_CONF}\"'s DNS settings are up-to-date";
				
			else # at least one DNS-IP/Hostname is missing

				echo -e "\n""Updating DNS Servers which build out of file \"${DEBIAN_NETWORK_CONF}\"";
				
				# "dns-search"
				if [ -n "${DNS_SEARCH_DOMAIN}" ] && [ "${ACTION_DOMAIN_RESOLUTION}" == "SET" ]; then
					#    verify if any line already contains the "dns-search" directive
					DNS_SEARCH_LINES_FOUND=$(cat "${DEBIAN_NETWORK_CONF}" | grep 'dns-search ' | wc -l);
					DOMAIN_BIND_TO_ETH0="${DNS_SEARCH_DOMAIN}";
					if [ "${DNS_SEARCH_LINES_FOUND}" == "0" ]; then
						# add the "dns-search" line
						echo "dns-search ${DOMAIN_BIND_TO_ETH0}" >>  "${DEBIAN_NETWORK_CONF}";
					else
						# modify the "dns-search" line
						SED_DNS_SEARCH="/^dns-search/c\dns-search ${DOMAIN_BIND_TO_ETH0}";
						sed --in-place --expression="${SED_DNS_SEARCH}" "${DEBIAN_NETWORK_CONF}";
					fi;

				else
					echo -e "\n""Skipping Setting: Local domain-name resolution (${ETC_RESOLVCONF} setting 'search ...')";
					echo "Skip Reason: Required variable 'DNS_SEARCH_DOMAIN' is undefined/empty (holds domain-name string)";

				fi;
				
				
				# "dns-nameservers"
				#    verify if any line already contains the "dns-nameservers" directive
				DNS_NAMESERVER_LINES_FOUND=$(cat "${DEBIAN_NETWORK_CONF}" | grep 'dns-nameservers' | wc -l);
				DNS_BIND_TO_ETH0="${DNS_NAMESRVR_1} ${DNS_NAMESRVR_2} ${DNS_NAMESRVR_3}";
				if [ "${DNS_NAMESERVER_LINES_FOUND}" == "0" ]; then
					# add the "dns-nameservers" line
					echo "dns-nameservers ${DNS_BIND_TO_ETH0}" >> "${DEBIAN_NETWORK_CONF}";
				else
					# modify the "dns-nameservers" line
					SED_DNS_NAMESERVERS="/^dns-nameservers/c\dns-nameservers ${DNS_BIND_TO_ETH0}";
					sed --in-place --expression="${SED_DNS_NAMESERVERS}" "${DEBIAN_NETWORK_CONF}";
				fi;
				
				REFRESH_DNS_FILE="1";

			fi;
			
			SystemResolveConf="/etc/systemd/resolved.conf";
			SystemNetworkConfDir="/etc/systemd/network";

			if [ -f "${SystemResolveConf}" ]; then

				echo "Updating Hostname-Resolving Service \"systemd-resolve\" via associated config-file \"${SystemResolveConf}\" ...";
				CAN_USE_SYSRESOLVE_STATUS="$(systemd-resolve --help | grep status)";
				
				echo -e "\n""Calling [cat \"${SystemResolveConf}\";] (BEFORE EDITS)";
				echo "${DASHES}"; cat "${SystemResolveConf}"; echo "${DASHES}";

				if [ -n "${CAN_USE_SYSRESOLVE_STATUS}" ]; then
					# Show "systemd-resolve --status" command's output BEFORE-EDITS (shows live DNS setup)
					echo -e "\n""Calling [systemd-resolve --status] (BEFORE EDITS)";
					echo "${DASHES}"; echo "$(systemd-resolve --status)"; echo "${DASHES}"; ## Must use echo "$(systemd-resolve --status)" to avoid scroll-lock (which holds up entire program)
				fi;

				sed_001="/^DNS=/c\DNS=${DNS_NAMESRVR_1} ${DNS_NAMESRVR_2} ${DNS_NAMESRVR_3}";
				sed_002="/^#DNS=/c\DNS=${DNS_NAMESRVR_1} ${DNS_NAMESRVR_2} ${DNS_NAMESRVR_3}";
				sed_003="/^FallbackDNS=/c\FallbackDNS=${DNS_FALLBACK_1} ${DNS_FALLBACK_2} ${DNS_FALLBACK_3}";
				sed_004="/^#FallbackDNS=/c\FallbackDNS=${DNS_FALLBACK_1} ${DNS_FALLBACK_2} ${DNS_FALLBACK_3}";

				sed --in-place --expression="${sed_001}" --expression="${sed_002}" --expression="${sed_003}" --expression="${sed_004}" "${SystemResolveConf}";
				if [ -d "${SystemNetworkConfDir}" ]; then
					echo -e "\n""Searching directory for config-files: \"${SystemNetworkConfDir}\"...";
					for EachNetworkFile in ${SystemNetworkConfDir}/*; do
						if [ -f "${EachNetworkFile}" ]; then
							echo "Applying DNS Configuration to Network File: \"${EachNetworkFile}\"";
							sed --in-place --expression="${sed_001}" --expression="${sed_002}" --expression="${sed_003}" --expression="${sed_004}" "${EachNetworkFile}";
						else
							echo "Skipping item with invalid filetype: \"${EachNetworkFile}\"";
						fi;
					done;
				fi;
				REFRESH_DNS_FILE="1";
			fi;


			if [ "${REFRESH_DNS_FILE}" == "1" ]; then
				# take down the main network interface & bring it back up (in one statement)
				echo -e "\n""Calling [ifdown -a && ifup -a;]...";
				echo "(takes down the main network interface & bring it back up, in one statement)...";
				echo "${DASHES}"; ifdown -a && ifup -a; echo "${DASHES}";
				
				# give the (virtual) NIC a few seconds to grab a connection
				sleep 5;
				
				# refresh the resolvconf DNS file
				echo -e "\n""Calling [resolvconf -u]...";
				echo "${DASHES}"; resolvconf -u; echo "${DASHES}";
				echo "";

				if [ -f "${SystemResolveConf}" ]; then
					# Show "systemd-resolve --status" command's output AFTER-EDITS (shows live DNS setup)
					echo -e "\n""Restarting local DNS resolution-service via [service systemd-resolved restart;]";
					echo "${DASHES}"; service systemd-resolved restart; echo "${DASHES}";
					
					echo -e "\n""Calling [cat \"${SystemResolveConf}\";]";
					echo "${DASHES}"; cat "${SystemResolveConf}"; echo "${DASHES}";

					if [ -n "${CAN_USE_SYSRESOLVE_STATUS}" ]; then
						# Show "systemd-resolve --status" command's output AFTER-EDITS (shows live DNS setup)
						echo -e "\n""Calling [systemd-resolve --status]";
						echo "${DASHES}"; echo "$(systemd-resolve --status)"; echo "${DASHES}"; ## Must use echo "$(systemd-resolve --status)" to avoid scroll-lock (which holds up entire program)
					fi;
				fi;
			fi;

		fi;
	
	fi;

	# ------------------------------------------------------------
	#
	# Show the final network configuration
	#

	# verify the configuration tied to eth0
	# echo "";
	# echo "Calling [ifconfig eth0]...";
	# echo "${DASHES}"; ifconfig eth0; echo "${DASHES}";

	if [ -f "${DEBIAN_NETWORK_CONF}" ]; then
		echo -e "\n""Calling [cat \"${DEBIAN_NETWORK_CONF}\"]";
		echo "${DASHES}"; cat "${DEBIAN_NETWORK_CONF}"; echo "${DASHES}";
	elif [ -f "${NMCLI_CONF}" ]; then
		echo -e "\n""Calling [cat \"${NMCLI_CONF}\"]";
		echo "${DASHES}"; cat "${NMCLI_CONF}"; echo "${DASHES}";
	fi;

	if [ -f "${ETC_RESOLVCONF}" ]; then
		echo -e "\n""Calling [cat \"${ETC_RESOLVCONF}\"]";
		echo "${DASHES}"; cat "${ETC_RESOLVCONF}"; echo "${DASHES}";
	fi;

fi;

# ------------------------------------------------------------
# Citation(s)
#
#   reddit.com  |  "What DNS servers to use?"  |  https://www.reddit.com/r/privacy/comments/8mx6pe/what_dns_servers_to_use/
#
# ------------------------------------------------------------