#!/bin/bash
# ------------------------------------------------------------
if [[ 0 -eq 1 ]]; then # RUN THIS SCRIPT REMOTELY:

# Option 1:  Sync basic + utility methods (only)
curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" | bash;

# Option 2 (--all):  Sync basic + utility + optional methods using opt-In methodology (will ask user per-module before installing them)
curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "https://raw.githubusercontent.com/mcavallo-git/cloud-infrastructure/master/usr/local/sbin/sync_cloud_infrastructure?t=$(date +'%s.%N')" | bash -s -- --all;

fi;
# ------------------------------------------------------------
#
# Edit this script, locally (for use during ad-hoc updates/hotfixes)
#
#   LOCAL_SBIN="/usr/local/sbin/sync_cloud_infrastructure" && echo "" > "${LOCAL_SBIN}" && vi "${LOCAL_SBIN}" && chmod 0755 "${LOCAL_SBIN}";
#
# ------------------------------------------------------------
#
# Log all shell output & error output to logfile
#
LOGDIR="${HOME}/sync_cloud_infrastructure_logs"; if [[ -w "/var/log/" ]]; then LOGDIR="/var/log/sync_cloud_infrastructure"; fi;
mkdir -p "${LOGDIR}"; chown $(stat -c '%u:%g' $(dirname ${LOGDIR})) "${LOGDIR}" 2>'/dev/null'; chmod 0770 "${LOGDIR}" 2>'/dev/null';
LOGFILE="${LOGDIR}/$(basename ${LOGDIR})_$(date +'%Y%m%d')"; touch "${LOGFILE}"; chmod 0660 "${LOGFILE}";
exec > >(tee -a "${LOGFILE}" );
exec 2>&1;
#
# ------------------------------------------------------------
#
# Instantiate static runtime variables
#

START_SECONDS_NANOSECONDS=$(date +'%s.%N');
START_EPOCHSECONDS=$(echo ${START_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 1);
START_DATETIME="$(date --date=@${START_EPOCHSECONDS} +'%Y-%m-%d %H:%M:%S')";
START_TIMESTAMP="$(date --date=@${START_EPOCHSECONDS} +'%Y%m%d_%H%M%S')";

DEFAULT_GIT_SOURCE_REPO_URL="https://github.com/mcavallo-git/cloud-infrastructure.git";
DEFAULT_GIT_SOURCE_BRANCH="master";
SYNC_CI_LOCAL="/usr/local/sbin/sync_cloud_infrastructure";

WAN_TEST_FQDN="${WAN_TEST_FQDN:-raw.githubusercontent.com}";

# ------------------------------------------------------------
#
# Instantiate dymamic runtime variables
#

LOCAL_CONFIG_DIR_FULLPATH="/etc/$(basename "${SYNC_CI_LOCAL}";)"; # holds configurations (if any) specific to this script

EXIT_CODE=0; # sum of errors from specific required calls - returned as the final exit-code from this script

UPDATE_SELF_REQUIRED=0; # used to determine if a newer version of this script should be pulled or not

# ------------------------------------------------------------
#
# Log the starting timestamp for the current runtime
#
echo -e "-- Info:  Start of \"$(basename "${SYNC_CI_LOCAL}";)\" runtime at [ ${START_DATETIME} ]  (ID: ${START_SECONDS_NANOSECONDS})";

# ------------------------------------------------------------
#
# Script must run as root (or via sudo)
#
if [[ "$(id -un)" != "root" ]]; then
  echo "";
  echo "$(date +'%Y-%m-%d %H:%M:%S') | Error: Script must run as user \"root\" or via \"sudo\" command";
  EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
else
  # ------------------------------------------------------------
  #
  # Script-specific config overrides
  #

  # Confirm Sync (y/n)
  SYNC_CONFIRMED=0;
  if [[ "$(tty --silent; echo ${?};)" -eq 0 ]]; then
    # Active Terminal --> Verify through the user that they confirm continuing with syncing cloud infrastructure modules
    if [[ -f "${SYNC_CI_LOCAL}" ]]; then
      # The [ sync_cloud_infrastructure ] module DOES already exist (first-time sync) - Confirmation skipped
      echo -e "\nInfo:  Auto-confirming cloud-infrastructure module sync (not initial sync)";
      SYNC_CONFIRMED=1;
    else
      # The [ sync_cloud_infrastructure ] module does NOT yet exist (first-time sync) - Confirmation required
      echo ""; read -p "Info:  Sync cloud-infrastructure modules, now?  (press 'y' to confirm)  " -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
      if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
        SYNC_CONFIRMED=1;
        echo -e "\n  |--> Confirmed";
      else
        SYNC_CONFIRMED=0;
        echo -e "\n  |--> Denied";
      fi;
    fi;
  else
    # Backend-only mode - do not require confirmation to sync modules
    echo -e "\nInfo:  Auto-confirming cloud-infrastructure module sync (no TTY present)";
    SYNC_CONFIRMED=1;
  fi;

  if [[ "${SYNC_CONFIRMED}" -eq 1 ]]; then

    # Create parent directory for script-specific config overrides
    if [[ ! -d "${LOCAL_CONFIG_DIR_FULLPATH}" ]]; then
      mkdir -pv "${LOCAL_CONFIG_DIR_FULLPATH}";
    fi;
    if [[ -d "${LOCAL_CONFIG_DIR_FULLPATH}" ]] && [[ -n "$(command -v stat 2>'/dev/null';)" ]] && [[ "$(stat --format '%a' ${LOCAL_CONFIG_DIR_FULLPATH})" != "755" ]]; then
      chmod 755 "${LOCAL_CONFIG_DIR_FULLPATH}";
    fi;

    # Git Repo URL - Allow overriding default repo URL with local filepath
    OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL="${LOCAL_CONFIG_DIR_FULLPATH}/git_source_repo.url";
    if [[ -f "${OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL}" ]]; then
      OVERRIDE_GIT_SOURCE_REPO_URL="$(cat ${OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL};)"; # Override the git source repo URL
    fi;
    GIT_SOURCE_REPO_URL="${OVERRIDE_GIT_SOURCE_REPO_URL:-${DEFAULT_GIT_SOURCE_REPO_URL}}";


    # ------------------------------------------------------------
    #
    # Parse inline arguments (passed to current script)
    #

    ARGS=("$@");
    ARGS_COUNT=${#ARGS[@]};

    ARGS_CHECK_WSL=$(if [[ -z "$(uname -r 2>&1 | grep -i 'microsoft' 2>&1;)" ]]; then echo 0; else echo 1; fi;);

    RESTART_SERVICE_CRON=0;
    RESTART_SERVICE_JENKINS=0;
    RESTART_SERVICE_NGINX=0;
    RESTART_SERVICE_SSH=0;
    RESTART_SERVICE_UFW=0;

    # Walk through any inline-arguments passed to this function
    for (( i=0;i<${ARGS_COUNT};i++ )); do

      EACH_ARG=${ARGS[${i}]};

      # Check if this is the last inline-argument or if there are more to follow
      if [[ $((${i}+1)) -eq ${ARGS_COUNT} ]]; then # if this is the last argument
        NEXT_ARG="";
      else
        NEXT_ARG=${ARGS[$((${i}+1))]};
        if [[ "${NEXT_ARG}" == "--"* ]]; then # Do not allow inline-arguments starting with "--..." to use the next bash-argument as an associated value if it, also, starts with "--..."
          NEXT_ARG="";
        fi;
      fi;

      if [[ -n "${EACH_ARG}" ]]; then # Parse each non-empty inline argument

        # Use "--all" inline-arg. to sync all modules
        if [[ "${EACH_ARG}" == "--all" ]]; then
          ARGS_CRONJOB_REMOVE=0; # Do not delete cronjobs since we're going to sync all of them
          ARGS_CRONJOB_SYNC=1;
          # ARGS_DEBUG_MODE=1;
          # ARGS_SYNC_DDNS=1;
          ARGS_SYNC_JENKINS=1;
          ARGS_SYNC_NGINX=1;
          ARGS_SYNC_SSH_CONFIG=1;
          ARGS_SYNC_TIMEZONE=1;
          ARGS_SYNC_UFW=1;
        fi;

        if [[ "${EACH_ARG}" == "--wsl" ]] || [[ "${EACH_ARG}" == "--windows" ]]; then
          ARGS_CHECK_WSL=1; # Parse WSL check calls
        fi;

        if [[ "${EACH_ARG}" == "--remove-cronjobs" ]] || [[ "${EACH_ARG}" == "--remove" ]]; then
          ARGS_CRONJOB_REMOVE=1; # Parse cronjobs removal calls
        fi;

        if [[ "${EACH_ARG}" == "--cron" ]]; then
          if [[ "${NEXT_ARG}" == "remove" ]] && [[ ${ARGS_CRONJOB_SYNC} -eq 0 ]]; then
            ARGS_CRONJOB_REMOVE=1; # Parse cronjob removal calls
          elif [[ "${NEXT_ARG}" == "sync" ]] && [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
            ARGS_CRONJOB_SYNC=1; # Parse cronjob sync calls
          else
            # Error - Invalid argument syntax (but also show user an example of valid argument syntax)
            echo "Error:  Invalid inline argument:  ${EACH_ARG} ${NEXT_ARG}";
            echo "                        |";
            echo "                        |--> Sync cron-job(s) via '--cron sync' argument";
            echo "                        |--> Remove synced cron-job(s) via '--cron remove' argument";
            echo "";
            EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          fi;
        fi;

        if [[ "${EACH_ARG}" == "--debug" ]] || [[ "${EACH_ARG}" == "--verbose" ]]; then
          ARGS_DEBUG_MODE=1; # Parse debug/verbose calls
        fi;

        if [[ "${EACH_ARG}" == "--git-branch" ]]; then
          if [[ -n "${NEXT_ARG}" ]]; then
            ARGS_GIT_BRANCH="${NEXT_ARG}"; # Parse git repo branch calls
          else
            # Error - Invalid argument syntax (but also show user an example of valid argument syntax)
            echo "Error:  Invalid inline argument:  ${EACH_ARG} ${NEXT_ARG}";
            echo "                        |";
            echo "                        |--> Change repository branch via '--git-branch BRANCH_NAME_HERE' argument";
            echo "";
            EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          fi;
        fi;

        if [[ "${EACH_ARG}" == "--force-self-update" ]]; then
          ARGS_FORCE_SELF_UPDATE=1; # Parse force-self-update calls
        fi;

        if [[ "${EACH_ARG}" == "--skip-self-update" ]]; then
          ARGS_SKIP_SELF_UPDATE=1; # Parse skip-self-update calls
        fi;

        if [[ "${EACH_ARG}" == "--ddns" ]]; then
          ARGS_SYNC_DDNS=1; # Parse DDNS sync Calls
        fi;

        if [[ "${EACH_ARG}" == "--jenkins" ]]; then
          ARGS_SYNC_JENKINS=1; # Parse Jenkins sync calls
        fi;

        if [[ "${EACH_ARG}" == "--nginx" ]]; then
          ARGS_SYNC_NGINX=1; # Parse NGINX sync calls
        fi;

        if [[ "${EACH_ARG}" == "--ssh" ]] || [[ "${EACH_ARG}" == "--sshd" ]]; then
          ARGS_SYNC_SSH_CONFIG=1; # Parse SSH config calls
        fi;

        if [[ "${EACH_ARG}" == "-z" ]] || [[ "${EACH_ARG}" == "--timezone" ]]; then
          ARGS_SYNC_TIMEZONE=1; # Parse Timezone config calls
        fi;

        if [[ "${EACH_ARG}" == "--ufw" ]]; then
          ARGS_SYNC_UFW=1; # Parse UFW sync calls
        fi;

      fi;

    done;

    # Integer arguments
    ARGS_CHECK_WSL=${ARGS_CHECK_WSL:-0};                  # Parsed from $@
    ARGS_CRONJOB_REMOVE=${ARGS_CRONJOB_REMOVE:-0};        # Parsed from $@
    ARGS_CRONJOB_SYNC=${ARGS_CRONJOB_SYNC:-0};            # Parsed from $@
    ARGS_DEBUG_MODE=${ARGS_DEBUG_MODE:-0};                # Parsed from $@
    ARGS_FORCE_SELF_UPDATE=${ARGS_FORCE_SELF_UPDATE:-0};  # Parsed from $@
    ARGS_SKIP_SELF_UPDATE=${ARGS_SKIP_SELF_UPDATE:-0};    # Parsed from $@
    ARGS_SYNC_DDNS=${ARGS_SYNC_DDNS:-0};                  # Parsed from $@
    ARGS_SYNC_JENKINS=${ARGS_SYNC_JENKINS:-0};            # Parsed from $@
    ARGS_SYNC_NGINX=${ARGS_SYNC_NGINX:-0};                # Parsed from $@
    ARGS_SYNC_SSH_CONFIG=${ARGS_SYNC_SSH_CONFIG:-0};      # Parsed from $@
    ARGS_SYNC_TIMEZONE=${ARGS_SYNC_TIMEZONE:-0};          # Parsed from $@
    ARGS_SYNC_UFW=${ARGS_SYNC_UFW:-0};                    # Parsed from $@

    # String arguments
    ARGS_GIT_BRANCH=${ARGS_GIT_BRANCH:-""};               # Parsed from $@

    # ------------------------------------------------------------

    WIN32_HOMEDIR="";

    DIR_REPO_BASE="";

    GIT_REPO_OWNER="$(basename $(dirname ${GIT_SOURCE_REPO_URL};);)";

    GIT_REPO_NAME="$(basename ${GIT_SOURCE_REPO_URL} | cut -d. -f1;)";

    GIT_LOCAL_PARENT_PATH="${HOME}/Documents/GitHub";

    GIT_LOCAL_REPO_PATH="${GIT_LOCAL_PARENT_PATH}/${GIT_REPO_NAME}/";

    GIT_SOURCE_BRANCH="${ARGS_GIT_BRANCH:-${DEFAULT_GIT_SOURCE_BRANCH}}";

    SYNC_CI_REMOTE="https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}/${SYNC_CI_LOCAL}?t=${START_SECONDS_NANOSECONDS}";

    # ------------------------------------------------------------
    # Check for a valid WAN (internet) connection

    WAN_TEST_CURL_RESPONSE=$(curl -sLI "${WAN_TEST_FQDN}";);
    WAN_TEST_CURL_FAILED=${?};
    WAN_TEST_HTTP_CODE=$(echo "${WAN_TEST_CURL_RESPONSE}" | grep '^HTTP' | tail -n 1 | cut -d' ' -f2;);
    WAN_TEST_FAILED=$(if [[ ${WAN_TEST_CURL_FAILED} -eq 0 ]] && [[ ${WAN_TEST_HTTP_CODE} -ge 200 ]] && [[ ${WAN_TEST_HTTP_CODE} -le 400 ]]; then echo 0; else echo 1; fi;);
    if [[ "${WAN_TEST_FAILED}" == "1" ]]; then
      echo "";
      echo "Error:  WAN network (internet) connection is required to sync cloud-infrastructure files, but is unable to be verified";
      EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
    elif [[ -z "${GIT_REPO_NAME}" ]]; then
      echo "";
      echo "Error:  Required variable empty/unset:  \${GIT_REPO_NAME}";
      EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
    elif [[ -z "${GIT_REPO_OWNER}" ]]; then
      echo "";
      echo "Error:  Required variable empty/unset:  \${GIT_REPO_OWNER}";
      EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
    fi;

    # ------------------------------------------------------------

    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
      echo "";
      echo "Debug:  ARGS = [ ${ARGS[@]} ]";
      echo "Debug:  ARGS_COUNT = [ ${ARGS_COUNT} ]";
      echo "";
      echo "Debug:  ARGS_CHECK_WSL = [ ${ARGS_CHECK_WSL} ]";
      echo "Debug:  ARGS_CRONJOB_REMOVE = [ ${ARGS_CRONJOB_REMOVE} ]";
      echo "Debug:  ARGS_CRONJOB_SYNC = [ ${ARGS_CRONJOB_SYNC} ]";
      echo "Debug:  ARGS_DEBUG_MODE = [ ${ARGS_DEBUG_MODE} ]";
      echo "Debug:  ARGS_GIT_BRANCH = [ ${ARGS_GIT_BRANCH} ]";
      echo "Debug:  ARGS_FORCE_SELF_UPDATE = [ ${ARGS_FORCE_SELF_UPDATE} ]";
      echo "Debug:  ARGS_SKIP_SELF_UPDATE = [ ${ARGS_SKIP_SELF_UPDATE} ]";
      echo "Debug:  ARGS_SYNC_DDNS = [ ${ARGS_SYNC_DDNS} ]";
      echo "Debug:  ARGS_SYNC_JENKINS = [ ${ARGS_SYNC_JENKINS} ]";
      echo "Debug:  ARGS_SYNC_NGINX = [ ${ARGS_SYNC_NGINX} ]";
      echo "Debug:  ARGS_SYNC_SSH_CONFIG = [ ${ARGS_SYNC_SSH_CONFIG} ]";
      echo "Debug:  ARGS_SYNC_TIMEZONE = [ ${ARGS_SYNC_TIMEZONE} ]";
      echo "Debug:  ARGS_SYNC_UFW = [ ${ARGS_SYNC_UFW} ]";
      echo "";
      echo "Debug:  GIT_LOCAL_PARENT_PATH = [ ${GIT_LOCAL_PARENT_PATH} ]";
      echo "Debug:  GIT_LOCAL_REPO_PATH = [ ${GIT_LOCAL_REPO_PATH} ]";
      echo "Debug:  GIT_REPO_NAME = [ ${GIT_REPO_NAME} ]";
      echo "Debug:  GIT_REPO_OWNER = [ ${GIT_REPO_OWNER} ]";
      echo "";
      echo "Debug:  GIT_SOURCE_BRANCH = [ ${GIT_SOURCE_BRANCH} ]";
      echo "Debug:  DEFAULT_GIT_SOURCE_BRANCH = [ ${DEFAULT_GIT_SOURCE_BRANCH} ]";
      echo "";
      echo "Debug:  GIT_SOURCE_REPO_URL = [ ${GIT_SOURCE_REPO_URL} ]";
      echo "Debug:  DEFAULT_GIT_SOURCE_REPO_URL = [ ${DEFAULT_GIT_SOURCE_REPO_URL} ]";
      echo "";
      echo "Debug:  LOCAL_CONFIG_DIR_FULLPATH = [ ${LOCAL_CONFIG_DIR_FULLPATH} ]";
      echo "Debug:  SYNC_CI_LOCAL = [ ${SYNC_CI_LOCAL} ]";
      echo "Debug:  SYNC_CI_REMOTE = [ ${SYNC_CI_REMOTE} ]";
      echo "";
      echo "Debug:  LOGDIR = [ ${LOGDIR} ]";
      echo "Debug:  LOGFILE = [ ${LOGFILE} ]";
      echo "";
      echo "Debug:  OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL = [ ${OVERRIDE_FULLPATH_GIT_SOURCE_REPO_URL} ]";
      echo "Debug:  OVERRIDE_GIT_SOURCE_REPO_URL = [ ${OVERRIDE_GIT_SOURCE_REPO_URL} ]";
      echo "";
      echo "Debug:  START_SECONDS_NANOSECONDS = [ ${START_SECONDS_NANOSECONDS} ]";
      echo "Debug:  START_EPOCHSECONDS = [ ${START_EPOCHSECONDS} ]";
      echo "Debug:  START_DATETIME = [ ${START_DATETIME} ]";
      echo "Debug:  START_TIMESTAMP = [ ${START_TIMESTAMP} ]";
      echo "";
      echo "Debug:  WAN_TEST_FQDN = [ ${WAN_TEST_FQDN} ]";
      echo "Debug:  WAN_TEST_CURL_FAILED = [ ${WAN_TEST_CURL_FAILED} ]";
      echo "Debug:  WAN_TEST_FAILED = [ ${WAN_TEST_FAILED} ]";
      echo "Debug:  WAN_TEST_HTTP_CODE = [ ${WAN_TEST_HTTP_CODE} ]";
    fi;

    # If no errors are found up-until this point, continue
    if [[ -z "${EXIT_CODE}" ]] || [[ "${EXIT_CODE}" == "0" ]]; then
      # Make sure prerequisite-packages are installed
      unset REQUIRED_PKGS_ARRAY; declare -a REQUIRED_PKGS_ARRAY; # [Re-]Instantiate bash array
      unset MISSING_PKGS_ARRAY; declare -a MISSING_PKGS_ARRAY; # [Re-]Instantiate bash array
      REQUIRED_PKGS_ARRAY=();
      REQUIRED_PKGS_ARRAY+=("bc");
      REQUIRED_PKGS_ARRAY+=("dos2unix");
      REQUIRED_PKGS_ARRAY+=("git");
      REQUIRED_PKGS_ARRAY+=("lsof");
      REQUIRED_PKGS_ARRAY+=("rsync");
      REQUIRED_PKGS_ARRAY+=("vim-common");
      REQUIRED_PKGS_ARRAY+=("wget");

      # Debian-specific packages
      if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
        REQUIRED_PKGS_ARRAY+=("cron");
        REQUIRED_PKGS_ARRAY+=("jq");
        # REQUIRED_PKGS_ARRAY+=("sslscan");
      elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
        REQUIRED_PKGS_ARRAY+=("bind-utils");
        REQUIRED_PKGS_ARRAY+=("epel-release");
        REQUIRED_PKGS_ARRAY+=("policycoreutils-devel");
        # Install the "jq" (JSON Parser) package manually for RHEL distros
        if [[ ! -f "/usr/bin/jq" ]] || [[ -f "/usr/bin/jq" && $(stat --printf="%s" "/usr/bin/jq";) -le 1000 ]]; then # stat command is for hotfix on invalid downloads
          curl -o "/usr/bin/jq" -sL "https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64" && chmod 0755 "/usr/bin/jq";
        fi;
      fi;

      # Determine if any required packages are missing
      for EACH_REQUIRED_PKG in "${REQUIRED_PKGS_ARRAY[@]}"; do
        if [[ -n "${EACH_REQUIRED_PKG}" ]]; then
          if [[ -n "$(command -v dpkg 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
            # Query Debian's Package-Manager for each package
            if [[ $(dpkg -L "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]]; then
              MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
            fi;
          elif [[ -n "$(command -v rpm 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
            # Query RHEL's Package-Manager for each package
            if [[ $(rpm --quiet --query "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]]; then
              MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
            fi;
          else # Other distros
            if [[ -z "$(command -v ${EACH_REQUIRED_PKG} 2>'/dev/null';)" ]]; then
              MISSING_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
            fi;
          fi;
        fi;
      done;

      # If any packages were determined to be missing, attempt to install them
      if [[ ${#MISSING_PKGS_ARRAY[@]} -ne 0 ]]; then

        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  MISSING_PKGS_ARRAY = [ ${MISSING_PKGS_ARRAY[@]} ]";
        fi;

        if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then
          if [[ 1 -eq 1 ]]; then
            # Debian distros (Ubuntu, Raspbian, etc.)
            #  |--> Individually install missing packages (to avoid errors from single-packages from taking-out the entire bulk-install attempt)
            echo -e "\nInfo:  Calling [ apt-get update -y; ]...";
            apt-get -y update;
            for EACH_MISSING_PKG in "${MISSING_PKGS_ARRAY[@]}"; do
              echo -e "\nInfo:  Calling [ apt-get -y install ${EACH_MISSING_PKG}; ]...";
              apt-get -y install ${EACH_MISSING_PKG};
            done;
          else
            # Debian distros (Ubuntu, Raspbian, etc.)
            #  |--> Bulk install missing packages
            echo -e "\nInfo:  Calling [ apt-get -y update; apt-get -y install ${MISSING_PKGS_ARRAY[@]}; ]...";
            apt-get -y update; apt-get -y install ${MISSING_PKGS_ARRAY[@]};
          fi;

        elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then
          # RHEL, CentOS distros
          #  |--> Bulk install missing packages
          echo -e "\nInfo:  Calling [ yum check-update -y; yum -y install ${MISSING_PKGS_ARRAY[@]}; ]...";
          yum check-update -y; yum -y install ${MISSING_PKGS_ARRAY[@]};

        elif [[ -n "$(command -v apk 2>'/dev/null';)" ]]; then
          # Alpine distros
          #  |--> Bulk install missing packages
          echo -e "\nInfo:  Calling [ apk update -y; apk add -y ${MISSING_PKGS_ARRAY[@]}; ]...";
          apk update -y; apk add -y ${MISSING_PKGS_ARRAY[@]};

        fi;

        # Verify that all required packages (which are needed later in this script) are installed as-intended
        unset FAILED_INSTALL_PKGS_ARRAY; declare -a FAILED_INSTALL_PKGS_ARRAY; # [Re-]Instantiate bash array
        for EACH_REQUIRED_PKG in "${REQUIRED_PKGS_ARRAY[@]}"; do
          if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
            # Query Debian's Package-Manager for each package
            if [[ $(dpkg -L "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]]; then
              FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
            fi;
          elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
            # Query RHEL's Package-Manager for each package
            if [[ $(rpm --quiet --query "${EACH_REQUIRED_PKG}" 1>'/dev/null' 2>&1; echo $?;) -ne 0 ]]; then
              FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
            fi;
          else # Other distros
            if [[ -z "$(command -v ${EACH_REQUIRED_PKG} 2>'/dev/null';)" ]]; then
              FAILED_INSTALL_PKGS_ARRAY+=("${EACH_REQUIRED_PKG}");
            fi;
          fi;
        done;

        if [[ ${#FAILED_INSTALL_PKGS_ARRAY[@]} -ne 0 ]]; then
          echo -e "\nError:  Unable to install package(s):  [ ${FAILED_INSTALL_PKGS_ARRAY[@]} ]";
          EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
        fi;

      fi;

      # ------------------------------------------------------------
      #
      # Self-update - If changes exist between the local & the remote (source) runtime versions of this script, then update it and recursively call it
      #
      if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then
        UPDATE_SELF_REQUIRED=0;
        echo -e "\nInfo:  Self-update skipped (script called with '--skip-self-update')";

      else

        CHECKSUM_LOCAL=$(if [[ -f "${SYNC_CI_LOCAL}" ]]; then cat "${SYNC_CI_LOCAL}" | sed -e '/^\s*$/d' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | cksum | cut -d" " -f1; else echo 0; fi;);  # remove commented & whitespace-only lines from script
        CHECKSUM_REMOTE=$(curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "${SYNC_CI_REMOTE}" | sed -e '/^\s*$/d' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | cksum | cut -d" " -f1);  # remove commented & whitespace-only lines from script

        CHECKSUM_ERROR_UNSIGNED=4294967295;

        TOTAL_LINES_THISSCRIPT_REMOTE=$(curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "${SYNC_CI_REMOTE}" | wc -l);

        TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED=10;

        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  SYNC_CI_REMOTE = [ ${SYNC_CI_REMOTE} ]";
          echo "Debug:  TOTAL_LINES_THISSCRIPT_REMOTE = [ ${TOTAL_LINES_THISSCRIPT_REMOTE} ]";
          echo "Debug:  TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED = [ ${TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED} ]";
          echo "";
          echo "Debug:  CHECKSUM_LOCAL = [ ${CHECKSUM_LOCAL} ]";
          echo "Debug:  CHECKSUM_REMOTE = [ ${CHECKSUM_REMOTE} ]";
          echo "Debug:  CHECKSUM_ERROR_UNSIGNED = [ ${CHECKSUM_ERROR_UNSIGNED} ]";
        fi;
        if [[ ${ARGS_FORCE_SELF_UPDATE} -eq 1 ]]; then
          UPDATE_SELF_REQUIRED=1;
          echo -e "\nInfo:  Self-update forced (via argument '--force-self-update')";
        elif [[ ${TOTAL_LINES_THISSCRIPT_REMOTE} -lt ${TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED} ]]; then
          UPDATE_SELF_REQUIRED=0;
          echo -e "\nInfo:  Self-update skipped (minimum lines of code (${TOTAL_LINES_THISSCRIPT_MINIMUM_REQUIRED}) not met while resolving remote source code (${TOTAL_LINES_THISSCRIPT_REMOTE}) from path/url \"${SYNC_CI_REMOTE}\")";
        elif [[ "${CHECKSUM_REMOTE}" == "${CHECKSUM_ERROR_UNSIGNED}" ]]; then
          UPDATE_SELF_REQUIRED=0;
          echo -e "\nInfo:  Self-update skipped (checksum of remote version (${CHECKSUM_REMOTE}) is invalid (unsigned int error))";
        elif [[ "${CHECKSUM_REMOTE}" == "${CHECKSUM_LOCAL}" ]]; then
          UPDATE_SELF_REQUIRED=0;
          echo -e "\nInfo:  Self-update skipped (checksum equal between local version (${CHECKSUM_LOCAL}) & remote version (${CHECKSUM_REMOTE}))";
        elif [[ "${CHECKSUM_REMOTE}" != "${CHECKSUM_LOCAL}" ]]; then
          UPDATE_SELF_REQUIRED=1;
          echo -e "\nInfo:  Self-update required (checksums difference detected between local version (${CHECKSUM_LOCAL}) & remote version (${CHECKSUM_REMOTE}))";
        fi;

      fi;

      if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
        echo "";
        echo "Debug:  UPDATE_SELF_REQUIRED = [ ${UPDATE_SELF_REQUIRED} ]";
      fi;

      if [[ "${UPDATE_SELF_REQUIRED}" -eq 1 ]]; then
        #
        # Update-self (recursive call) >> IS << required
        #


  # !!! DISABLED WHILE DEBUGGING !!!
  if [ 0 -eq 1 ]; then
        echo "Info:  Running self-update...";
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "Info:  Downloading updated runtime from remote path \"${SYNC_CI_REMOTE}\" to local path \"${SYNC_CI_LOCAL}\""; fi;
        BENCHMARK_START=$(date +'%s.%N');
        # Download the latest version of this script
        curl -H "Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" -sL "${SYNC_CI_REMOTE}" | sed -e '/^\s*$/d' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' > "${SYNC_CI_LOCAL}";  # remove commented & whitespace-only lines from script
        chmod 0755 "${SYNC_CI_LOCAL}";
        BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
        echo "Info:  Self-update complete";
  fi;
  # !!! DISABLED WHILE DEBUGGING !!!


        echo -e "\n---- Info:  Recursively calling latest revision of this script  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";

        # Call the updated version of this script with the same parameters passed to the current runtime
        if [[ -n "$(command -v eval 2>'/dev/null';)" ]]; then
          # 'eval' DOES exist as a local command - build a recursive callback command to pass to eval
          #
          # DEPRECATED APPROACH (local callback) - Threw preposterous amounts of unintelligable errors when the source repo's script file differed from the local script file - likely due to the fact that the script file is running within itself locally while also updating itself
          # RECURSIVE_CALLBACK_COMMAND="${SYNC_CI_LOCAL} --skip-self-update $@}";
          #
          # UPDATED APPROACH - Call script directly from source (to avoid conflict updating/running the file which is already running and executing these commands)
          RECURSIVE_CALLBACK_COMMAND="curl -H 'Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' -sL '${SYNC_CI_REMOTE}'";
          if [[ -n "$(command -v sed 2>'/dev/null';)" ]]; then
            # trim leading/trailing whitespace (from all lines)
            RECURSIVE_CALLBACK_COMMAND+=" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'";
            # remove whitespace-only lines
            RECURSIVE_CALLBACK_COMMAND+=" | sed -e '/^\s*$/d'";
          fi;
          # remove comment-only lines
          RECURSIVE_CALLBACK_COMMAND+=" | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p'";
          # remove comments appended to the end of lines
          RECURSIVE_CALLBACK_COMMAND+=" | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/'";
          # set the script to use the local bash shell
          RECURSIVE_CALLBACK_COMMAND+=" | /bin/bash -s -- --skip-self-update $@";
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "      |--> Calling [ eval \" ${RECURSIVE_CALLBACK_COMMAND}\"; ]..."; fi;
          eval " ${RECURSIVE_CALLBACK_COMMAND}"; # trigger the recursive callback

        else
          # 'eval' does NOT exist as a local command - call the recursive callback command directly (via curL) without eval
          #
          # DEPRECATED APPROACH (local callback) - Threw preposterous amounts of unintelligable errors when the source repo's script file differed from the local script file - likely due to the fact that the script file is running within itself locally while also updating itself
          # if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "      |--> Calling [ \"${SYNC_CI_LOCAL}\" --skip-self-update $@; ]..."; fi;
          # "${SYNC_CI_LOCAL}" --skip-self-update $@;
          #
          # UPDATED APPROACH - Call script directly from source (to avoid conflict updating/running the file which is already running and executing these commands)
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "      |--> Calling [ curl -H 'Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' -sL \"${SYNC_CI_REMOTE}\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -e '/^\s*$/d' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | /bin/bash -s -- --skip-self-update $@; ]..."; fi;
          curl -H 'Cache-Control: no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0' -sL "${SYNC_CI_REMOTE}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed -e '/^\s*$/d' | sed -rne 's/^(((#\!)|([^#]{2})).+)$/\1/p' | sed -re 's/^(.*(else|then|;))\s+#\s+[^;]+$/\1/' | /bin/bash -s -- --skip-self-update $@; # trigger the recursive callback

        fi;

        echo -e "\n==== Info:  Returned to parent runtime from recursive call  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";

      else
        # Update-self (recursive call) >> NOT << required  (possiblyz already running as a recursive call)
        # ------------------------------
        if [[ -z "$(command -v git 2>'/dev/null';)" ]]; then
          # git does NOT exist (as a local command)
          echo -e "\nWarning:  Unable to pull/update repository codebase - Pre-requisite command \"git\" not found";
        else
          # git DOES exist (as a local command)
          if [[ ! -d "${GIT_LOCAL_PARENT_PATH}" ]]; then
            # Ensure that the directory designated to contain git repos exists (locally)
            mkdir -p "${GIT_LOCAL_PARENT_PATH}";
          fi;
          # Fetch/Pull/Clone the Remote Repo
          echo -e "\nInfo:  Pulling the latest revision of the \"${GIT_REPO_NAME}\" repository using the \"${GIT_SOURCE_BRANCH}\" branch";
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Source (Repo URL):   ${GIT_SOURCE_REPO_URL}"; fi;
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Destination (Path):  ${GIT_LOCAL_REPO_PATH}"; fi;
          BENCHMARK_START=$(date +'%s.%N');
          # Clone the repo if it hasn't been synced, yet
          if [[ ! -d "${GIT_LOCAL_REPO_PATH}" ]]; then
            cd "${GIT_LOCAL_PARENT_PATH}" && \
            git clone --quiet "${GIT_SOURCE_REPO_URL}";
          fi;
          # Sync local workstation's commands with the repo's commands
          cd "${GIT_LOCAL_REPO_PATH}" && \
          git fetch --quiet && \
          git reset --quiet --hard "origin/${GIT_SOURCE_BRANCH}" && \
          git pull --quiet;
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # Set ownership for git-repo files as-intended
          echo -e "\nInfo:  Setting ownership for directories within the \"${GIT_REPO_NAME}\" synced repository";
          BENCHMARK_START=$(date +'%s.%N');
          # find "${GIT_LOCAL_REPO_PATH}" -type d -exec chmod 0700 "{}" ";"; # directories, find + chmod
          find "${GIT_LOCAL_REPO_PATH}" -type d -print0 | xargs -0 chmod 0700; # directories, xargs + chmod
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # Set ownership for git-repo directories as-intended
          echo -e "\nInfo:  Setting ownership for files within the \"${GIT_REPO_NAME}\" synced repository";
          BENCHMARK_START=$(date +'%s.%N');
          # find "${GIT_LOCAL_REPO_PATH}" -type f -exec chmod 0600 "{}" ";"; # files, find + chmod
          find "${GIT_LOCAL_REPO_PATH}" -type f -print0 | xargs -0 chmod 0600; # files, xargs + chmod
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
        fi;
        # ------------------------------
        if [[ ${ARGS_CHECK_WSL} -eq 1 ]]; then
          # Detect if current runtime is being executed within a WSL instance/terminal
          WSL_CHECK_EXISTS="$(command -v get_username_windows_wsl 2>'/dev/null';)";
          if [[ -n "${WSL_CHECK_EXISTS}" ]]; then
            # Attempt to resolve the Windows-user who is running the current WSL instance
            echo -e "\nInfo:  Checking for Windows Subsystem for Linux (WSL) Environment";
            WIN32_USERNAME=$(get_username_windows_wsl);
            WIN32_USER_ERRORS="$?";
          fi;
          if [[ -n "${WIN32_USERNAME}" ]] && [[ -n "${WIN32_USER_ERRORS}" ]] && [[ "${WIN32_USER_ERRORS}" == "0" ]]; then
            #  Windows OS running WSL (Windows Subsystem for Linux) - Locate source directory from amongst Win32-Host-User's files
            echo -e "\nInfo:  Detected [ Windows Subsystem for Linux (WSL) ] Environment - Checking for local repo files";
            BENCHMARK_START=$(date +'%s.%N');
            WIN32_HOMEDIR=$(find /mnt/*/Users/${WIN32_USERNAME} -mindepth 0 -maxdepth 0 -type d);
            # WIN32_USR_LOCAL=$(find ${WIN32_HOMEDIR}/Documents -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
            WIN32_USR_LOCAL=$(find "${WIN32_HOMEDIR}/Documents/"**"/${GIT_REPO_NAME}/usr/local" -maxdepth 0 -type d | head -n 1;);
            BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            if [[ -z "${WIN32_USR_LOCAL}" ]]; then
              echo "";
              echo "Error:  Unable to locate directory matching '${GIT_REPO_NAME}/usr/local' within win32-user's documents @ '${WIN32_USERNAME}'";
              EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
            else
              DIR_REPO_USR="$(dirname ${WIN32_USR_LOCAL})";
              DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Using repository directory @ [ ${DIR_REPO_BASE} ]"; fi;
            fi;
          fi;
        fi;
        # ------------------------------
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  WSL_CHECK_EXISTS = [ ${WSL_CHECK_EXISTS} ]";
          echo "Debug:  WIN32_HOMEDIR = [ ${WIN32_HOMEDIR} ]";
          echo "Debug:  WIN32_USR_LOCAL = [ ${WIN32_USR_LOCAL} ]";
          echo "Debug:  WIN32_USERNAME = [ ${WIN32_USERNAME} ]";
          echo "Debug:  WIN32_USER_ERRORS = [ ${WIN32_USER_ERRORS} ]";
        fi;
        # ------------------------------
        if [[ -z "${WIN32_HOMEDIR}" ]]; then
          # Windows/WSL check(s) failed (or were skipped)
          #  |--> Check for required Linux filepath(s) as a fallback
          echo -e "\nInfo:  Checking for local repository files within user [ $(whoami) ]'s home-directory";
          BENCHMARK_START=$(date +'%s.%N');
          WHOAMI_HOME_DIR="$(getent passwd $(id -un) | cut --delimiter=: --fields=6)";
          WHOAMI_USR_LOCAL=$(find ${WHOAMI_HOME_DIR} -mindepth 2 -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
          DIR_REPO_USR="$(dirname ${WHOAMI_USR_LOCAL})";
          DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
          RET_CODE=$?;
          if [[ ${RET_CODE} -eq 0 ]]; then
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Using [ $(whoami) ] user's repository directory @ [ ${DIR_REPO_BASE} ]"; fi;
          else 
            if [[ -n "${SUDO_USER}" ]]; then
              #  Linux OS - Locate source directory from amongst Non-Sudo User's files
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Repository not found within [ $(whoami) ] user's home-directory"; fi;
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Checking for local repository files within [ ${SUDO_USER} ] user's home-directory"; fi;
              BENCHMARK_START=$(date +'%s.%N');
              SUDOER_HOME_DIR="$(getent passwd ${SUDO_USER} | cut --delimiter=: --fields=6)";
              SUDOER_USR_LOCAL=$(find ${SUDOER_HOME_DIR} -mindepth 2 -maxdepth 5 -name 'local' -type d | grep "/${GIT_REPO_NAME}/usr/local");
              DIR_REPO_USR="$(dirname ${SUDOER_USR_LOCAL})";
              DIR_REPO_BASE="$(dirname ${DIR_REPO_USR})";
              RET_CODE=$?;
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${RET_CODE} -eq 0 ]]; then
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Using [ ${SUDO_USER} ] user's repository directory @ [ ${DIR_REPO_BASE} ]"; fi;
              fi;
            fi;
          fi;
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
        else
          # Running in WSL environment/terminal on Windows-based OS
          WSL_DIR="${WIN32_HOMEDIR}/Documents/GitHub/Coding/man";
          if [[ -d "${WSL_DIR}" ]]; then
            # Create link(s) to the Windows user's directory (who is masquerading as the current WSL User)
            if [[ -d "${HOME}" ]]; then
              # Home Dir - Current User
              if [[ ! -h "${HOME}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${HOME}/$(basename ${WSL_DIR})" ]]; then
                ln -sf "${WSL_DIR}" "${HOME}/$(basename ${WSL_DIR})";
              fi;
            fi;
            if [[ -n "${SUDO_USER}" ]]; then
              # Home Dir - Sudoer User (also create link in default user's homedir)
              SUDOER_HOMEDIR="$(getent passwd ${SUDO_USER} | cut -d: -f 6;)";
              if [[ -d "${SUDOER_HOMEDIR}" ]]; then
                if [[ ! -h "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]]; then
                  ln -sf "${WSL_DIR}" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
                fi;
                chown --no-dereference "${SUDO_USER}:$(id -gn ${SUDO_USER})" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
              fi;
            fi;
          fi;
          # Create link to WSL-User's local desktop
          WSL_DIR="${WIN32_HOMEDIR}/Desktop";
          if [[ -d "${WSL_DIR}" ]]; then
            # Current User
            if [[ -d "${HOME}" ]]; then
              if [[ ! -h "${HOME}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${HOME}/$(basename ${WSL_DIR})" ]]; then
                ln -sf "${WSL_DIR}" "${HOME}/$(basename ${WSL_DIR})";
              fi;
            fi;
            if [[ -n "${SUDO_USER}" ]]; then
              # Sudoer User (also create link in default user's homedir)
              SUDOER_HOMEDIR="$(getent passwd ${SUDO_USER} | cut -d: -f 6;)";
              if [[ -d "${SUDOER_HOMEDIR}" ]]; then
                if [[ ! -h "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]] || [[ ! -e "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})" ]]; then
                  ln -sf "${WSL_DIR}" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
                fi;
                chown --no-dereference "${SUDO_USER}:$(id -gn ${SUDO_USER})" "${SUDOER_HOMEDIR}/$(basename ${WSL_DIR})";
              fi;
            fi;
          fi;

        fi;
        # ------------------------------
        if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
          echo "";
          echo "Debug:  DIR_REPO_BASE = [ ${DIR_REPO_BASE} ]";
          echo "Debug:  DIR_REPO_USR = [ ${DIR_REPO_USR} ]";
          echo "Debug:  SUDO_USER = [ ${SUDO_USER} ]";
          echo "Debug:  SUDOER_HOMEDIR = [ ${SUDOER_HOMEDIR} ]";
        fi;
        # ------------------------------
        if [[ -z "${DIR_REPO_BASE}" ]]; then
          # Required variable(s) are empty/unset
          EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          echo "";
          echo "Error:  Required variable is empty/unset: \${DIR_REPO_BASE}";
        elif [[ ! -d "${DIR_REPO_BASE}/usr/local/bin/" ]] || [[ ! -d "${DIR_REPO_BASE}/usr/local/sbin/" ]]; then
          # Required source directory/directories not found
          EXIT_CODE=$(( ${EXIT_CODE:-0} + 1 ));
          if [[ ! -d "${DIR_REPO_BASE}/usr/local/bin/" ]]; then
            echo "";
            echo "Error:  Directory not-found: [ ${DIR_REPO_BASE}/usr/local/bin/ ]";
          fi;
          if [[ ! -d "${DIR_REPO_BASE}/usr/local/sbin/" ]]; then
            echo "";
            echo "Error:  Directory not-found: [ ${DIR_REPO_BASE}/usr/local/sbin/ ]";
          fi;
        fi;
        # ------------------------------
        if [[ "${EXIT_CODE}" == "0" ]] && [[ "${UPDATE_SELF_REQUIRED}" -ne 1 ]]; then

          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  'If' main statement block - No errors detected thus far  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;

          # No known/caught errors were thrown up-until this point - Assume prereq installs/packages/modules exist
          #  |--> Run the part of the sync job which actually performs the sync
          # ------------------------------------------------------------
          #
          # /usr/local/bin
          #
          DESTINATION_PATH="/usr/local/bin";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0755"; DIR_PERMS="0755";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------------------------------------
          #
          # /usr/local/sbin
          #
          DESTINATION_PATH="/usr/local/sbin";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0755"; DIR_PERMS="0755";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------------------------------------
          #
          # /etc/inputrc
          #
          if [[ -f '/etc/inputrc' ]]; then
            if [[ $(sed -rne 's/^#\s*(set\s+bell-style\s+none\s*)$/\0/p' '/etc/inputrc' | wc -l 2>'/dev/null';) -gt 0 ]]; then
              ### Bash - Do not bell on tab-completion (silence it, instead - especially intended for WSL (Windows Subsystem for Linux))
              BENCHMARK_START=$(date +'%s.%N');
              echo -e "\nInfo:  Setting bell-style the bell sound effect in \"/etc/inputrc\")";
              sed -i".${START_TIMESTAMP}.bak" -r -e 's/^#\s*(set\s+bell-style\s+none\s*)$/\1/' '/etc/inputrc'; # Uncomment lines starting with  [ # set bell-style none ]
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # /etc/profile
          #
          if [[ $(sed -rne 's/^MAIL=""$/\0/p' '/etc/profile' | wc -l 2>'/dev/null';) -eq 0 ]]; then
            if [[ $(sed -rne 's/^(\s*export ?.*)( MAIL)( ?.*)$/\0/p' '/etc/profile' | wc -l 2>'/dev/null';) -gt 0 ]]; then
              ### Bash - Disable "You have mail in ..." && "You have new mail in /var/spool/mail/..." alerts
              BENCHMARK_START=$(date +'%s.%N');
              echo -e "\nInfo:  Disabling \"You have new mail in ...\" alerts (commenting MAIL=... in \"/etc/profile\")";
              sed -i".${START_TIMESTAMP}.bak" -r -e 's/^ *MAIL=".+"/#\0/p' "/etc/profile"; # Comment out all lines which set variable  [ MAIL ]  to anything OTHER THAN an empty string ("")
              sed -i".${START_TIMESTAMP}.bak" -r -e '/^ *export ?.* MAIL ?.*/{' -e 'i\MAIL=""' -e '}' "/etc/profile"; # Remove MAIL from the  [ export ... ]  variables
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # /etc/pki/ca-trust/source/anchors  (Server root-certificates & CA-bundles)
          #
          if [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
            DESTINATION_PATH="/etc/pki/ca-trust/source/anchors";
            SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
            FILE_PERMS="0644"; DIR_PERMS="0644";
            echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
            BENCHMARK_START=$(date +'%s.%N');
            rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
            chown -R "root:root" "${DESTINATION_PATH}";
            find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
            find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
            if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
            dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
            BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            # Reference:  https://manuals.gfi.com/en/kerio/connect/content/server-configuration/ssl-certificates/adding-trusted-root-certificates-to-the-server-1605.html
            update-ca-trust force-enable;
            update-ca-trust extract; # Update for Rhel/Centos
          fi;
          # ------------------------------------------------------------
          #
          # /etc/profile.d/required_paths.sh
          #
          DESTINATION_PATH="/etc/profile.d/required_paths.sh";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0644"; DIR_PERMS="0644";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------------------------------------
          #
          # /etc/profile.d/bash_history_logging.sh
          #
          DESTINATION_PATH="/etc/profile.d/bash_history_logging.sh";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0644"; DIR_PERMS="0644";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------------------------------------
          #
          # /etc/whitelist.d
          #
          DESTINATION_PATH="/etc/whitelist.d";
          SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
          FILE_PERMS="0644"; DIR_PERMS="0755";
          echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
          chown -R "root:root" "${DESTINATION_PATH}";
          find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
          find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
          if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
          dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------------------------------------
          #
          # /etc/ssh/sshd_config
          #
          if [[ ${ARGS_SYNC_SSH_CONFIG} -eq 1 ]]; then

            if [[ -z "$(command -v ssh 2>'/dev/null';)" ]]; then
              echo -e "\nInfo:  Skipped SSH Config-Update - Pre-requisite command 'ssh' not found";

            else

              # ------------------------------

              # Backup & Update the sshd_config (SSH Server) file
              SSHD_CONFIG_LIVE="/etc/ssh/sshd_config";
              SSHD_CONFIG_MFA="${SSHD_CONFIG_LIVE}.mfa"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_MFA}" "${SSHD_CONFIG_MFA}";
              SSHD_CONFIG_NO_MFA="${SSHD_CONFIG_LIVE}.no_mfa"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_NO_MFA}" "${SSHD_CONFIG_NO_MFA}";
              SSHD_CONFIG_PASS_AUTH="${SSHD_CONFIG_LIVE}.password_auth"; cp -f "${DIR_REPO_BASE}${SSHD_CONFIG_PASS_AUTH}" "${SSHD_CONFIG_PASS_AUTH}";
              SSHD_CONFIG_SED="${SSHD_CONFIG_LIVE}.sed";

              if [[ ! -d "/etc/ssh/authorized_keys" ]]; then
                echo -e "\nInfo:  Creating directory \"/etc/ssh/authorized_keys\"";
                mkdir "/etc/ssh/authorized_keys";
                chmod 0755 "/etc/ssh/authorized_keys";
                chown "root:root" "/etc/ssh/authorized_keys";
              fi;

              if [[ -d "/etc/ssh/authorized_keys" ]] && [[ "$(find /etc/ssh/authorized_keys -type f | wc -l;)" != "0" ]]; then
                # Set ownership of "/etc/ssh/authorized_keys" directory as-intended
                ### chmod 0755 "/etc/ssh/authorized_keys"; # Keep for reference on intended permissions for "/etc/ssh/authorized_keys" (chmod 0755 as-of 20200310-063820)
                # At least one SSH-Key exists in the standard keyfile directory (/etc/ssh/authorized_keys)
                MFA_CONFIG_LOGIN_DUO="/etc/duo/login_duo.conf";
                MFA_CONFIG_PAM_DUO="/etc/duo/pam_duo.conf";
                if [[ -f "${MFA_CONFIG_PAM_DUO}" ]] || [[ -f "${MFA_CONFIG_LOGIN_DUO}" ]]; then
                  # Duo MFA Installed --> Use it (through PAM) for SSH-Authentication
                  SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_MFA}";
                else
                  # No MFA, but at least one SSH-Key exists
                  SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_NO_MFA}";
                fi;
              else
                # No SSH Key(s) exist in the standard keyfile directory (/etc/ssh/authorized_keys) --> Allow passwords, for now
                SSHD_CONFIG_REPLACEMENT="${SSHD_CONFIG_PASS_AUTH}";
              fi;

              # ------------------------------

              dos2unix --quiet "${SSHD_CONFIG_LIVE}";
              dos2unix --quiet "${SSHD_CONFIG_REPLACEMENT}";
              if [[ $(cmp -s "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_REPLACEMENT}" 1>'/dev/null' 2>&1; echo $?;) -eq 0 ]]; then
                # SSH-Config file already fully up-to-date
                echo -e "\nInfo:  Skipped update to SSH-Config file \"${SSHD_CONFIG_LIVE}\" - Already running the latest revision";
                echo "  |--> Checksum already up-to-date with \"$(basename "${SSHD_CONFIG_REPLACEMENT}";)\"";

              elif [[ ! -d "/home/" ]] || [[ $(find '/home/' -mindepth 1 -maxdepth 1 | wc -l 2>'/dev/null') -eq 0 ]]; then
                # Need another user other than root to SSH into this machine --> No user directories found in /home/.
                echo -e "\nInfo:  Skipped SSH Config-Update - Must create at least one user other than root whose home directory is within  [ /home/. ] to access this workstation";

              elif [[ ! -d "/etc/ssh/authorized_keys/" ]] || [[ $(find '/etc/ssh/authorized_keys/' -mindepth 1 -maxdepth 1 | wc -l 2>'/dev/null') -eq 0 ]]; then
                # Need at least one SSH-Key to exist in /etc/ssh/authorized_keys/.
                echo -e "\nInfo:  Skipped SSH Config-Update - Must create at least one private-key/public-key combo, with the public key residing @  [ /etc/ssh/authorized_keys/${SUDO_USER} ]";

              else
                # At least one Tell the user to make sure and open a new SSH terminal to avoid being locked-out of the server
                ECHO_SSH_WARNING="";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n !!! Warning !!!";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |--> Update to SSH Configuration Requested";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |--> To avoid being locked-out, ensure you have a separate SSH connection open (aside from this terminal) before continuing";
                ECHO_SSH_WARNING="${ECHO_SSH_WARNING}\n  |";
                ECHO_SSH_CONFIRMATION="  |--> Update \"/etc/ssh/sshd_config\", now? - If you are unsure, press \"n\"  (press 'y' to confirm)  ";

                if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
                  # Require user-confirmation to proceed with config-update
                  echo -e "${ECHO_SSH_WARNING}";
                  read -p "${ECHO_SSH_CONFIRMATION}" -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
                  echo "  |";
                  if [[ -z "${REPLY}" ]] || [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" != "y" ]]; then
                    # User declined the config-update
                    echo -e "  |--> Info:  Skipped SSH Config-Update - User opted-out";
                  else
                    # User accepted/confirmed the config-update
                    echo -e "  |--> Info:  Updating SSH-Config file \"${SSHD_CONFIG_LIVE}\"";
                    echo -e "  |--> Info:  Replacing with contents from file \"${SSHD_CONFIG_REPLACEMENT}\"";
                    # Backup & Update the sshd_config (SSH Server) file
                    BENCHMARK_START=$(date +'%s.%N');
                    cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_LIVE}.${START_TIMESTAMP}.bak" \
                      && wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${SSHD_CONFIG_REPLACEMENT}" -O "${SSHD_CONFIG_REPLACEMENT}" -q \
                      && chmod 0644 "${SSHD_CONFIG_REPLACEMENT}" \
                      && cp -f "${SSHD_CONFIG_REPLACEMENT}" "${SSHD_CONFIG_LIVE}" \
                      && RESTART_SERVICE_SSH=1;
                    BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                  fi;

                elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.

                  # Amongst other things, disable the "root" user and require that users login with SSH private keys (deny password-based login)
                  BENCHMARK_START=$(date +'%s.%N');
                  cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_SED}";
                  chmod 0644 "${SSHD_CONFIG_SED}";
                  sed -r -i \
                    -e "/^#?AuthorizedKeysFile/c\AuthorizedKeysFile /etc/ssh/authorized_keys/%u" \
                    -e "/^#?AuthenticationMethods/c\AuthenticationMethods publickey" \
                    -e "/^#?ChallengeResponseAuthentication/c\ChallengeResponseAuthentication no" \
                    -e "/^#?LogLevel/c\LogLevel INFO" \
                    -e "/^#?PasswordAuthentication/c\PasswordAuthentication no" \
                    -e "/^#?PermitEmptyPasswords/c\PermitEmptyPasswords no" \
                    -e "/^#?PermitRootLogin/c\PermitRootLogin no" \
                    -e "/^#?PubkeyAuthentication/c\PubkeyAuthentication yes" \
                    -e "/^#?SyslogFacility/c\SyslogFacility AUTH" \
                    -e "/^#?TCPKeepAlive/c\TCPKeepAlive no" \
                    -e "/^#?UseDNS/c\UseDNS no" \
                    -e "/^#?UsePAM/c\UsePAM yes" \
                    "${SSHD_CONFIG_SED}";

                  # Remove duplicated lines in a target file (while keeping one copy of each line)
                  echo "$(tac ${SSHD_CONFIG_SED};)" > "${SSHD_CONFIG_SED}";
                  echo "$(cat -n ${SSHD_CONFIG_SED} | sort -uk2 | sort -nk1 | cut -f2-;)" > "${SSHD_CONFIG_SED}";
                  echo "$(tac ${SSHD_CONFIG_SED};)" > "${SSHD_CONFIG_SED}";

                  # Update the service's config-file only if its checksum is not the same as the updated config-file's checksum
                  CHECKSUM_SOURCE=$(cat "${SSHD_CONFIG_LIVE}" | cksum | cut -d" " -f1;);
                  CHECKSUM_UPDATED=$(cat "${SSHD_CONFIG_SED}" | cksum | cut -d" " -f1;);
                  if [[ "${CHECKSUM_SOURCE}" != "${CHECKSUM_UPDATED}" ]]; then
                    # Require user-confirmation to proceed with config-update
                    echo -e "${ECHO_SSH_WARNING}";
                    read -p "${ECHO_SSH_CONFIRMATION}" -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress

                    echo "  |";
                    if [[ -z "${REPLY}" ]] || [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" != "y" ]]; then
                      # User declined the config-update
                      echo -e "  |--> Info:  Skipped SSH Config-Update - User opted-out";
                    else
                      # User accepted/confirmed the config-update
                      echo -e "  |--> Info:  Updating SSH-Config file \"${SSHD_CONFIG_LIVE}\"";
                      echo -e "  |--> Info:  Replacing with contents from file \"${SSHD_CONFIG_SED}\"";
                      cp -f "${SSHD_CONFIG_LIVE}" "${SSHD_CONFIG_LIVE}.${START_TIMESTAMP}.bak" \
                        && cp -f "${SSHD_CONFIG_SED}" "${SSHD_CONFIG_LIVE}" \
                        && RESTART_SERVICE_SSH=1;
                    fi;
                  else
                    echo -e "\nInfo:  Skipped SSH Config-Update - Already running the latest revision";
                  fi;
                  BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                fi;
              fi;
              # ------------------------------
            fi;
          fi;
          # ------------------------------------------------------------
          # Sync Timezone
          TZ="America/New_York";
          if [[ ${ARGS_SYNC_TIMEZONE} -eq 1 ]] && [[ "$(cat /etc/timezone;)" != "${TZ}" ]]; then
              echo -e "\nInfo:  Request to set Timezone to \"${TZ}\"";
              read -p "  |--> Set Timezone, now?  (press 'y' to confirm)" -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
              echo "";
              if [[ $REPLY =~ ^[Yy]$ ]]; then
                ln -snf "/usr/share/zoneinfo/$TZ" "/etc/localtime";
                echo $TZ > "/etc/timezone";
              fi;
            fi;
          fi;
          # ------------------------------------------------------------
          # Sync UFW ("Uncomplicated Firewall")
          ENABLE_CRON_DDNS_UPDATER=0;
          if [[ ${ARGS_SYNC_UFW} -eq 1 ]]; then
            # Ensure that the UFW module exists on the current Linux Distro before continuing to setting it up
            if [[ -n "$(command -v ufw 2>'/dev/null';)" ]]; then
              # Distros: Debian, Ubuntu, etc.
              if [[ $(ufw status 1>'/dev/null' 2>&1; echo $?;) -eq 0 ]]; then
                # Check if UFW is enabled or disabled
                UFW_ENABLED=$(test -n "$(ufw status | grep 'Status' | grep 'inactive')" && echo 0 || echo 1;);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
                  echo "";
                  echo "Debug:  UFW_ENABLED = [ ${UFW_ENABLED} ]";
                fi;

                if [[ ${UFW_ENABLED} -eq 0 ]]; then
                  # UFW DISABLED - Show recommendations for general-practice setup
                  echo -e "\nWarning:  Firewall package UFW (default Debian firewall) is installed but disabled";
                  echo -e "Warning:  Firewall package UFW (default Debian firewall) is installed but disabled";
                  echo -e "  |--> Call this script with \"--debug\" for suggested resolution path";
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
                    echo "  |";
                    echo "  |--> Recommend applying the following ruleset, enabling UFW, then tweaking rules as-needed:";
                    echo "         ufw allow proto tcp from 10.0.0.0/8 to any port 22;     # Allow incoming SSH/SFTP requests from LAN IPv4 addresses (RFC-1918)";
                    echo "         ufw allow proto tcp from 172.16.0.0/12 to any port 22;  # Allow incoming SSH/SFTP requests from LAN IPv4 addresses (RFC-1918)";
                    echo "         ufw allow proto tcp from 192.168.0.0/16 to any port 22; # Allow incoming SSH/SFTP requests from LAN IPv4 addresses (RFC-1918)";
                    echo "         ufw allow proto tcp from 0.0.0.0/0 to any port 80;      # Allow incoming HTTP requests from any IPv4 address";
                    echo "         ufw allow proto tcp from 0.0.0.0/0 to any port 443;     # Allow incoming HTTPS requests from any IPv4 address";
                    echo "         ufw allow proto tcp from ::/0 to any port 80;           # Allow incoming HTTP requests from any IPv6 address";
                    echo "         ufw allow proto tcp from ::/0 to any port 443;          # Allow incoming HTTPS requests from any IPv6 address";
                    echo "         ufw default allow outgoing; # allow all non-matched outgoing requests";
                    echo "         ufw default deny incoming;  # deny all non-matched incoming requests";
                    echo "         ufw logging on; # enable logging";
                    echo "         ufw enable; # enforce all ufw rules, including aforementioned 'allow' and 'deny' rules (if applied)";
                    echo "         ## Add / remove / tweak UFW rules as-needed (based on machine's environment and designated purpose)";
                  fi;
                  # UFW DISABLED - Prompt for confirmation before auto-enabling UFW (and potentially locking user out of being able to access the machine)
                  # echo "  |";
                  # echo "  |--> UFW sync requested, however UFW is currently disabled";
                  # echo "  |";
                  # read -p "  |--> Enable UFW, now? - If you are unsure, press \"n\"   (press 'y' to confirm)  " -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
                  # if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  #   ufw enable;
                  #   # Re-check UFW Enabled/Disabled Status
                  #   UFW_ENABLED=$(test -n "$(ufw status | grep 'Status' | grep 'inactive')" && echo 0 || echo 1;);
                  #   if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
                  #     echo "";
                  #     echo "Debug:  UFW_ENABLED = [ ${UFW_ENABLED} ]";
                  #   fi;
                  # fi;
                fi;
                if [[ ${UFW_ENABLED} -eq 1 ]]; then
                  # UFW is enabled
                  RESTART_SERVICE_UFW=1;
                  RESTART_SERVICE_SSH=1;
                  # Sync Cronjob Automation:  UFW DDNS Updates
                  if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
                    ENABLE_CRON_DDNS_UPDATER=1;
                  fi;
                fi;
              fi;
            elif [[ -n "$(command -v firewall-cmd 2>'/dev/null';)" ]]; then
              # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
              if [[ $(systemctl is-enabled firewalld 1>'/dev/null' 2>&1; echo $?) -eq 0 ]]; then
                ENABLE_CRON_DDNS_UPDATER=1;
              fi;
            fi;
            if [[ ${ENABLE_CRON_DDNS_UPDATER} -ne 0 ]]; then
              # Enable a cronjob to perform scheduled updates/syncs of the UFW firewall whitelist
              CRON_DDNS_UFW_UPDATE="/etc/cron.d/CRON_ddns_ufw_update";
              echo -e "\nInfo:  Updating \"${CRON_DDNS_UFW_UPDATE}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${CRON_DDNS_UFW_UPDATE}" -O "${CRON_DDNS_UFW_UPDATE}" -q \
                && chmod 0644 "${CRON_DDNS_UFW_UPDATE}" \
                && RESTART_SERVICE_CRON=1;
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;

          fi;
          # ------------------------------------------------------------
          #
          # /etc/cron.d/...
          #
          if [[ ${ARGS_CRONJOB_SYNC} -eq 1 ]]; then
            RESTART_SERVICE_CRON=1;
            # ------------------------------------------------------------
            #
            # /etc/cron.d/CRON_sync_cloud_infrastructure
            #
            DESTINATION_PATH="/etc/cron.d/CRON_sync_cloud_infrastructure";
            SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
            FILE_PERMS="0644"; DIR_PERMS="0644";
            echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
            BENCHMARK_START=$(date +'%s.%N');
            rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
            chown -R "root:root" "${DESTINATION_PATH}";
            find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
            find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
            if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
            dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
            BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
            if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            # ------------------------------------------------------------
            #
            # /etc/cron.d/CRON_certbot_renew_all
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              if [[ -n "$(command -v certbot 2>'/dev/null';)" ]]; then
                DESTINATION_PATH="/etc/cron.d/CRON_certbot_renew_all";
                if [[ -f "${DESTINATION_PATH}" ]]; then
                  REPLY="y";
                else
                  echo ""; read -p "Enable SSL (TLS/HTTPS) certificate auto-renewal, now? (Runs \"certbot_renew_all\" every Sunday at 06:10 AM)  (press 'y' to confirm)  " -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
                fi;
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                  FILE_PERMS="0644"; DIR_PERMS="0644";
                  echo -e "\n  |--> Confirmed - Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                  BENCHMARK_START=$(date +'%s.%N');
                  rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                  chown -R "root:root" "${DESTINATION_PATH}";
                  find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                  find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                  if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                  dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                  BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                else
                  echo "  |--> Denied - SSL (TLS/HTTPS) certificate auto-renewal disabled";
                fi;
              fi;
            fi;
            # ------------------------------------------------------------
            #
            # /etc/cron.d/CRON_journalctl_logfile_cleanup
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              DESTINATION_PATH="/etc/cron.d/CRON_journalctl_logfile_cleanup";
              if [[ -f "${DESTINATION_PATH}" ]]; then
                REPLY="y";
              else
                echo ""; read -p "Enable Logfile Auto-Cleanup, now? (Runs \"journalctl --vacuum-time=90d --vacuum-size=5G\" every day at 02:00 AM)  (press 'y' to confirm)  " -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
              fi;
              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\n  |--> Confirmed - Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              else
                echo "  |--> Denied - Logfile Auto-Cleanup disabled";
              fi;
            fi;
            # ------------------------------------------------------------
            #
            # /etc/cron.d/CRON_update_dns_config
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              DESTINATION_PATH="/etc/cron.d/CRON_update_dns_config";
              if [[ -f "${DESTINATION_PATH}" ]]; then
                REPLY="y";
              else
                echo ""; read -p "Enable DNS-server sync, now? (Runs \"update_dns_config\" daily at 04:05 AM)  (press 'y' to confirm)  " -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
              fi;
              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\n  |--> Confirmed - Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              else
                echo "  |--> Denied - DNS-server sync disabled";
              fi;
            fi;
            # ------------------------------------------------------------
            #
            # /etc/cron.d/CRON_update_system
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              DESTINATION_PATH="/etc/cron.d/CRON_update_system";
              if [[ -f "${DESTINATION_PATH}" ]]; then
                REPLY="y";
              else
                echo ""; read -p "Enable system & package weekly updates, now? (Runs \"update_system\" every Sunday at 04:10 AM)  (press 'y' to confirm)  " -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
              fi;

              if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\n  |--> Confirmed - Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              else
                echo "  |--> Denied - System & package weekly updates disabled";
              fi;
            fi;
            # ------------------------------------------------------------
            #
            # /etc/cron.d/CRON_raspi_hw_monitor
            #
            if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
              RaspberryPi_Check=$(grep 'Hardware' '/proc/cpuinfo' | sed --regexp-extended --quiet --expression='s/^Hardware\s*:\s*([a-zA-Z0-9]+)\s*$/\1/p');
              if [[ "${RaspberryPi_Check}" == "BCM2835" ]]; then
                DESTINATION_PATH="/etc/cron.d/CRON_raspi_hw_monitor";
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              fi;
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # ${HOME}/.
          #
          # Get list of files to Copy into Home-Dirs
          COPY_FROM_SOURCE="${DIR_REPO_BASE}/root";
          FILES_TO_COPY=$(ls -hAl "${COPY_FROM_SOURCE}/" | awk '{print $9}');
          # User-List whose Home-Dirs will be updated
          LINUX_BASH_USERS=$(cat /etc/passwd | grep /bin/bash | awk -F':' '{ print $1}');
          # Determine longest Username to enhance log-readability by left-padding (right-aligning) output text, below
          #   NOTE: Linux usernames cannot be longer than 32 chars (according to useradd man page)
          USERNAMES_MOSTCHARS=0;
          for EACH_SSH_USER in ${LINUX_BASH_USERS}; do
            EACH_USERNAME_LENGTH=${#EACH_SSH_USER};
            if (( ${EACH_USERNAME_LENGTH} > ${USERNAMES_MOSTCHARS} )); then
              USERNAMES_MOSTCHARS=${EACH_USERNAME_LENGTH};
            fi;
          done;
          echo -e "\nInfo:  Syncing Bash-Config & Terminal-Formatting files for SSH-Enabled users...$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
          BENCHMARK_START=$(date +'%s.%N');
          # Begin copying files to SSH-Enabled User-Home Directories
          for EACH_FILE in ${FILES_TO_COPY}; do
            if [[ ! -z "${EACH_FILE// }" ]]; then # Ignore blank/empty filenames
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> \"~/${EACH_FILE}\""; fi;
              SRC_FULLPATH="${COPY_FROM_SOURCE}/${EACH_FILE}";
              for EACH_SSH_USER in ${LINUX_BASH_USERS}; do
                EACH_PRIMARY_GROUP="$(id -gn ${EACH_SSH_USER})";
                DIR_USER_HOME="$(eval echo ~${EACH_SSH_USER})";
                # Only copy files to SSH-Enabled user home-directories (plus root)
                if [[ -d "${DIR_USER_HOME}/.ssh" ]] || [[ -f "${DIR_USER_HOME}/.bash_history" ]] || [[ -f "/etc/ssh/authorized_keys/${EACH_SSH_USER}" ]] || [[ "${EACH_SSH_USER}" == "root" ]]; then
                  DEST_FULLPATH="${DIR_USER_HOME}/${EACH_FILE}";
                  if [[ -d "${SRC_FULLPATH}" ]] && [[ -f "${SRC_FULLPATH}/"* ]]; then
                    # Directories containing at least one file
                    dos2unix --quiet "${SRC_FULLPATH}/"*;
                    cp -rf "${SRC_FULLPATH}" "${DIR_USER_HOME}";
                    chown -R "${EACH_SSH_USER}:${EACH_PRIMARY_GROUP}" "${DEST_FULLPATH}";
                    chmod -R 600 "${DEST_FULLPATH}";
                    chmod 700 "${DEST_FULLPATH}";
                  else
                    # Files
                    dos2unix --quiet "${SRC_FULLPATH}";
                    cp -f "${SRC_FULLPATH}" "${DEST_FULLPATH}";
                    chown "${EACH_SSH_USER}:${EACH_PRIMARY_GROUP}" "${DEST_FULLPATH}";
                    chmod 600 "${DEST_FULLPATH}";
                  fi;
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then USERNAME_RPAD="  "$(printf '%-'${USERNAMES_MOSTCHARS}'s' "|----> ${EACH_SSH_USER}"); echo "${USERNAME_RPAD}:  [ ${DEST_FULLPATH} ]"; fi;
                fi;
              done;
            fi;
          done;
          BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |"; fi;
          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
          # ------------------------------------------------------------
          #
          # /etc/cron.d/CRON_ddns_updater
          #
          if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
            if [[ ${ARGS_SYNC_DDNS} -eq 1 ]]; then
              # Syncs the cronjob trigger to update a given DNS-Provider with current WAN IP
              CRON_UPDATE_DNS_A_RECORDS="/etc/cron.d/CRON_ddns_updater";
              echo -e "\nInfo:  Updating \"${CRON_UPDATE_DNS_A_RECORDS}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');

              /usr/local/bin/ddns_setup \
                && wget "https://raw.githubusercontent.com/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/${GIT_SOURCE_BRANCH}${CRON_UPDATE_DNS_A_RECORDS}" -O "/etc/cron.d/CRON_ddns_updater" -q \
                && chmod 0644 "/etc/cron.d/CRON_ddns_updater" \
                && RESTART_SERVICE_CRON=1;

              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # Jenkins Items
          #
          if [[ ${ARGS_SYNC_JENKINS} -eq 1 ]] && [[ ${RESTART_SERVICE_JENKINS} -eq 0 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="jenkins";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -ne 0 ]]; then
              # Service not found locally
              echo -e "\nInfo:  Skipped Jenkins config-sync - No local 'jenkins' service exists";
            else
              # ------------------------------------------------------------
              #
              # Set directory permissions as-intended
              #  |--> Fix for issue where jenkins images wouldn't show-up while on "Manage Jenkins" page (or directly accessing them)
              #
              DESTINATION_PATH="/var/cache/jenkins";
              DIR_PERMS="0751";
              chmod "${DIR_PERMS}" "${DESTINATION_PATH}";

              DESTINATION_PATH="/var/cache/jenkins/war";
              DIR_PERMS="0755";
              chmod "${DIR_PERMS}" "${DESTINATION_PATH}";
              # ------------------------------------------------------------
              #
              # /var/cache/jenkins/war
              #
              DESTINATION_PATH="/var/cache/jenkins/war";
              SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
              FILE_PERMS="0644"; DIR_PERMS="0755";
              echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
              chown -R "jenkins:jenkins" "${DESTINATION_PATH}";
              find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
              find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
              if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
              dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              # /var/cache/jenkins/war - Set policies to stop Selinux from blocking access to cached Jenkins images within "/var/cache/jenkins/war/images"
              if [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
                chcon -R -t httpd_sys_content_t "/var/cache/jenkins/war/images/";
                semanage fcontext -a -t httpd_sys_content_t "/var/cache/jenkins/war/images/";
              fi;
              # ------------------------------------------------------------
              #
              # /etc/default/jenkins
              #
              DESTINATION_PATH="/etc/default/jenkins";
              SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
              FILE_PERMS="0644"; DIR_PERMS="0755";
              echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
              chown -R "jenkins:jenkins" "${DESTINATION_PATH}";
              find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
              find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
              if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
              dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              if [[ ${ARGS_CRONJOB_REMOVE} -eq 0 ]]; then
                # ------------------------------------------------------------
                #
                # /etc/cron.d/CRON_jenkins_export_config
                #
                DESTINATION_PATH="/etc/cron.d/CRON_jenkins_export_config";
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                # ------------------------------------------------------------
                #
                # /etc/cron.d/CRON_jenkins_log_cleanup
                #
                DESTINATION_PATH="/etc/cron.d/CRON_jenkins_log_cleanup";
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                # ------------------------------------------------------------
                #
                # /etc/cron.d/CRON_jenkins_sync_ci
                #
                DESTINATION_PATH="/etc/cron.d/CRON_jenkins_sync_ci";
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
                # ------------------------------------------------------------
                #
                # /etc/cron.d/CRON_jenkins_warfile_update
                #
                DESTINATION_PATH="/etc/cron.d/CRON_jenkins_warfile_update";
                SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
                FILE_PERMS="0644"; DIR_PERMS="0644";
                echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
                BENCHMARK_START=$(date +'%s.%N');
                rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform file-sync
                chown -R "root:root" "${DESTINATION_PATH}";
                find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
                find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
                if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
                dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
                BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
                if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
              fi;
              RESTART_SERVICE_JENKINS=1;
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # /etc/nginx
          #
          if [[ ${ARGS_SYNC_NGINX} -eq 1 ]]; then
            if [[ -z "$(command -v nginx 2>'/dev/null';)" ]]; then
              # NGINX does NOT exist locally
              echo -e "\nInfo:  Skipped NGINX sync - No local 'nginx' service exists";
            else
              # NGINX exists locally
              # ------------------------------------------------------------
              #
              # /etc/nginx
              #
              DESTINATION_PATH="/etc/nginx"; if [[ ! -d  "${DESTINATION_PATH}" ]]; then mkdir -p "${DESTINATION_PATH}"; fi;
              SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
              FILE_PERMS="0644"; DIR_PERMS="0755";
              echo -e "\nInfo:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
              chown -R "root:root" "${DESTINATION_PATH}";
              find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
              find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
              if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
              dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
              # ------------------------------------------------------------
              #
              # /var/www/error
              #
              DESTINATION_PATH="/var/www/error"; if [[ ! -d  "${DESTINATION_PATH}" ]]; then mkdir -p "${DESTINATION_PATH}"; fi;
              SOURCE_PATH="${DIR_REPO_BASE}${DESTINATION_PATH}"; if [[ -d "${SOURCE_PATH}" ]]; then SOURCE_PATH+="/"; fi;
              FILE_PERMS="0644"; DIR_PERMS="0755";
              echo -e "  |--> Info:  Updating \"${DESTINATION_PATH}\" with changes from \"${GIT_REPO_NAME}\" repository$(if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;)";
              BENCHMARK_START=$(date +'%s.%N');
              rsync --archive --inplace --checksum --quiet "${SOURCE_PATH}" "${DESTINATION_PATH}"; # Perform dir-sync
              chown -R "root:root" "${DESTINATION_PATH}";
              find "${DESTINATION_PATH}" -type d -exec chmod ${DIR_PERMS} '{}' \; ; # chmod directories
              find "${DESTINATION_PATH}" -type f -exec chmod ${FILE_PERMS} '{}' \; ; # chmod files
              if [[ "${FILE_PERMS}" == "${DIR_PERMS}" ]]; then chmod -R "${FILE_PERMS}" "${DESTINATION_PATH}"; fi; # Ensure permissions are set as-intended
              dos2unix --quiet "${DESTINATION_PATH}"/*; # Convert any CRLF files to force line-endings to be LF (only)
              # Check if running on Fedora
              if [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
                # Selinux - Whitelist/allow read actions on a specific file/directory filepath (otherwise Selinux (by-default) will prevent read requests on said filepath(s) for the local web service user (commonly 'wwww-data') and therefore fail web requests to servers hosted from this device
                chcon -Rt httpd_sys_content_t "${DESTINATION_PATH}";
              fi;
              # Ensure that the Diffie-Hellman parameter for DHE ciphersuites exists
              DH_PARAM_FILEPATH="/etc/ssl/certs/dhparam.pem";
              DH_ENCRYPTION_BIT_STRENGTH=2048; # 2048 / 3072 / 4096 <-- Do not go lower than 2048 (as-of late 2019)
              if [[ ! -f "${DH_PARAM_FILEPATH}" ]]; then
                echo "  |--> Creating Diffie-Hellman Parameters File @ \"${DH_PARAM_FILEPATH}\"...";
                openssl dhparam -out "${DH_PARAM_FILEPATH}" ${DH_ENCRYPTION_BIT_STRENGTH};
              fi;
              # Set the environment-specific web-server runtime user
              if [[ -n "$(command -v apt 2>'/dev/null';)" ]]; then # Distros: Debian, Ubuntu, etc.
                sed -i 's|user www-data;|user www-data;|g' "/etc/nginx/nginx.conf";
              elif [[ -n "$(command -v yum 2>'/dev/null';)" ]]; then # Distros: Fedora, Oracle Linux, Red Hat Enterprise Linux, CentOS, etc.
                sed -i 's|user www-data;|user nginx;|g' "/etc/nginx/nginx.conf";
              fi;
              # Walk through all sites-available (from repo), resolve their WAN IPv4 address & compare it against the WAN IPv4 address of the current device - only sync if the two IPv4 addresses are a direct match
              find "/etc/nginx/sites-available/" -mindepth 1 -maxdepth 1 -name "*.nginx" -type "f" -print0 | while IFS= read -r -d $'\0' Each_SitesAvailable; do
                Each_FQDN=$(echo "$(basename ${Each_SitesAvailable})" | rev | cut -d. -f 1 --complement | rev);
                Each_SitesEnabled="/etc/nginx/sites-enabled/${Each_FQDN}";
                if [[ "$(dig +short ${Each_FQDN};)" == "$(hostname -i | awk '{print $1}';)" ]] || [[ "$(dig +short ${Each_FQDN};)" == "$(curl -s -4 https://icanhazip.com;)" ]]; then
                  # The FQDN resolved to an IPv4 which matches the WAN IPv4 address of the current device - Set this FQDN to "Enabled" for the current NGINX server
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |\n  |--> $(if [[ -e "${Each_SitesEnabled}" ]]; then echo "Updating"; else echo "Enabling"; fi;) NGINX FQDN \"${Each_FQDN}\" via file \"${Each_SitesEnabled}\"\n        |--> Exact match found between [ the resolved WAN IPv4 address for target FQDN \"${Each_FQDN}\" ] and [ the resolved WAN IPv4 address of the current device ]"; fi;
                  ln -sf "${Each_SitesAvailable}" "${Each_SitesEnabled}";
                elif [[ "${Each_FQDN}" == "$(hostname --fqdn;)" ]]; then
                  # The FQDN is equal to the hostname (as a FQDN) for the current device
                  if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |\n  |--> $(if [[ -e "${Each_SitesEnabled}" ]]; then echo "Updating"; else echo "Enabling"; fi;) NGINX FQDN \"${Each_FQDN}\" via file \"${Each_SitesEnabled}\"\n        |--> Exact match found between [ the target FQDN \"${Each_FQDN}\" ] and [ the hostname (formatted as a FQDN) of the current device ]"; fi;
                  ln -sf "${Each_SitesAvailable}" "${Each_SitesEnabled}";
                else
                  # Skipped - The FQDN doesnt match the hostname or IPv4 address of the current device
                  rm -f "${Each_SitesAvailable}";
                  if [[ -h "${Each_SitesEnabled}" ]] || [[ -f "${Each_SitesEnabled}" ]]; then
                    # If this NGINX site (FQDN) is enabled (but should be disabled as no matches were found between it and the current device), then disable it
                    if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "  |\n  |--> Disabling NGINX FQDN \"${Each_FQDN}\" (removing/unlinking \"${Each_SitesEnabled}\")\n        |--> No match found between [ the resolved WAN IPv4 address for target FQDN \"${Each_FQDN}\" ] and [ the resolved WAN IPv4 address of the current device ]\n        |--> No match found between [ the target FQDN \"${Each_FQDN}\" ] and [ the hostname (formatted as a FQDN) of the current device ]"; fi;
                    if [[ -h "${Each_SitesEnabled}" ]]; then
                      unlink "${Each_SitesEnabled}";
                    elif [[ -f "${Each_SitesEnabled}" ]]; then
                      rm -f "${Each_SitesEnabled}";
                    fi;
                  fi;
                fi;
              done;
              # Setup certbot to reload NGINX whenever a Let's Encrypt HTTPS certificate is renewed via certbot
              if [[ -d "/etc/letsencrypt/renewal-hooks/deploy" ]] && [[ ! -e "/etc/letsencrypt/renewal-hooks/deploy/reload_nginx" ]] && [[ -f "/usr/local/sbin/reload_nginx" ]]; then
                ln --symbolic --verbose --force "/usr/local/sbin/reload_nginx" "/etc/letsencrypt/renewal-hooks/deploy/reload_nginx";
              fi;
              RESTART_SERVICE_NGINX=1;
              BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${BENCHMARK_START})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
              if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo "  |--> Finished after ${BENCHMARK_DELTA}s"; fi;
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # /etc/cron.d/CRON_*
          #
          if [[ ${ARGS_CRONJOB_REMOVE} -eq 1 ]]; then
            #
            # --remove-cronjobs  -->  Removes all scripts matching /etc/cron.d/CRON_*  (other than CRON_sync_cloud_infrastructure, which triggers this, current script)
            #
            LOCAL_CRON_D_SCRIPTS=$(ls /etc/cron.d/CRON_* | grep -v "$(basename "${SYNC_CI_LOCAL}";)" 2>'/dev/null';);
            COUNT_CRON_D_SCRIPTS=$(echo "${LOCAL_CRON_D_SCRIPTS}" | wc -l;);
            if [[ $(echo "${LOCAL_CRON_D_SCRIPTS}" | wc -l) -eq 0 ]]; then
              echo -e "\nInfo:  Skipped removal of cron sync-triggers - No scripts found matching \"/etc/cron.d/CRON_*\"";
            else
              echo -e "\nInfo:  Found ${COUNT_CRON_D_SCRIPTS} cron sync-triggers matching \"/etc/cron.d/CRON_*\":";
              for EACH_CRON_TRIGGER in ${LOCAL_CRON_D_SCRIPTS}; do
                echo "  |";
                read -p "  |--> Are you sure you want to remove cron sync-trigger \"${EACH_CRON_TRIGGER}\", now?  (press 'y' to confirm)" -n 1 -t 60 REPLY <'/dev/tty'; # Await single keypress
                if [[ -n "${REPLY}" ]] && [[ "$(echo ${REPLY} | tr '[:upper:]' '[:lower:]';)" == "y" ]]; then
                  echo "  |----> Confirmed - Removing \"${EACH_CRON_TRIGGER}\"...";
                  rm -f "${EACH_CRON_TRIGGER}";
                else
                  echo "  |----> Skipped - Leaving \"${EACH_CRON_TRIGGER}\" unchanged/unaffected";
                fi;
              done;
            fi;
          fi;
          # ------------------------------------------------------------
          # DELETE OLD FILES / UNLINK OLD SYMLINKS
          # ------------------------------------------------------------
          DELDIR="/usr/local/bin/";
          TO_DEL="${DELDIR}/docker_check_installation_status"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/docker_list_volume_maps.sh"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/get_enabled_services"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
          TO_DEL="${DELDIR}/get_lan_ipv4"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/get_open_ports"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/get_port_available_on_localhost"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
          TO_DEL="${DELDIR}/get_ports_open_on_host"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
          TO_DEL="${DELDIR}/get_services"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
          TO_DEL="${DELDIR}/get_unused_local_port"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/get_wan_ip"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/get_wan_ipv4"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/port_sniffer"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/wsl_get_windows_username"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;

          DELDIR="/usr/local/sbin/";
          TO_DEL="${DELDIR}/disable_mail_alerts"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/install_devops_packages"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/install_minio_mc"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/install_mongod"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/install_utilities"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/install_vmware-tools"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/jenkins-config-export"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/jenkins_war_update"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/sudoer_edit"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/sync_Cloud_infrastructure"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2020-01-06
          TO_DEL="${DELDIR}/sync_config_gpg_git"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/sync_gpg_git_config"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 2019-12-12
          TO_DEL="${DELDIR}/sync_upd"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/update_bins_from_sftp"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi;
          TO_DEL="${DELDIR}/wsl_reboot"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20191220-164752

          DELDIR="/etc/ddns_ufw_update";
          if [[ -d "${DELDIR}" ]]; then rm -rf "${DELDIR}" fi; # Added 20200115-223014 - Moved to /etc/whitelist.d

          DELDIR="/etc/nginx/conf.ddns";
          TO_DEL="${DELDIR}/rz.mcavallo.com"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200115-224618
          TO_DEL="${DELDIR}/x1.mcavallo.com"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200115-224620

          DELDIR="/etc/nginx/conf.vendor";
          TO_DEL="${DELDIR}/LAN_subnets.conf"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-192658

          DELDIR="/var/cache/jenkins/war";
          TO_DEL="${DELDIR}Jenkins Artwork (jenkins.io).url"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456
          TO_DEL="${DELDIR}Jenkins Material Theme (GitHub).url"; if [[ -h "${TO_DEL}" ]]; then unlink "${TO_DEL}"; elif [[ -f "${TO_DEL}" ]]; then rm -f "${TO_DEL}"; fi; # Added 20200114-161456

          # ------------------------------------------------------------
          #
          # cron  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_CRON} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            CRON_SVC_FOUND=0; CRON_SVC_NAMES="";
            # cron  -->  Restart service
            SERVICE_NAME="cron";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              CRON_SVC_FOUND=$((${CRON_SVC_FOUND}+1));
              CRON_SVC_NAMES="${SERVICE_NAME}";
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            fi;
            # crond  -->  Restart service
            SERVICE_NAME="crond";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              CRON_SVC_FOUND=$((${CRON_SVC_FOUND}+1));
              CRON_SVC_NAMES="${SERVICE_NAME}";
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            fi;
            if [[ ${CRON_SVC_FOUND} -eq 0 ]]; then
              echo "Skipped restart of the \"${CRON_SVC_NAMES}\" service(s) (not found as a local service)";
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # jenkins  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_JENKINS} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="jenkins";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # nginx  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_NGINX} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="nginx";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/local/sbin/reload_nginx;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;

          # ------------------------------------------------------------
          #
          # ssh  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_SSH} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="sshd";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/sbin/service "${SERVICE_NAME}" restart;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # ufw  -->  Restart service (if needed)
          #
          if [[ ${RESTART_SERVICE_UFW} -eq 1 ]] && [[ -x "/usr/sbin/service" ]]; then
            SERVICE_NAME="ufw";
            SERVICE_RET_CODE=$(/bin/systemctl list-unit-files --no-legend --no-pager --full "${SERVICE_NAME}.service" | grep "^${SERVICE_NAME}.service" 1>'/dev/null' 2>&1; echo $?;);
            if [[ ${SERVICE_RET_CODE} -eq 0 ]]; then
              /usr/sbin/service "${SERVICE_NAME}" restart;
              if [[ -n "$(command -v ${SERVICE_NAME} 2>'/dev/null';)" ]]; then
                ufw reload;
              fi;
              /usr/sbin/service "${SERVICE_NAME}" status --no-pager --full;
            else
              echo "Skipped restart of the \"${SERVICE_NAME}\" service (not found as a local service)";
            fi;
          fi;
          # ------------------------------------------------------------
          #
          # Logfile cleanup
          #
          DIR_TO_CLEANUP="${LOGDIR}";
          if [[ -z "${DIR_TO_CLEANUP}" ]]; then
            if [[ -w "/var/log/" ]]; then
              DIR_TO_CLEANUP="/var/log/$(basename "${SYNC_CI_LOCAL}";)";
            else
              DIR_TO_CLEANUP="${HOME}/sync_cloud_infrastructure_logs";
            fi;
          fi;
          if [[ "${DIR_TO_CLEANUP}" == "${HOME}/sync_cloud_infrastructure_logs" ]] || [[ "${DIR_TO_CLEANUP}" == "/var/log/$(basename "${SYNC_CI_LOCAL}";)" ]]; then
            if [[ -d "${DIR_TO_CLEANUP}" ]]; then
              # Cleanup log files (older than the retention-policy's max-allowed-age)
              echo -e "\nInfo:  Cleaning logs older than 3 days old from directory \"${DIR_TO_CLEANUP}\"";
              find "${DIR_TO_CLEANUP}" -type f -mtime +3 -exec rm -- '{}' \; ;
            fi;
          fi;
          echo "";

        elif [[ "${UPDATE_SELF_REQUIRED}" -eq 1 ]]; then

          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  'Elif' main statement block - Skipped main 'If' in favor of recursive call handling it (UPDATE_SELF_REQUIRED=[${UPDATE_SELF_REQUIRED}])  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;

        elif [[ -n "${EXIT_CODE}" ]] && [[ "${EXIT_CODE}" != "0" ]]; then

          echo -e "\nError:  One or more errors were found (EXIT_CODE=[${EXIT_CODE}])  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";

        else 

          if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  'Else' statement placeholder (to-be-updated) (EXIT_CODE=[${EXIT_CODE}])  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;

        fi;

      fi;

    fi;

  fi;

fi;


# ------------------------------------------------------------
#
# Log the ending timestamp for the current runtime
#

END_SECONDS_NANOSECONDS="$(date +'%s.%N';)";
END_EPOCHSECONDS="$(echo ${END_SECONDS_NANOSECONDS} | cut --delimiter '.' --fields 1;)";
END_DATETIME="$(date --date=@${END_EPOCHSECONDS} +'%Y-%m-%d %H:%M:%S';)";
END_BENCHMARK_DELTA=$(echo "scale=4; ($(date +'%s.%N') - ${START_SECONDS_NANOSECONDS})/1" | bc -l | sed 's/\([^0-9]\|^\)\(\.[0-9]*\)/\10\2/g';);
if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then
  echo "";
  echo "Debug:  END_SECONDS_NANOSECONDS = [ ${END_SECONDS_NANOSECONDS} ]";
  echo "Debug:  END_EPOCHSECONDS = [ ${END_EPOCHSECONDS} ]";
  echo "Debug:  END_DATETIME = [ ${END_DATETIME} ]";
  echo "Debug:  END_BENCHMARK_DELTA = [ ${END_BENCHMARK_DELTA} ]";
fi;

echo -e "\n== Info:  End of $(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo "recursive "; fi;)\"$(basename "${SYNC_CI_LOCAL}";)\" runtime at [ ${END_DATETIME} ] after [ ${END_BENCHMARK_DELTA}s ]  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))";


# ------------------------------------------------------------
#
# Exit & return the value of EXIT_CODE back to caller
#
if [[ ${ARGS_DEBUG_MODE} -eq 1 ]]; then echo -e "\nDebug:  Calling [ exit ${EXIT_CODE:-0}; ]...  (ID: ${START_SECONDS_NANOSECONDS}$(if [[ ${ARGS_SKIP_SELF_UPDATE} -eq 1 ]]; then echo " - recursive call"; fi;))"; fi;
test ${ARGS_SKIP_SELF_UPDATE:-0} -eq 0 && exit ${EXIT_CODE:-0};


# ------------------------------------------------------------